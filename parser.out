Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> code_entity
Rule 2     code_entity -> iterative_statement
Rule 3     code_entity -> conditional_statement
Rule 4     code_entity -> expression
Rule 5     code_entity -> input_function
Rule 6     code_entity -> output_function
Rule 7     iterative_statement -> WHILE expression COLON start ENDWHILE
Rule 8     iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
Rule 9     conditional_statement -> IF expression COLON start ELSE start ENDIF
Rule 10    conditional_statement -> IF expression COLON start ENDIF
Rule 11    expression -> assignment_statement
Rule 12    assignment_statement -> or_statement
Rule 13    assignment_statement -> IDENTIFIER EQUALS or_statement
Rule 14    or_statement -> and_statement
Rule 15    or_statement -> or_statement OR and_statement
Rule 16    and_statement -> equality_statement
Rule 17    and_statement -> and_statement AND equality_statement
Rule 18    equality_statement -> relational_statement
Rule 19    equality_statement -> equality_statement EQ relational_statement
Rule 20    equality_statement -> equality_statement NEQ relational_statement
Rule 21    relational_statement -> add_statement
Rule 22    relational_statement -> relational_statement LT add_statement
Rule 23    relational_statement -> relational_statement GT add_statement
Rule 24    relational_statement -> relational_statement LTEQ add_statement
Rule 25    relational_statement -> relational_statement GTEQ add_statement
Rule 26    add_statement -> multiply_statement
Rule 27    add_statement -> add_statement PLUS multiply_statement
Rule 28    add_statement -> add_statement MINUS multiply_statement
Rule 29    multiply_statement -> unary_statement
Rule 30    multiply_statement -> multiply_statement TIMES unary_statement
Rule 31    multiply_statement -> multiply_statement DIVIDE unary_statement
Rule 32    multiply_statement -> multiply_statement MOD unary_statement
Rule 33    unary_statement -> exponent
Rule 34    unary_statement -> MINUS unary_statement
Rule 35    unary_statement -> NOT unary_statement
Rule 36    exponent -> term
Rule 37    exponent -> term POWER unary_statement
Rule 38    term -> IDENTIFIER
Rule 39    term -> atom
Rule 40    term -> LPAREN expression RPAREN
Rule 41    atom -> INTEGER
Rule 42    atom -> FLOAT
Rule 43    atom -> STRING
Rule 44    atom -> TRUE
Rule 45    atom -> FALSE
Rule 46    atom -> LBRACKET elements RBRACKET
Rule 47    atom -> IDENTIFIER LBRACKET INTEGER RBRACKET
Rule 48    elements -> elements INTEGER
Rule 49    elements -> elements FLOAT
Rule 50    elements -> <empty>
Rule 51    input_function -> INPUT LPAREN IDENTIFIER RPAREN
Rule 52    output_function -> PRINT LPAREN term RPAREN

Terminals, with rules where they appear

AND                  : 17
COLON                : 7 8 9 10
COMMA                : 8 8
DIVIDE               : 31
ELSE                 : 9
ENDFOR               : 8
ENDIF                : 9 10
ENDWHILE             : 7
EQ                   : 19
EQUALS               : 8 13
FALSE                : 45
FLOAT                : 42 49
FOR                  : 8
GT                   : 23
GTEQ                 : 25
IDENTIFIER           : 13 38 47 51
IF                   : 9 10
INPUT                : 51
INTEGER              : 41 47 48
LBRACKET             : 46 47
LPAREN               : 40 51 52
LT                   : 22
LTEQ                 : 24
MINUS                : 28 34
MOD                  : 32
NEQ                  : 20
NOT                  : 35
OR                   : 15
PLUS                 : 27
POWER                : 37
PRINT                : 52
RBRACKET             : 46 47
RPAREN               : 40 51 52
STRING               : 43
TIMES                : 30
TRUE                 : 44
WHILE                : 7
error                : 

Nonterminals, with rules where they appear

add_statement        : 21 22 23 24 25 27 28
and_statement        : 14 15 17
assignment_statement : 11
atom                 : 39
code_entity          : 1
conditional_statement : 3
elements             : 46 48 49
equality_statement   : 16 17 19 20
exponent             : 33
expression           : 4 7 8 8 8 9 10 40
input_function       : 5
iterative_statement  : 2
multiply_statement   : 26 27 28 30 31 32
or_statement         : 12 13 15
output_function      : 6
relational_statement : 18 19 20 22 23 24 25
start                : 7 8 9 9 10 0
term                 : 36 37 52
unary_statement      : 29 30 31 32 34 35 37

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . expression
    (5) code_entity -> . input_function
    (6) code_entity -> . output_function
    (7) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (8) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (9) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (10) conditional_statement -> . IF expression COLON start ENDIF
    (11) expression -> . assignment_statement
    (51) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (52) output_function -> . PRINT LPAREN term RPAREN
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    start                          shift and go to state 1
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 1

    (0) S' -> start .



state 2

    (1) start -> code_entity .

    $end            reduce using rule 1 (start -> code_entity .)
    ENDWHILE        reduce using rule 1 (start -> code_entity .)
    ELSE            reduce using rule 1 (start -> code_entity .)
    ENDIF           reduce using rule 1 (start -> code_entity .)
    ENDFOR          reduce using rule 1 (start -> code_entity .)


state 3

    (2) code_entity -> iterative_statement .

    $end            reduce using rule 2 (code_entity -> iterative_statement .)
    ENDWHILE        reduce using rule 2 (code_entity -> iterative_statement .)
    ELSE            reduce using rule 2 (code_entity -> iterative_statement .)
    ENDIF           reduce using rule 2 (code_entity -> iterative_statement .)
    ENDFOR          reduce using rule 2 (code_entity -> iterative_statement .)


state 4

    (3) code_entity -> conditional_statement .

    $end            reduce using rule 3 (code_entity -> conditional_statement .)
    ENDWHILE        reduce using rule 3 (code_entity -> conditional_statement .)
    ELSE            reduce using rule 3 (code_entity -> conditional_statement .)
    ENDIF           reduce using rule 3 (code_entity -> conditional_statement .)
    ENDFOR          reduce using rule 3 (code_entity -> conditional_statement .)


state 5

    (4) code_entity -> expression .

    $end            reduce using rule 4 (code_entity -> expression .)
    ENDWHILE        reduce using rule 4 (code_entity -> expression .)
    ELSE            reduce using rule 4 (code_entity -> expression .)
    ENDIF           reduce using rule 4 (code_entity -> expression .)
    ENDFOR          reduce using rule 4 (code_entity -> expression .)


state 6

    (5) code_entity -> input_function .

    $end            reduce using rule 5 (code_entity -> input_function .)
    ENDWHILE        reduce using rule 5 (code_entity -> input_function .)
    ELSE            reduce using rule 5 (code_entity -> input_function .)
    ENDIF           reduce using rule 5 (code_entity -> input_function .)
    ENDFOR          reduce using rule 5 (code_entity -> input_function .)


state 7

    (6) code_entity -> output_function .

    $end            reduce using rule 6 (code_entity -> output_function .)
    ENDWHILE        reduce using rule 6 (code_entity -> output_function .)
    ELSE            reduce using rule 6 (code_entity -> output_function .)
    ENDIF           reduce using rule 6 (code_entity -> output_function .)
    ENDFOR          reduce using rule 6 (code_entity -> output_function .)


state 8

    (7) iterative_statement -> WHILE . expression COLON start ENDWHILE
    (11) expression -> . assignment_statement
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 34
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 9

    (8) iterative_statement -> FOR . EQUALS expression COMMA expression COMMA expression COLON start ENDFOR

    EQUALS          shift and go to state 35


state 10

    (9) conditional_statement -> IF . expression COLON start ELSE start ENDIF
    (10) conditional_statement -> IF . expression COLON start ENDIF
    (11) expression -> . assignment_statement
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 36
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 11

    (11) expression -> assignment_statement .

    $end            reduce using rule 11 (expression -> assignment_statement .)
    COLON           reduce using rule 11 (expression -> assignment_statement .)
    RPAREN          reduce using rule 11 (expression -> assignment_statement .)
    COMMA           reduce using rule 11 (expression -> assignment_statement .)
    ENDWHILE        reduce using rule 11 (expression -> assignment_statement .)
    ELSE            reduce using rule 11 (expression -> assignment_statement .)
    ENDIF           reduce using rule 11 (expression -> assignment_statement .)
    ENDFOR          reduce using rule 11 (expression -> assignment_statement .)


state 12

    (51) input_function -> INPUT . LPAREN IDENTIFIER RPAREN

    LPAREN          shift and go to state 37


state 13

    (40) term -> LPAREN . expression RPAREN
    (11) expression -> . assignment_statement
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 38
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 14

    (13) assignment_statement -> IDENTIFIER . EQUALS or_statement
    (38) term -> IDENTIFIER .
    (47) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET

    EQUALS          shift and go to state 39
    POWER           reduce using rule 38 (term -> IDENTIFIER .)
    TIMES           reduce using rule 38 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 38 (term -> IDENTIFIER .)
    MOD             reduce using rule 38 (term -> IDENTIFIER .)
    PLUS            reduce using rule 38 (term -> IDENTIFIER .)
    MINUS           reduce using rule 38 (term -> IDENTIFIER .)
    LT              reduce using rule 38 (term -> IDENTIFIER .)
    GT              reduce using rule 38 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 38 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 38 (term -> IDENTIFIER .)
    EQ              reduce using rule 38 (term -> IDENTIFIER .)
    NEQ             reduce using rule 38 (term -> IDENTIFIER .)
    AND             reduce using rule 38 (term -> IDENTIFIER .)
    OR              reduce using rule 38 (term -> IDENTIFIER .)
    $end            reduce using rule 38 (term -> IDENTIFIER .)
    COLON           reduce using rule 38 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 38 (term -> IDENTIFIER .)
    COMMA           reduce using rule 38 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 38 (term -> IDENTIFIER .)
    ELSE            reduce using rule 38 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 38 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 38 (term -> IDENTIFIER .)
    LBRACKET        shift and go to state 40


state 15

    (52) output_function -> PRINT . LPAREN term RPAREN

    LPAREN          shift and go to state 41


state 16

    (36) exponent -> term .
    (37) exponent -> term . POWER unary_statement

    TIMES           reduce using rule 36 (exponent -> term .)
    DIVIDE          reduce using rule 36 (exponent -> term .)
    MOD             reduce using rule 36 (exponent -> term .)
    PLUS            reduce using rule 36 (exponent -> term .)
    MINUS           reduce using rule 36 (exponent -> term .)
    LT              reduce using rule 36 (exponent -> term .)
    GT              reduce using rule 36 (exponent -> term .)
    LTEQ            reduce using rule 36 (exponent -> term .)
    GTEQ            reduce using rule 36 (exponent -> term .)
    EQ              reduce using rule 36 (exponent -> term .)
    NEQ             reduce using rule 36 (exponent -> term .)
    AND             reduce using rule 36 (exponent -> term .)
    OR              reduce using rule 36 (exponent -> term .)
    $end            reduce using rule 36 (exponent -> term .)
    COLON           reduce using rule 36 (exponent -> term .)
    RPAREN          reduce using rule 36 (exponent -> term .)
    COMMA           reduce using rule 36 (exponent -> term .)
    ENDWHILE        reduce using rule 36 (exponent -> term .)
    ELSE            reduce using rule 36 (exponent -> term .)
    ENDIF           reduce using rule 36 (exponent -> term .)
    ENDFOR          reduce using rule 36 (exponent -> term .)
    POWER           shift and go to state 42


state 17

    (12) assignment_statement -> or_statement .
    (15) or_statement -> or_statement . OR and_statement

    $end            reduce using rule 12 (assignment_statement -> or_statement .)
    COLON           reduce using rule 12 (assignment_statement -> or_statement .)
    RPAREN          reduce using rule 12 (assignment_statement -> or_statement .)
    COMMA           reduce using rule 12 (assignment_statement -> or_statement .)
    ENDWHILE        reduce using rule 12 (assignment_statement -> or_statement .)
    ELSE            reduce using rule 12 (assignment_statement -> or_statement .)
    ENDIF           reduce using rule 12 (assignment_statement -> or_statement .)
    ENDFOR          reduce using rule 12 (assignment_statement -> or_statement .)
    OR              shift and go to state 43


state 18

    (14) or_statement -> and_statement .
    (17) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 14 (or_statement -> and_statement .)
    $end            reduce using rule 14 (or_statement -> and_statement .)
    COLON           reduce using rule 14 (or_statement -> and_statement .)
    RPAREN          reduce using rule 14 (or_statement -> and_statement .)
    COMMA           reduce using rule 14 (or_statement -> and_statement .)
    ENDWHILE        reduce using rule 14 (or_statement -> and_statement .)
    ELSE            reduce using rule 14 (or_statement -> and_statement .)
    ENDIF           reduce using rule 14 (or_statement -> and_statement .)
    ENDFOR          reduce using rule 14 (or_statement -> and_statement .)
    AND             shift and go to state 44


state 19

    (16) and_statement -> equality_statement .
    (19) equality_statement -> equality_statement . EQ relational_statement
    (20) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 16 (and_statement -> equality_statement .)
    OR              reduce using rule 16 (and_statement -> equality_statement .)
    $end            reduce using rule 16 (and_statement -> equality_statement .)
    COLON           reduce using rule 16 (and_statement -> equality_statement .)
    RPAREN          reduce using rule 16 (and_statement -> equality_statement .)
    COMMA           reduce using rule 16 (and_statement -> equality_statement .)
    ENDWHILE        reduce using rule 16 (and_statement -> equality_statement .)
    ELSE            reduce using rule 16 (and_statement -> equality_statement .)
    ENDIF           reduce using rule 16 (and_statement -> equality_statement .)
    ENDFOR          reduce using rule 16 (and_statement -> equality_statement .)
    EQ              shift and go to state 45
    NEQ             shift and go to state 46


state 20

    (18) equality_statement -> relational_statement .
    (22) relational_statement -> relational_statement . LT add_statement
    (23) relational_statement -> relational_statement . GT add_statement
    (24) relational_statement -> relational_statement . LTEQ add_statement
    (25) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 18 (equality_statement -> relational_statement .)
    NEQ             reduce using rule 18 (equality_statement -> relational_statement .)
    AND             reduce using rule 18 (equality_statement -> relational_statement .)
    OR              reduce using rule 18 (equality_statement -> relational_statement .)
    $end            reduce using rule 18 (equality_statement -> relational_statement .)
    COLON           reduce using rule 18 (equality_statement -> relational_statement .)
    RPAREN          reduce using rule 18 (equality_statement -> relational_statement .)
    COMMA           reduce using rule 18 (equality_statement -> relational_statement .)
    ENDWHILE        reduce using rule 18 (equality_statement -> relational_statement .)
    ELSE            reduce using rule 18 (equality_statement -> relational_statement .)
    ENDIF           reduce using rule 18 (equality_statement -> relational_statement .)
    ENDFOR          reduce using rule 18 (equality_statement -> relational_statement .)
    LT              shift and go to state 47
    GT              shift and go to state 48
    LTEQ            shift and go to state 49
    GTEQ            shift and go to state 50


state 21

    (21) relational_statement -> add_statement .
    (27) add_statement -> add_statement . PLUS multiply_statement
    (28) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 21 (relational_statement -> add_statement .)
    GT              reduce using rule 21 (relational_statement -> add_statement .)
    LTEQ            reduce using rule 21 (relational_statement -> add_statement .)
    GTEQ            reduce using rule 21 (relational_statement -> add_statement .)
    EQ              reduce using rule 21 (relational_statement -> add_statement .)
    NEQ             reduce using rule 21 (relational_statement -> add_statement .)
    AND             reduce using rule 21 (relational_statement -> add_statement .)
    OR              reduce using rule 21 (relational_statement -> add_statement .)
    $end            reduce using rule 21 (relational_statement -> add_statement .)
    COLON           reduce using rule 21 (relational_statement -> add_statement .)
    RPAREN          reduce using rule 21 (relational_statement -> add_statement .)
    COMMA           reduce using rule 21 (relational_statement -> add_statement .)
    ENDWHILE        reduce using rule 21 (relational_statement -> add_statement .)
    ELSE            reduce using rule 21 (relational_statement -> add_statement .)
    ENDIF           reduce using rule 21 (relational_statement -> add_statement .)
    ENDFOR          reduce using rule 21 (relational_statement -> add_statement .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 22

    (26) add_statement -> multiply_statement .
    (30) multiply_statement -> multiply_statement . TIMES unary_statement
    (31) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (32) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 26 (add_statement -> multiply_statement .)
    MINUS           reduce using rule 26 (add_statement -> multiply_statement .)
    LT              reduce using rule 26 (add_statement -> multiply_statement .)
    GT              reduce using rule 26 (add_statement -> multiply_statement .)
    LTEQ            reduce using rule 26 (add_statement -> multiply_statement .)
    GTEQ            reduce using rule 26 (add_statement -> multiply_statement .)
    EQ              reduce using rule 26 (add_statement -> multiply_statement .)
    NEQ             reduce using rule 26 (add_statement -> multiply_statement .)
    AND             reduce using rule 26 (add_statement -> multiply_statement .)
    OR              reduce using rule 26 (add_statement -> multiply_statement .)
    $end            reduce using rule 26 (add_statement -> multiply_statement .)
    COLON           reduce using rule 26 (add_statement -> multiply_statement .)
    RPAREN          reduce using rule 26 (add_statement -> multiply_statement .)
    COMMA           reduce using rule 26 (add_statement -> multiply_statement .)
    ENDWHILE        reduce using rule 26 (add_statement -> multiply_statement .)
    ELSE            reduce using rule 26 (add_statement -> multiply_statement .)
    ENDIF           reduce using rule 26 (add_statement -> multiply_statement .)
    ENDFOR          reduce using rule 26 (add_statement -> multiply_statement .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55


state 23

    (34) unary_statement -> MINUS . unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    unary_statement                shift and go to state 56
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 24

    (29) multiply_statement -> unary_statement .

    TIMES           reduce using rule 29 (multiply_statement -> unary_statement .)
    DIVIDE          reduce using rule 29 (multiply_statement -> unary_statement .)
    MOD             reduce using rule 29 (multiply_statement -> unary_statement .)
    PLUS            reduce using rule 29 (multiply_statement -> unary_statement .)
    MINUS           reduce using rule 29 (multiply_statement -> unary_statement .)
    LT              reduce using rule 29 (multiply_statement -> unary_statement .)
    GT              reduce using rule 29 (multiply_statement -> unary_statement .)
    LTEQ            reduce using rule 29 (multiply_statement -> unary_statement .)
    GTEQ            reduce using rule 29 (multiply_statement -> unary_statement .)
    EQ              reduce using rule 29 (multiply_statement -> unary_statement .)
    NEQ             reduce using rule 29 (multiply_statement -> unary_statement .)
    AND             reduce using rule 29 (multiply_statement -> unary_statement .)
    OR              reduce using rule 29 (multiply_statement -> unary_statement .)
    $end            reduce using rule 29 (multiply_statement -> unary_statement .)
    COLON           reduce using rule 29 (multiply_statement -> unary_statement .)
    RPAREN          reduce using rule 29 (multiply_statement -> unary_statement .)
    COMMA           reduce using rule 29 (multiply_statement -> unary_statement .)
    ENDWHILE        reduce using rule 29 (multiply_statement -> unary_statement .)
    ELSE            reduce using rule 29 (multiply_statement -> unary_statement .)
    ENDIF           reduce using rule 29 (multiply_statement -> unary_statement .)
    ENDFOR          reduce using rule 29 (multiply_statement -> unary_statement .)


state 25

    (33) unary_statement -> exponent .

    TIMES           reduce using rule 33 (unary_statement -> exponent .)
    DIVIDE          reduce using rule 33 (unary_statement -> exponent .)
    MOD             reduce using rule 33 (unary_statement -> exponent .)
    PLUS            reduce using rule 33 (unary_statement -> exponent .)
    MINUS           reduce using rule 33 (unary_statement -> exponent .)
    LT              reduce using rule 33 (unary_statement -> exponent .)
    GT              reduce using rule 33 (unary_statement -> exponent .)
    LTEQ            reduce using rule 33 (unary_statement -> exponent .)
    GTEQ            reduce using rule 33 (unary_statement -> exponent .)
    EQ              reduce using rule 33 (unary_statement -> exponent .)
    NEQ             reduce using rule 33 (unary_statement -> exponent .)
    AND             reduce using rule 33 (unary_statement -> exponent .)
    OR              reduce using rule 33 (unary_statement -> exponent .)
    $end            reduce using rule 33 (unary_statement -> exponent .)
    COLON           reduce using rule 33 (unary_statement -> exponent .)
    RPAREN          reduce using rule 33 (unary_statement -> exponent .)
    COMMA           reduce using rule 33 (unary_statement -> exponent .)
    ENDWHILE        reduce using rule 33 (unary_statement -> exponent .)
    ELSE            reduce using rule 33 (unary_statement -> exponent .)
    ENDIF           reduce using rule 33 (unary_statement -> exponent .)
    ENDFOR          reduce using rule 33 (unary_statement -> exponent .)


state 26

    (35) unary_statement -> NOT . unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    unary_statement                shift and go to state 58
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 27

    (39) term -> atom .

    POWER           reduce using rule 39 (term -> atom .)
    TIMES           reduce using rule 39 (term -> atom .)
    DIVIDE          reduce using rule 39 (term -> atom .)
    MOD             reduce using rule 39 (term -> atom .)
    PLUS            reduce using rule 39 (term -> atom .)
    MINUS           reduce using rule 39 (term -> atom .)
    LT              reduce using rule 39 (term -> atom .)
    GT              reduce using rule 39 (term -> atom .)
    LTEQ            reduce using rule 39 (term -> atom .)
    GTEQ            reduce using rule 39 (term -> atom .)
    EQ              reduce using rule 39 (term -> atom .)
    NEQ             reduce using rule 39 (term -> atom .)
    AND             reduce using rule 39 (term -> atom .)
    OR              reduce using rule 39 (term -> atom .)
    $end            reduce using rule 39 (term -> atom .)
    COLON           reduce using rule 39 (term -> atom .)
    RPAREN          reduce using rule 39 (term -> atom .)
    COMMA           reduce using rule 39 (term -> atom .)
    ENDWHILE        reduce using rule 39 (term -> atom .)
    ELSE            reduce using rule 39 (term -> atom .)
    ENDIF           reduce using rule 39 (term -> atom .)
    ENDFOR          reduce using rule 39 (term -> atom .)


state 28

    (41) atom -> INTEGER .

    POWER           reduce using rule 41 (atom -> INTEGER .)
    TIMES           reduce using rule 41 (atom -> INTEGER .)
    DIVIDE          reduce using rule 41 (atom -> INTEGER .)
    MOD             reduce using rule 41 (atom -> INTEGER .)
    PLUS            reduce using rule 41 (atom -> INTEGER .)
    MINUS           reduce using rule 41 (atom -> INTEGER .)
    LT              reduce using rule 41 (atom -> INTEGER .)
    GT              reduce using rule 41 (atom -> INTEGER .)
    LTEQ            reduce using rule 41 (atom -> INTEGER .)
    GTEQ            reduce using rule 41 (atom -> INTEGER .)
    EQ              reduce using rule 41 (atom -> INTEGER .)
    NEQ             reduce using rule 41 (atom -> INTEGER .)
    AND             reduce using rule 41 (atom -> INTEGER .)
    OR              reduce using rule 41 (atom -> INTEGER .)
    $end            reduce using rule 41 (atom -> INTEGER .)
    COLON           reduce using rule 41 (atom -> INTEGER .)
    RPAREN          reduce using rule 41 (atom -> INTEGER .)
    COMMA           reduce using rule 41 (atom -> INTEGER .)
    ENDWHILE        reduce using rule 41 (atom -> INTEGER .)
    ELSE            reduce using rule 41 (atom -> INTEGER .)
    ENDIF           reduce using rule 41 (atom -> INTEGER .)
    ENDFOR          reduce using rule 41 (atom -> INTEGER .)


state 29

    (42) atom -> FLOAT .

    POWER           reduce using rule 42 (atom -> FLOAT .)
    TIMES           reduce using rule 42 (atom -> FLOAT .)
    DIVIDE          reduce using rule 42 (atom -> FLOAT .)
    MOD             reduce using rule 42 (atom -> FLOAT .)
    PLUS            reduce using rule 42 (atom -> FLOAT .)
    MINUS           reduce using rule 42 (atom -> FLOAT .)
    LT              reduce using rule 42 (atom -> FLOAT .)
    GT              reduce using rule 42 (atom -> FLOAT .)
    LTEQ            reduce using rule 42 (atom -> FLOAT .)
    GTEQ            reduce using rule 42 (atom -> FLOAT .)
    EQ              reduce using rule 42 (atom -> FLOAT .)
    NEQ             reduce using rule 42 (atom -> FLOAT .)
    AND             reduce using rule 42 (atom -> FLOAT .)
    OR              reduce using rule 42 (atom -> FLOAT .)
    $end            reduce using rule 42 (atom -> FLOAT .)
    COLON           reduce using rule 42 (atom -> FLOAT .)
    RPAREN          reduce using rule 42 (atom -> FLOAT .)
    COMMA           reduce using rule 42 (atom -> FLOAT .)
    ENDWHILE        reduce using rule 42 (atom -> FLOAT .)
    ELSE            reduce using rule 42 (atom -> FLOAT .)
    ENDIF           reduce using rule 42 (atom -> FLOAT .)
    ENDFOR          reduce using rule 42 (atom -> FLOAT .)


state 30

    (43) atom -> STRING .

    POWER           reduce using rule 43 (atom -> STRING .)
    TIMES           reduce using rule 43 (atom -> STRING .)
    DIVIDE          reduce using rule 43 (atom -> STRING .)
    MOD             reduce using rule 43 (atom -> STRING .)
    PLUS            reduce using rule 43 (atom -> STRING .)
    MINUS           reduce using rule 43 (atom -> STRING .)
    LT              reduce using rule 43 (atom -> STRING .)
    GT              reduce using rule 43 (atom -> STRING .)
    LTEQ            reduce using rule 43 (atom -> STRING .)
    GTEQ            reduce using rule 43 (atom -> STRING .)
    EQ              reduce using rule 43 (atom -> STRING .)
    NEQ             reduce using rule 43 (atom -> STRING .)
    AND             reduce using rule 43 (atom -> STRING .)
    OR              reduce using rule 43 (atom -> STRING .)
    $end            reduce using rule 43 (atom -> STRING .)
    COLON           reduce using rule 43 (atom -> STRING .)
    RPAREN          reduce using rule 43 (atom -> STRING .)
    COMMA           reduce using rule 43 (atom -> STRING .)
    ENDWHILE        reduce using rule 43 (atom -> STRING .)
    ELSE            reduce using rule 43 (atom -> STRING .)
    ENDIF           reduce using rule 43 (atom -> STRING .)
    ENDFOR          reduce using rule 43 (atom -> STRING .)


state 31

    (44) atom -> TRUE .

    POWER           reduce using rule 44 (atom -> TRUE .)
    TIMES           reduce using rule 44 (atom -> TRUE .)
    DIVIDE          reduce using rule 44 (atom -> TRUE .)
    MOD             reduce using rule 44 (atom -> TRUE .)
    PLUS            reduce using rule 44 (atom -> TRUE .)
    MINUS           reduce using rule 44 (atom -> TRUE .)
    LT              reduce using rule 44 (atom -> TRUE .)
    GT              reduce using rule 44 (atom -> TRUE .)
    LTEQ            reduce using rule 44 (atom -> TRUE .)
    GTEQ            reduce using rule 44 (atom -> TRUE .)
    EQ              reduce using rule 44 (atom -> TRUE .)
    NEQ             reduce using rule 44 (atom -> TRUE .)
    AND             reduce using rule 44 (atom -> TRUE .)
    OR              reduce using rule 44 (atom -> TRUE .)
    $end            reduce using rule 44 (atom -> TRUE .)
    COLON           reduce using rule 44 (atom -> TRUE .)
    RPAREN          reduce using rule 44 (atom -> TRUE .)
    COMMA           reduce using rule 44 (atom -> TRUE .)
    ENDWHILE        reduce using rule 44 (atom -> TRUE .)
    ELSE            reduce using rule 44 (atom -> TRUE .)
    ENDIF           reduce using rule 44 (atom -> TRUE .)
    ENDFOR          reduce using rule 44 (atom -> TRUE .)


state 32

    (45) atom -> FALSE .

    POWER           reduce using rule 45 (atom -> FALSE .)
    TIMES           reduce using rule 45 (atom -> FALSE .)
    DIVIDE          reduce using rule 45 (atom -> FALSE .)
    MOD             reduce using rule 45 (atom -> FALSE .)
    PLUS            reduce using rule 45 (atom -> FALSE .)
    MINUS           reduce using rule 45 (atom -> FALSE .)
    LT              reduce using rule 45 (atom -> FALSE .)
    GT              reduce using rule 45 (atom -> FALSE .)
    LTEQ            reduce using rule 45 (atom -> FALSE .)
    GTEQ            reduce using rule 45 (atom -> FALSE .)
    EQ              reduce using rule 45 (atom -> FALSE .)
    NEQ             reduce using rule 45 (atom -> FALSE .)
    AND             reduce using rule 45 (atom -> FALSE .)
    OR              reduce using rule 45 (atom -> FALSE .)
    $end            reduce using rule 45 (atom -> FALSE .)
    COLON           reduce using rule 45 (atom -> FALSE .)
    RPAREN          reduce using rule 45 (atom -> FALSE .)
    COMMA           reduce using rule 45 (atom -> FALSE .)
    ENDWHILE        reduce using rule 45 (atom -> FALSE .)
    ELSE            reduce using rule 45 (atom -> FALSE .)
    ENDIF           reduce using rule 45 (atom -> FALSE .)
    ENDFOR          reduce using rule 45 (atom -> FALSE .)


state 33

    (46) atom -> LBRACKET . elements RBRACKET
    (48) elements -> . elements INTEGER
    (49) elements -> . elements FLOAT
    (50) elements -> .

    RBRACKET        reduce using rule 50 (elements -> .)
    INTEGER         reduce using rule 50 (elements -> .)
    FLOAT           reduce using rule 50 (elements -> .)

    elements                       shift and go to state 59

state 34

    (7) iterative_statement -> WHILE expression . COLON start ENDWHILE

    COLON           shift and go to state 60


state 35

    (8) iterative_statement -> FOR EQUALS . expression COMMA expression COMMA expression COLON start ENDFOR
    (11) expression -> . assignment_statement
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 61
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 36

    (9) conditional_statement -> IF expression . COLON start ELSE start ENDIF
    (10) conditional_statement -> IF expression . COLON start ENDIF

    COLON           shift and go to state 62


state 37

    (51) input_function -> INPUT LPAREN . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 63


state 38

    (40) term -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 64


state 39

    (13) assignment_statement -> IDENTIFIER EQUALS . or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    or_statement                   shift and go to state 65
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 40

    (47) atom -> IDENTIFIER LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 66


state 41

    (52) output_function -> PRINT LPAREN . term RPAREN
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    term                           shift and go to state 67
    atom                           shift and go to state 27

state 42

    (37) exponent -> term POWER . unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    term                           shift and go to state 16
    unary_statement                shift and go to state 68
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 43

    (15) or_statement -> or_statement OR . and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    and_statement                  shift and go to state 69
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 44

    (17) and_statement -> and_statement AND . equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    equality_statement             shift and go to state 70
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 45

    (19) equality_statement -> equality_statement EQ . relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    relational_statement           shift and go to state 71
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 46

    (20) equality_statement -> equality_statement NEQ . relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    relational_statement           shift and go to state 72
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 47

    (22) relational_statement -> relational_statement LT . add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    add_statement                  shift and go to state 73
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 48

    (23) relational_statement -> relational_statement GT . add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    add_statement                  shift and go to state 74
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 49

    (24) relational_statement -> relational_statement LTEQ . add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    add_statement                  shift and go to state 75
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 50

    (25) relational_statement -> relational_statement GTEQ . add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    add_statement                  shift and go to state 76
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 51

    (27) add_statement -> add_statement PLUS . multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    multiply_statement             shift and go to state 77
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 52

    (28) add_statement -> add_statement MINUS . multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    multiply_statement             shift and go to state 78
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 53

    (30) multiply_statement -> multiply_statement TIMES . unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    unary_statement                shift and go to state 79
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 54

    (31) multiply_statement -> multiply_statement DIVIDE . unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    unary_statement                shift and go to state 80
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 55

    (32) multiply_statement -> multiply_statement MOD . unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 57
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    unary_statement                shift and go to state 81
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 56

    (34) unary_statement -> MINUS unary_statement .

    TIMES           reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    DIVIDE          reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    MOD             reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    PLUS            reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    MINUS           reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    LT              reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    GT              reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    LTEQ            reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    GTEQ            reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    EQ              reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    NEQ             reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    AND             reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    OR              reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    $end            reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    COLON           reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    RPAREN          reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    COMMA           reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    ENDWHILE        reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    ELSE            reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    ENDIF           reduce using rule 34 (unary_statement -> MINUS unary_statement .)
    ENDFOR          reduce using rule 34 (unary_statement -> MINUS unary_statement .)


state 57

    (38) term -> IDENTIFIER .
    (47) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET

    POWER           reduce using rule 38 (term -> IDENTIFIER .)
    TIMES           reduce using rule 38 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 38 (term -> IDENTIFIER .)
    MOD             reduce using rule 38 (term -> IDENTIFIER .)
    PLUS            reduce using rule 38 (term -> IDENTIFIER .)
    MINUS           reduce using rule 38 (term -> IDENTIFIER .)
    LT              reduce using rule 38 (term -> IDENTIFIER .)
    GT              reduce using rule 38 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 38 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 38 (term -> IDENTIFIER .)
    EQ              reduce using rule 38 (term -> IDENTIFIER .)
    NEQ             reduce using rule 38 (term -> IDENTIFIER .)
    AND             reduce using rule 38 (term -> IDENTIFIER .)
    OR              reduce using rule 38 (term -> IDENTIFIER .)
    $end            reduce using rule 38 (term -> IDENTIFIER .)
    COLON           reduce using rule 38 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 38 (term -> IDENTIFIER .)
    COMMA           reduce using rule 38 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 38 (term -> IDENTIFIER .)
    ELSE            reduce using rule 38 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 38 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 38 (term -> IDENTIFIER .)
    LBRACKET        shift and go to state 40


state 58

    (35) unary_statement -> NOT unary_statement .

    TIMES           reduce using rule 35 (unary_statement -> NOT unary_statement .)
    DIVIDE          reduce using rule 35 (unary_statement -> NOT unary_statement .)
    MOD             reduce using rule 35 (unary_statement -> NOT unary_statement .)
    PLUS            reduce using rule 35 (unary_statement -> NOT unary_statement .)
    MINUS           reduce using rule 35 (unary_statement -> NOT unary_statement .)
    LT              reduce using rule 35 (unary_statement -> NOT unary_statement .)
    GT              reduce using rule 35 (unary_statement -> NOT unary_statement .)
    LTEQ            reduce using rule 35 (unary_statement -> NOT unary_statement .)
    GTEQ            reduce using rule 35 (unary_statement -> NOT unary_statement .)
    EQ              reduce using rule 35 (unary_statement -> NOT unary_statement .)
    NEQ             reduce using rule 35 (unary_statement -> NOT unary_statement .)
    AND             reduce using rule 35 (unary_statement -> NOT unary_statement .)
    OR              reduce using rule 35 (unary_statement -> NOT unary_statement .)
    $end            reduce using rule 35 (unary_statement -> NOT unary_statement .)
    COLON           reduce using rule 35 (unary_statement -> NOT unary_statement .)
    RPAREN          reduce using rule 35 (unary_statement -> NOT unary_statement .)
    COMMA           reduce using rule 35 (unary_statement -> NOT unary_statement .)
    ENDWHILE        reduce using rule 35 (unary_statement -> NOT unary_statement .)
    ELSE            reduce using rule 35 (unary_statement -> NOT unary_statement .)
    ENDIF           reduce using rule 35 (unary_statement -> NOT unary_statement .)
    ENDFOR          reduce using rule 35 (unary_statement -> NOT unary_statement .)


state 59

    (46) atom -> LBRACKET elements . RBRACKET
    (48) elements -> elements . INTEGER
    (49) elements -> elements . FLOAT

    RBRACKET        shift and go to state 82
    INTEGER         shift and go to state 83
    FLOAT           shift and go to state 84


state 60

    (7) iterative_statement -> WHILE expression COLON . start ENDWHILE
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . expression
    (5) code_entity -> . input_function
    (6) code_entity -> . output_function
    (7) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (8) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (9) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (10) conditional_statement -> . IF expression COLON start ENDIF
    (11) expression -> . assignment_statement
    (51) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (52) output_function -> . PRINT LPAREN term RPAREN
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 5
    start                          shift and go to state 85
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 61

    (8) iterative_statement -> FOR EQUALS expression . COMMA expression COMMA expression COLON start ENDFOR

    COMMA           shift and go to state 86


state 62

    (9) conditional_statement -> IF expression COLON . start ELSE start ENDIF
    (10) conditional_statement -> IF expression COLON . start ENDIF
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . expression
    (5) code_entity -> . input_function
    (6) code_entity -> . output_function
    (7) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (8) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (9) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (10) conditional_statement -> . IF expression COLON start ENDIF
    (11) expression -> . assignment_statement
    (51) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (52) output_function -> . PRINT LPAREN term RPAREN
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 5
    start                          shift and go to state 87
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 63

    (51) input_function -> INPUT LPAREN IDENTIFIER . RPAREN

    RPAREN          shift and go to state 88


state 64

    (40) term -> LPAREN expression RPAREN .

    POWER           reduce using rule 40 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 40 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 40 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 40 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 40 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 40 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 40 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 40 (term -> LPAREN expression RPAREN .)
    LTEQ            reduce using rule 40 (term -> LPAREN expression RPAREN .)
    GTEQ            reduce using rule 40 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 40 (term -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 40 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 40 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 40 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 40 (term -> LPAREN expression RPAREN .)
    COLON           reduce using rule 40 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 40 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 40 (term -> LPAREN expression RPAREN .)
    ENDWHILE        reduce using rule 40 (term -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 40 (term -> LPAREN expression RPAREN .)
    ENDIF           reduce using rule 40 (term -> LPAREN expression RPAREN .)
    ENDFOR          reduce using rule 40 (term -> LPAREN expression RPAREN .)


state 65

    (13) assignment_statement -> IDENTIFIER EQUALS or_statement .
    (15) or_statement -> or_statement . OR and_statement

    $end            reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COLON           reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    RPAREN          reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COMMA           reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDWHILE        reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ELSE            reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDIF           reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDFOR          reduce using rule 13 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    OR              shift and go to state 43


state 66

    (47) atom -> IDENTIFIER LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 89


state 67

    (52) output_function -> PRINT LPAREN term . RPAREN

    RPAREN          shift and go to state 90


state 68

    (37) exponent -> term POWER unary_statement .

    TIMES           reduce using rule 37 (exponent -> term POWER unary_statement .)
    DIVIDE          reduce using rule 37 (exponent -> term POWER unary_statement .)
    MOD             reduce using rule 37 (exponent -> term POWER unary_statement .)
    PLUS            reduce using rule 37 (exponent -> term POWER unary_statement .)
    MINUS           reduce using rule 37 (exponent -> term POWER unary_statement .)
    LT              reduce using rule 37 (exponent -> term POWER unary_statement .)
    GT              reduce using rule 37 (exponent -> term POWER unary_statement .)
    LTEQ            reduce using rule 37 (exponent -> term POWER unary_statement .)
    GTEQ            reduce using rule 37 (exponent -> term POWER unary_statement .)
    EQ              reduce using rule 37 (exponent -> term POWER unary_statement .)
    NEQ             reduce using rule 37 (exponent -> term POWER unary_statement .)
    AND             reduce using rule 37 (exponent -> term POWER unary_statement .)
    OR              reduce using rule 37 (exponent -> term POWER unary_statement .)
    $end            reduce using rule 37 (exponent -> term POWER unary_statement .)
    COLON           reduce using rule 37 (exponent -> term POWER unary_statement .)
    RPAREN          reduce using rule 37 (exponent -> term POWER unary_statement .)
    COMMA           reduce using rule 37 (exponent -> term POWER unary_statement .)
    ENDWHILE        reduce using rule 37 (exponent -> term POWER unary_statement .)
    ELSE            reduce using rule 37 (exponent -> term POWER unary_statement .)
    ENDIF           reduce using rule 37 (exponent -> term POWER unary_statement .)
    ENDFOR          reduce using rule 37 (exponent -> term POWER unary_statement .)


state 69

    (15) or_statement -> or_statement OR and_statement .
    (17) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    $end            reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    COLON           reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    RPAREN          reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    COMMA           reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    ENDWHILE        reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    ELSE            reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    ENDIF           reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    ENDFOR          reduce using rule 15 (or_statement -> or_statement OR and_statement .)
    AND             shift and go to state 44


state 70

    (17) and_statement -> and_statement AND equality_statement .
    (19) equality_statement -> equality_statement . EQ relational_statement
    (20) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    OR              reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    $end            reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    COLON           reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    RPAREN          reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    COMMA           reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    ENDWHILE        reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    ELSE            reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    ENDIF           reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    ENDFOR          reduce using rule 17 (and_statement -> and_statement AND equality_statement .)
    EQ              shift and go to state 45
    NEQ             shift and go to state 46


state 71

    (19) equality_statement -> equality_statement EQ relational_statement .
    (22) relational_statement -> relational_statement . LT add_statement
    (23) relational_statement -> relational_statement . GT add_statement
    (24) relational_statement -> relational_statement . LTEQ add_statement
    (25) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    NEQ             reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    AND             reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    OR              reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    $end            reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    COLON           reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    RPAREN          reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    COMMA           reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    ENDWHILE        reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    ELSE            reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    ENDIF           reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    ENDFOR          reduce using rule 19 (equality_statement -> equality_statement EQ relational_statement .)
    LT              shift and go to state 47
    GT              shift and go to state 48
    LTEQ            shift and go to state 49
    GTEQ            shift and go to state 50


state 72

    (20) equality_statement -> equality_statement NEQ relational_statement .
    (22) relational_statement -> relational_statement . LT add_statement
    (23) relational_statement -> relational_statement . GT add_statement
    (24) relational_statement -> relational_statement . LTEQ add_statement
    (25) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    NEQ             reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    AND             reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    OR              reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    $end            reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    COLON           reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    RPAREN          reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    COMMA           reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDWHILE        reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    ELSE            reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDIF           reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDFOR          reduce using rule 20 (equality_statement -> equality_statement NEQ relational_statement .)
    LT              shift and go to state 47
    GT              shift and go to state 48
    LTEQ            shift and go to state 49
    GTEQ            shift and go to state 50


state 73

    (22) relational_statement -> relational_statement LT add_statement .
    (27) add_statement -> add_statement . PLUS multiply_statement
    (28) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    GT              reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    LTEQ            reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    GTEQ            reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    EQ              reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    NEQ             reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    AND             reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    OR              reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    $end            reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    COLON           reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    RPAREN          reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    COMMA           reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    ENDWHILE        reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    ELSE            reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    ENDIF           reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    ENDFOR          reduce using rule 22 (relational_statement -> relational_statement LT add_statement .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 74

    (23) relational_statement -> relational_statement GT add_statement .
    (27) add_statement -> add_statement . PLUS multiply_statement
    (28) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    GT              reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    LTEQ            reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    GTEQ            reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    EQ              reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    NEQ             reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    AND             reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    OR              reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    $end            reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    COLON           reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    RPAREN          reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    COMMA           reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    ENDWHILE        reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    ELSE            reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    ENDIF           reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    ENDFOR          reduce using rule 23 (relational_statement -> relational_statement GT add_statement .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 75

    (24) relational_statement -> relational_statement LTEQ add_statement .
    (27) add_statement -> add_statement . PLUS multiply_statement
    (28) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    GT              reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    LTEQ            reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    GTEQ            reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    EQ              reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    NEQ             reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    AND             reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    OR              reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    $end            reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    COLON           reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    RPAREN          reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    COMMA           reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDWHILE        reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    ELSE            reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDIF           reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDFOR          reduce using rule 24 (relational_statement -> relational_statement LTEQ add_statement .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 76

    (25) relational_statement -> relational_statement GTEQ add_statement .
    (27) add_statement -> add_statement . PLUS multiply_statement
    (28) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    GT              reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    LTEQ            reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    GTEQ            reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    EQ              reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    NEQ             reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    AND             reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    OR              reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    $end            reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    COLON           reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    RPAREN          reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    COMMA           reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDWHILE        reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    ELSE            reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDIF           reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDFOR          reduce using rule 25 (relational_statement -> relational_statement GTEQ add_statement .)
    PLUS            shift and go to state 51
    MINUS           shift and go to state 52


state 77

    (27) add_statement -> add_statement PLUS multiply_statement .
    (30) multiply_statement -> multiply_statement . TIMES unary_statement
    (31) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (32) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    MINUS           reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    LT              reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    GT              reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    LTEQ            reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    GTEQ            reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    EQ              reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    NEQ             reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    AND             reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    OR              reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    $end            reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    COLON           reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    RPAREN          reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    COMMA           reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    ENDWHILE        reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    ELSE            reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    ENDIF           reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    ENDFOR          reduce using rule 27 (add_statement -> add_statement PLUS multiply_statement .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55


state 78

    (28) add_statement -> add_statement MINUS multiply_statement .
    (30) multiply_statement -> multiply_statement . TIMES unary_statement
    (31) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (32) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    MINUS           reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    LT              reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    GT              reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    LTEQ            reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    GTEQ            reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    EQ              reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    NEQ             reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    AND             reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    OR              reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    $end            reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    COLON           reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    RPAREN          reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    COMMA           reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    ENDWHILE        reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    ELSE            reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    ENDIF           reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    ENDFOR          reduce using rule 28 (add_statement -> add_statement MINUS multiply_statement .)
    TIMES           shift and go to state 53
    DIVIDE          shift and go to state 54
    MOD             shift and go to state 55


state 79

    (30) multiply_statement -> multiply_statement TIMES unary_statement .

    TIMES           reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    DIVIDE          reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MOD             reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    PLUS            reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MINUS           reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LT              reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GT              reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LTEQ            reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GTEQ            reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    EQ              reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    NEQ             reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    AND             reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    OR              reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    $end            reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COLON           reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    RPAREN          reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COMMA           reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDWHILE        reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ELSE            reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDIF           reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDFOR          reduce using rule 30 (multiply_statement -> multiply_statement TIMES unary_statement .)


state 80

    (31) multiply_statement -> multiply_statement DIVIDE unary_statement .

    TIMES           reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    DIVIDE          reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MOD             reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    PLUS            reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MINUS           reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LT              reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GT              reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LTEQ            reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GTEQ            reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    EQ              reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    NEQ             reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    AND             reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    OR              reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    $end            reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COLON           reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    RPAREN          reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COMMA           reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDWHILE        reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ELSE            reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDIF           reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDFOR          reduce using rule 31 (multiply_statement -> multiply_statement DIVIDE unary_statement .)


state 81

    (32) multiply_statement -> multiply_statement MOD unary_statement .

    TIMES           reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    DIVIDE          reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    MOD             reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    PLUS            reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    MINUS           reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    LT              reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    GT              reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    LTEQ            reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    GTEQ            reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    EQ              reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    NEQ             reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    AND             reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    OR              reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    $end            reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    COLON           reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    RPAREN          reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    COMMA           reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDWHILE        reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    ELSE            reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDIF           reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDFOR          reduce using rule 32 (multiply_statement -> multiply_statement MOD unary_statement .)


state 82

    (46) atom -> LBRACKET elements RBRACKET .

    POWER           reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    TIMES           reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    DIVIDE          reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    MOD             reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    PLUS            reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    MINUS           reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    LT              reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    GT              reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    LTEQ            reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    GTEQ            reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    EQ              reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    NEQ             reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    AND             reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    OR              reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    $end            reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    COLON           reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    RPAREN          reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    COMMA           reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    ENDWHILE        reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    ELSE            reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    ENDIF           reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)
    ENDFOR          reduce using rule 46 (atom -> LBRACKET elements RBRACKET .)


state 83

    (48) elements -> elements INTEGER .

    RBRACKET        reduce using rule 48 (elements -> elements INTEGER .)
    INTEGER         reduce using rule 48 (elements -> elements INTEGER .)
    FLOAT           reduce using rule 48 (elements -> elements INTEGER .)


state 84

    (49) elements -> elements FLOAT .

    RBRACKET        reduce using rule 49 (elements -> elements FLOAT .)
    INTEGER         reduce using rule 49 (elements -> elements FLOAT .)
    FLOAT           reduce using rule 49 (elements -> elements FLOAT .)


state 85

    (7) iterative_statement -> WHILE expression COLON start . ENDWHILE

    ENDWHILE        shift and go to state 91


state 86

    (8) iterative_statement -> FOR EQUALS expression COMMA . expression COMMA expression COLON start ENDFOR
    (11) expression -> . assignment_statement
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 92
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 87

    (9) conditional_statement -> IF expression COLON start . ELSE start ENDIF
    (10) conditional_statement -> IF expression COLON start . ENDIF

    ELSE            shift and go to state 93
    ENDIF           shift and go to state 94


state 88

    (51) input_function -> INPUT LPAREN IDENTIFIER RPAREN .

    $end            reduce using rule 51 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDWHILE        reduce using rule 51 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ELSE            reduce using rule 51 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDIF           reduce using rule 51 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDFOR          reduce using rule 51 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)


state 89

    (47) atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .

    POWER           reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TIMES           reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    DIVIDE          reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MOD             reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PLUS            reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MINUS           reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LT              reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GT              reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LTEQ            reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GTEQ            reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    EQ              reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NEQ             reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    AND             reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    OR              reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    $end            reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COLON           reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    RPAREN          reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDWHILE        reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ELSE            reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDIF           reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDFOR          reduce using rule 47 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)


state 90

    (52) output_function -> PRINT LPAREN term RPAREN .

    $end            reduce using rule 52 (output_function -> PRINT LPAREN term RPAREN .)
    ENDWHILE        reduce using rule 52 (output_function -> PRINT LPAREN term RPAREN .)
    ELSE            reduce using rule 52 (output_function -> PRINT LPAREN term RPAREN .)
    ENDIF           reduce using rule 52 (output_function -> PRINT LPAREN term RPAREN .)
    ENDFOR          reduce using rule 52 (output_function -> PRINT LPAREN term RPAREN .)


state 91

    (7) iterative_statement -> WHILE expression COLON start ENDWHILE .

    $end            reduce using rule 7 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDWHILE        reduce using rule 7 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ELSE            reduce using rule 7 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDIF           reduce using rule 7 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDFOR          reduce using rule 7 (iterative_statement -> WHILE expression COLON start ENDWHILE .)


state 92

    (8) iterative_statement -> FOR EQUALS expression COMMA expression . COMMA expression COLON start ENDFOR

    COMMA           shift and go to state 95


state 93

    (9) conditional_statement -> IF expression COLON start ELSE . start ENDIF
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . expression
    (5) code_entity -> . input_function
    (6) code_entity -> . output_function
    (7) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (8) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (9) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (10) conditional_statement -> . IF expression COLON start ENDIF
    (11) expression -> . assignment_statement
    (51) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (52) output_function -> . PRINT LPAREN term RPAREN
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 5
    start                          shift and go to state 96
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 94

    (10) conditional_statement -> IF expression COLON start ENDIF .

    $end            reduce using rule 10 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDWHILE        reduce using rule 10 (conditional_statement -> IF expression COLON start ENDIF .)
    ELSE            reduce using rule 10 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDIF           reduce using rule 10 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDFOR          reduce using rule 10 (conditional_statement -> IF expression COLON start ENDIF .)


state 95

    (8) iterative_statement -> FOR EQUALS expression COMMA expression COMMA . expression COLON start ENDFOR
    (11) expression -> . assignment_statement
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 97
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 96

    (9) conditional_statement -> IF expression COLON start ELSE start . ENDIF

    ENDIF           shift and go to state 98


state 97

    (8) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression . COLON start ENDFOR

    COLON           shift and go to state 99


state 98

    (9) conditional_statement -> IF expression COLON start ELSE start ENDIF .

    $end            reduce using rule 9 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDWHILE        reduce using rule 9 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ELSE            reduce using rule 9 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDIF           reduce using rule 9 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDFOR          reduce using rule 9 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)


state 99

    (8) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON . start ENDFOR
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . expression
    (5) code_entity -> . input_function
    (6) code_entity -> . output_function
    (7) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (8) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (9) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (10) conditional_statement -> . IF expression COLON start ENDIF
    (11) expression -> . assignment_statement
    (51) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (52) output_function -> . PRINT LPAREN term RPAREN
    (12) assignment_statement -> . or_statement
    (13) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (14) or_statement -> . and_statement
    (15) or_statement -> . or_statement OR and_statement
    (16) and_statement -> . equality_statement
    (17) and_statement -> . and_statement AND equality_statement
    (18) equality_statement -> . relational_statement
    (19) equality_statement -> . equality_statement EQ relational_statement
    (20) equality_statement -> . equality_statement NEQ relational_statement
    (21) relational_statement -> . add_statement
    (22) relational_statement -> . relational_statement LT add_statement
    (23) relational_statement -> . relational_statement GT add_statement
    (24) relational_statement -> . relational_statement LTEQ add_statement
    (25) relational_statement -> . relational_statement GTEQ add_statement
    (26) add_statement -> . multiply_statement
    (27) add_statement -> . add_statement PLUS multiply_statement
    (28) add_statement -> . add_statement MINUS multiply_statement
    (29) multiply_statement -> . unary_statement
    (30) multiply_statement -> . multiply_statement TIMES unary_statement
    (31) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (32) multiply_statement -> . multiply_statement MOD unary_statement
    (33) unary_statement -> . exponent
    (34) unary_statement -> . MINUS unary_statement
    (35) unary_statement -> . NOT unary_statement
    (36) exponent -> . term
    (37) exponent -> . term POWER unary_statement
    (38) term -> . IDENTIFIER
    (39) term -> . atom
    (40) term -> . LPAREN expression RPAREN
    (41) atom -> . INTEGER
    (42) atom -> . FLOAT
    (43) atom -> . STRING
    (44) atom -> . TRUE
    (45) atom -> . FALSE
    (46) atom -> . LBRACKET elements RBRACKET
    (47) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 32
    LBRACKET        shift and go to state 33

    expression                     shift and go to state 5
    start                          shift and go to state 100
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 100

    (8) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start . ENDFOR

    ENDFOR          shift and go to state 101


state 101

    (8) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .

    $end            reduce using rule 8 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDWHILE        reduce using rule 8 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ELSE            reduce using rule 8 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDIF           reduce using rule 8 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDFOR          reduce using rule 8 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)

