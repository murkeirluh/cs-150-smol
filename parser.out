Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    UMINUS

Grammar

Rule 0     S' -> start
Rule 1     start -> code_entity
Rule 2     code_entity -> iterative_statement
Rule 3     code_entity -> conditional_statement
Rule 4     code_entity -> declarative_statement
Rule 5     code_entity -> expression
Rule 6     code_entity -> input_function
Rule 7     code_entity -> output_function
Rule 8     iterative_statement -> WHILE expression COLON start ENDWHILE
Rule 9     iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
Rule 10    conditional_statement -> IF expression COLON start ELSE start ENDIF
Rule 11    conditional_statement -> IF expression COLON start ENDIF
Rule 12    declarative_statement -> variable_type IDENTIFIER
Rule 13    declarative_statement -> variable_type IDENTIFIER EQUALS atom
Rule 14    variable_type -> TYP_INT
Rule 15    variable_type -> TYP_FLOAT
Rule 16    variable_type -> TYP_STR
Rule 17    variable_type -> TYP_BOOL
Rule 18    expression -> assignment_statement
Rule 19    assignment_statement -> or_statement
Rule 20    assignment_statement -> IDENTIFIER EQUALS or_statement
Rule 21    or_statement -> and_statement
Rule 22    or_statement -> or_statement OR and_statement
Rule 23    and_statement -> equality_statement
Rule 24    and_statement -> and_statement AND equality_statement
Rule 25    equality_statement -> relational_statement
Rule 26    equality_statement -> equality_statement EQ relational_statement
Rule 27    equality_statement -> equality_statement NEQ relational_statement
Rule 28    relational_statement -> add_statement
Rule 29    relational_statement -> relational_statement LT add_statement
Rule 30    relational_statement -> relational_statement GT add_statement
Rule 31    relational_statement -> relational_statement LTEQ add_statement
Rule 32    relational_statement -> relational_statement GTEQ add_statement
Rule 33    add_statement -> multiply_statement
Rule 34    add_statement -> add_statement PLUS multiply_statement
Rule 35    add_statement -> add_statement MINUS multiply_statement
Rule 36    multiply_statement -> unary_statement
Rule 37    multiply_statement -> multiply_statement TIMES unary_statement
Rule 38    multiply_statement -> multiply_statement DIVIDE unary_statement
Rule 39    multiply_statement -> multiply_statement MOD unary_statement
Rule 40    unary_statement -> exponent
Rule 41    unary_statement -> MINUS unary_statement
Rule 42    unary_statement -> NOT unary_statement
Rule 43    exponent -> term
Rule 44    exponent -> term POWER unary_statement
Rule 45    term -> IDENTIFIER
Rule 46    term -> atom
Rule 47    term -> LPAREN expression RPAREN
Rule 48    atom -> INTEGER
Rule 49    atom -> FLOAT
Rule 50    atom -> STRING
Rule 51    atom -> TRUE
Rule 52    atom -> FALSE
Rule 53    input_function -> INPUT LPAREN IDENTIFIER RPAREN
Rule 54    output_function -> PRINT LPAREN term RPAREN

Terminals, with rules where they appear

AND                  : 24
COLON                : 8 9 10 11
COMMA                : 9 9
DIVIDE               : 38
ELSE                 : 10
ENDFOR               : 9
ENDIF                : 10 11
ENDWHILE             : 8
EQ                   : 26
EQUALS               : 9 13 20
FALSE                : 52
FLOAT                : 49
FOR                  : 9
GT                   : 30
GTEQ                 : 32
IDENTIFIER           : 12 13 20 45 53
IF                   : 10 11
INPUT                : 53
INTEGER              : 48
LPAREN               : 47 53 54
LT                   : 29
LTEQ                 : 31
MINUS                : 35 41
MOD                  : 39
NEQ                  : 27
NOT                  : 42
OR                   : 22
PLUS                 : 34
POWER                : 44
PRINT                : 54
RPAREN               : 47 53 54
STRING               : 50
TIMES                : 37
TRUE                 : 51
TYP_BOOL             : 17
TYP_FLOAT            : 15
TYP_INT              : 14
TYP_STR              : 16
UMINUS               : 
WHILE                : 8
error                : 

Nonterminals, with rules where they appear

add_statement        : 28 29 30 31 32 34 35
and_statement        : 21 22 24
assignment_statement : 18
atom                 : 13 46
code_entity          : 1
conditional_statement : 3
declarative_statement : 4
equality_statement   : 23 24 26 27
exponent             : 40
expression           : 5 8 9 9 9 10 11 47
input_function       : 6
iterative_statement  : 2
multiply_statement   : 33 34 35 37 38 39
or_statement         : 19 20 22
output_function      : 7
relational_statement : 25 26 27 29 30 31 32
start                : 8 9 10 10 11 0
term                 : 43 44 54
unary_statement      : 36 37 38 39 41 42 44
variable_type        : 12 13

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . declarative_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) declarative_statement -> . variable_type IDENTIFIER
    (13) declarative_statement -> . variable_type IDENTIFIER EQUALS atom
    (18) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (14) variable_type -> . TYP_INT
    (15) variable_type -> . TYP_FLOAT
    (16) variable_type -> . TYP_STR
    (17) variable_type -> . TYP_BOOL
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 11
    INPUT           shift and go to state 16
    PRINT           shift and go to state 18
    TYP_INT         shift and go to state 20
    TYP_FLOAT       shift and go to state 21
    TYP_STR         shift and go to state 22
    TYP_BOOL        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    start                          shift and go to state 1
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    declarative_statement          shift and go to state 5
    expression                     shift and go to state 6
    input_function                 shift and go to state 7
    output_function                shift and go to state 8
    variable_type                  shift and go to state 12
    atom                           shift and go to state 14
    assignment_statement           shift and go to state 15
    term                           shift and go to state 19
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32

state 1

    (0) S' -> start .



state 2

    (1) start -> code_entity .

    $end            reduce using rule 1 (start -> code_entity .)
    ENDWHILE        reduce using rule 1 (start -> code_entity .)
    ELSE            reduce using rule 1 (start -> code_entity .)
    ENDIF           reduce using rule 1 (start -> code_entity .)
    ENDFOR          reduce using rule 1 (start -> code_entity .)


state 3

    (2) code_entity -> iterative_statement .

    $end            reduce using rule 2 (code_entity -> iterative_statement .)
    ENDWHILE        reduce using rule 2 (code_entity -> iterative_statement .)
    ELSE            reduce using rule 2 (code_entity -> iterative_statement .)
    ENDIF           reduce using rule 2 (code_entity -> iterative_statement .)
    ENDFOR          reduce using rule 2 (code_entity -> iterative_statement .)


state 4

    (3) code_entity -> conditional_statement .

    $end            reduce using rule 3 (code_entity -> conditional_statement .)
    ENDWHILE        reduce using rule 3 (code_entity -> conditional_statement .)
    ELSE            reduce using rule 3 (code_entity -> conditional_statement .)
    ENDIF           reduce using rule 3 (code_entity -> conditional_statement .)
    ENDFOR          reduce using rule 3 (code_entity -> conditional_statement .)


state 5

    (4) code_entity -> declarative_statement .

    $end            reduce using rule 4 (code_entity -> declarative_statement .)
    ENDWHILE        reduce using rule 4 (code_entity -> declarative_statement .)
    ELSE            reduce using rule 4 (code_entity -> declarative_statement .)
    ENDIF           reduce using rule 4 (code_entity -> declarative_statement .)
    ENDFOR          reduce using rule 4 (code_entity -> declarative_statement .)


state 6

    (5) code_entity -> expression .

    $end            reduce using rule 5 (code_entity -> expression .)
    ENDWHILE        reduce using rule 5 (code_entity -> expression .)
    ELSE            reduce using rule 5 (code_entity -> expression .)
    ENDIF           reduce using rule 5 (code_entity -> expression .)
    ENDFOR          reduce using rule 5 (code_entity -> expression .)


state 7

    (6) code_entity -> input_function .

    $end            reduce using rule 6 (code_entity -> input_function .)
    ENDWHILE        reduce using rule 6 (code_entity -> input_function .)
    ELSE            reduce using rule 6 (code_entity -> input_function .)
    ENDIF           reduce using rule 6 (code_entity -> input_function .)
    ENDFOR          reduce using rule 6 (code_entity -> input_function .)


state 8

    (7) code_entity -> output_function .

    $end            reduce using rule 7 (code_entity -> output_function .)
    ENDWHILE        reduce using rule 7 (code_entity -> output_function .)
    ELSE            reduce using rule 7 (code_entity -> output_function .)
    ENDIF           reduce using rule 7 (code_entity -> output_function .)
    ENDFOR          reduce using rule 7 (code_entity -> output_function .)


state 9

    (8) iterative_statement -> WHILE . expression COLON start ENDWHILE
    (18) expression -> . assignment_statement
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 39
    assignment_statement           shift and go to state 15
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 10

    (9) iterative_statement -> FOR . EQUALS expression COMMA expression COMMA expression COLON start ENDFOR

    EQUALS          shift and go to state 40


state 11

    (10) conditional_statement -> IF . expression COLON start ELSE start ENDIF
    (11) conditional_statement -> IF . expression COLON start ENDIF
    (18) expression -> . assignment_statement
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 41
    assignment_statement           shift and go to state 15
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 12

    (12) declarative_statement -> variable_type . IDENTIFIER
    (13) declarative_statement -> variable_type . IDENTIFIER EQUALS atom

    IDENTIFIER      shift and go to state 42


state 13

    (20) assignment_statement -> IDENTIFIER . EQUALS or_statement
    (45) term -> IDENTIFIER .

    EQUALS          shift and go to state 43
    POWER           reduce using rule 45 (term -> IDENTIFIER .)
    TIMES           reduce using rule 45 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 45 (term -> IDENTIFIER .)
    MOD             reduce using rule 45 (term -> IDENTIFIER .)
    PLUS            reduce using rule 45 (term -> IDENTIFIER .)
    MINUS           reduce using rule 45 (term -> IDENTIFIER .)
    LT              reduce using rule 45 (term -> IDENTIFIER .)
    GT              reduce using rule 45 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 45 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 45 (term -> IDENTIFIER .)
    EQ              reduce using rule 45 (term -> IDENTIFIER .)
    NEQ             reduce using rule 45 (term -> IDENTIFIER .)
    AND             reduce using rule 45 (term -> IDENTIFIER .)
    OR              reduce using rule 45 (term -> IDENTIFIER .)
    $end            reduce using rule 45 (term -> IDENTIFIER .)
    COLON           reduce using rule 45 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 45 (term -> IDENTIFIER .)
    COMMA           reduce using rule 45 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 45 (term -> IDENTIFIER .)
    ELSE            reduce using rule 45 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 45 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 45 (term -> IDENTIFIER .)


state 14

    (46) term -> atom .

    POWER           reduce using rule 46 (term -> atom .)
    TIMES           reduce using rule 46 (term -> atom .)
    DIVIDE          reduce using rule 46 (term -> atom .)
    MOD             reduce using rule 46 (term -> atom .)
    PLUS            reduce using rule 46 (term -> atom .)
    MINUS           reduce using rule 46 (term -> atom .)
    LT              reduce using rule 46 (term -> atom .)
    GT              reduce using rule 46 (term -> atom .)
    LTEQ            reduce using rule 46 (term -> atom .)
    GTEQ            reduce using rule 46 (term -> atom .)
    EQ              reduce using rule 46 (term -> atom .)
    NEQ             reduce using rule 46 (term -> atom .)
    AND             reduce using rule 46 (term -> atom .)
    OR              reduce using rule 46 (term -> atom .)
    $end            reduce using rule 46 (term -> atom .)
    COLON           reduce using rule 46 (term -> atom .)
    RPAREN          reduce using rule 46 (term -> atom .)
    COMMA           reduce using rule 46 (term -> atom .)
    ENDWHILE        reduce using rule 46 (term -> atom .)
    ELSE            reduce using rule 46 (term -> atom .)
    ENDIF           reduce using rule 46 (term -> atom .)
    ENDFOR          reduce using rule 46 (term -> atom .)


state 15

    (18) expression -> assignment_statement .

    $end            reduce using rule 18 (expression -> assignment_statement .)
    COLON           reduce using rule 18 (expression -> assignment_statement .)
    RPAREN          reduce using rule 18 (expression -> assignment_statement .)
    COMMA           reduce using rule 18 (expression -> assignment_statement .)
    ENDWHILE        reduce using rule 18 (expression -> assignment_statement .)
    ELSE            reduce using rule 18 (expression -> assignment_statement .)
    ENDIF           reduce using rule 18 (expression -> assignment_statement .)
    ENDFOR          reduce using rule 18 (expression -> assignment_statement .)


state 16

    (53) input_function -> INPUT . LPAREN IDENTIFIER RPAREN

    LPAREN          shift and go to state 44


state 17

    (47) term -> LPAREN . expression RPAREN
    (18) expression -> . assignment_statement
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 45
    assignment_statement           shift and go to state 15
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 18

    (54) output_function -> PRINT . LPAREN term RPAREN

    LPAREN          shift and go to state 46


state 19

    (43) exponent -> term .
    (44) exponent -> term . POWER unary_statement

    TIMES           reduce using rule 43 (exponent -> term .)
    DIVIDE          reduce using rule 43 (exponent -> term .)
    MOD             reduce using rule 43 (exponent -> term .)
    PLUS            reduce using rule 43 (exponent -> term .)
    MINUS           reduce using rule 43 (exponent -> term .)
    LT              reduce using rule 43 (exponent -> term .)
    GT              reduce using rule 43 (exponent -> term .)
    LTEQ            reduce using rule 43 (exponent -> term .)
    GTEQ            reduce using rule 43 (exponent -> term .)
    EQ              reduce using rule 43 (exponent -> term .)
    NEQ             reduce using rule 43 (exponent -> term .)
    AND             reduce using rule 43 (exponent -> term .)
    OR              reduce using rule 43 (exponent -> term .)
    $end            reduce using rule 43 (exponent -> term .)
    COLON           reduce using rule 43 (exponent -> term .)
    RPAREN          reduce using rule 43 (exponent -> term .)
    COMMA           reduce using rule 43 (exponent -> term .)
    ENDWHILE        reduce using rule 43 (exponent -> term .)
    ELSE            reduce using rule 43 (exponent -> term .)
    ENDIF           reduce using rule 43 (exponent -> term .)
    ENDFOR          reduce using rule 43 (exponent -> term .)
    POWER           shift and go to state 47


state 20

    (14) variable_type -> TYP_INT .

    IDENTIFIER      reduce using rule 14 (variable_type -> TYP_INT .)


state 21

    (15) variable_type -> TYP_FLOAT .

    IDENTIFIER      reduce using rule 15 (variable_type -> TYP_FLOAT .)


state 22

    (16) variable_type -> TYP_STR .

    IDENTIFIER      reduce using rule 16 (variable_type -> TYP_STR .)


state 23

    (17) variable_type -> TYP_BOOL .

    IDENTIFIER      reduce using rule 17 (variable_type -> TYP_BOOL .)


state 24

    (19) assignment_statement -> or_statement .
    (22) or_statement -> or_statement . OR and_statement

    $end            reduce using rule 19 (assignment_statement -> or_statement .)
    COLON           reduce using rule 19 (assignment_statement -> or_statement .)
    RPAREN          reduce using rule 19 (assignment_statement -> or_statement .)
    COMMA           reduce using rule 19 (assignment_statement -> or_statement .)
    ENDWHILE        reduce using rule 19 (assignment_statement -> or_statement .)
    ELSE            reduce using rule 19 (assignment_statement -> or_statement .)
    ENDIF           reduce using rule 19 (assignment_statement -> or_statement .)
    ENDFOR          reduce using rule 19 (assignment_statement -> or_statement .)
    OR              shift and go to state 48


state 25

    (21) or_statement -> and_statement .
    (24) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 21 (or_statement -> and_statement .)
    $end            reduce using rule 21 (or_statement -> and_statement .)
    COLON           reduce using rule 21 (or_statement -> and_statement .)
    RPAREN          reduce using rule 21 (or_statement -> and_statement .)
    COMMA           reduce using rule 21 (or_statement -> and_statement .)
    ENDWHILE        reduce using rule 21 (or_statement -> and_statement .)
    ELSE            reduce using rule 21 (or_statement -> and_statement .)
    ENDIF           reduce using rule 21 (or_statement -> and_statement .)
    ENDFOR          reduce using rule 21 (or_statement -> and_statement .)
    AND             shift and go to state 49


state 26

    (23) and_statement -> equality_statement .
    (26) equality_statement -> equality_statement . EQ relational_statement
    (27) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 23 (and_statement -> equality_statement .)
    OR              reduce using rule 23 (and_statement -> equality_statement .)
    $end            reduce using rule 23 (and_statement -> equality_statement .)
    COLON           reduce using rule 23 (and_statement -> equality_statement .)
    RPAREN          reduce using rule 23 (and_statement -> equality_statement .)
    COMMA           reduce using rule 23 (and_statement -> equality_statement .)
    ENDWHILE        reduce using rule 23 (and_statement -> equality_statement .)
    ELSE            reduce using rule 23 (and_statement -> equality_statement .)
    ENDIF           reduce using rule 23 (and_statement -> equality_statement .)
    ENDFOR          reduce using rule 23 (and_statement -> equality_statement .)
    EQ              shift and go to state 50
    NEQ             shift and go to state 51


state 27

    (25) equality_statement -> relational_statement .
    (29) relational_statement -> relational_statement . LT add_statement
    (30) relational_statement -> relational_statement . GT add_statement
    (31) relational_statement -> relational_statement . LTEQ add_statement
    (32) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 25 (equality_statement -> relational_statement .)
    NEQ             reduce using rule 25 (equality_statement -> relational_statement .)
    AND             reduce using rule 25 (equality_statement -> relational_statement .)
    OR              reduce using rule 25 (equality_statement -> relational_statement .)
    $end            reduce using rule 25 (equality_statement -> relational_statement .)
    COLON           reduce using rule 25 (equality_statement -> relational_statement .)
    RPAREN          reduce using rule 25 (equality_statement -> relational_statement .)
    COMMA           reduce using rule 25 (equality_statement -> relational_statement .)
    ENDWHILE        reduce using rule 25 (equality_statement -> relational_statement .)
    ELSE            reduce using rule 25 (equality_statement -> relational_statement .)
    ENDIF           reduce using rule 25 (equality_statement -> relational_statement .)
    ENDFOR          reduce using rule 25 (equality_statement -> relational_statement .)
    LT              shift and go to state 52
    GT              shift and go to state 53
    LTEQ            shift and go to state 54
    GTEQ            shift and go to state 55


state 28

    (28) relational_statement -> add_statement .
    (34) add_statement -> add_statement . PLUS multiply_statement
    (35) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 28 (relational_statement -> add_statement .)
    GT              reduce using rule 28 (relational_statement -> add_statement .)
    LTEQ            reduce using rule 28 (relational_statement -> add_statement .)
    GTEQ            reduce using rule 28 (relational_statement -> add_statement .)
    EQ              reduce using rule 28 (relational_statement -> add_statement .)
    NEQ             reduce using rule 28 (relational_statement -> add_statement .)
    AND             reduce using rule 28 (relational_statement -> add_statement .)
    OR              reduce using rule 28 (relational_statement -> add_statement .)
    $end            reduce using rule 28 (relational_statement -> add_statement .)
    COLON           reduce using rule 28 (relational_statement -> add_statement .)
    RPAREN          reduce using rule 28 (relational_statement -> add_statement .)
    COMMA           reduce using rule 28 (relational_statement -> add_statement .)
    ENDWHILE        reduce using rule 28 (relational_statement -> add_statement .)
    ELSE            reduce using rule 28 (relational_statement -> add_statement .)
    ENDIF           reduce using rule 28 (relational_statement -> add_statement .)
    ENDFOR          reduce using rule 28 (relational_statement -> add_statement .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 29

    (33) add_statement -> multiply_statement .
    (37) multiply_statement -> multiply_statement . TIMES unary_statement
    (38) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (39) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 33 (add_statement -> multiply_statement .)
    MINUS           reduce using rule 33 (add_statement -> multiply_statement .)
    LT              reduce using rule 33 (add_statement -> multiply_statement .)
    GT              reduce using rule 33 (add_statement -> multiply_statement .)
    LTEQ            reduce using rule 33 (add_statement -> multiply_statement .)
    GTEQ            reduce using rule 33 (add_statement -> multiply_statement .)
    EQ              reduce using rule 33 (add_statement -> multiply_statement .)
    NEQ             reduce using rule 33 (add_statement -> multiply_statement .)
    AND             reduce using rule 33 (add_statement -> multiply_statement .)
    OR              reduce using rule 33 (add_statement -> multiply_statement .)
    $end            reduce using rule 33 (add_statement -> multiply_statement .)
    COLON           reduce using rule 33 (add_statement -> multiply_statement .)
    RPAREN          reduce using rule 33 (add_statement -> multiply_statement .)
    COMMA           reduce using rule 33 (add_statement -> multiply_statement .)
    ENDWHILE        reduce using rule 33 (add_statement -> multiply_statement .)
    ELSE            reduce using rule 33 (add_statement -> multiply_statement .)
    ENDIF           reduce using rule 33 (add_statement -> multiply_statement .)
    ENDFOR          reduce using rule 33 (add_statement -> multiply_statement .)
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60


state 30

    (41) unary_statement -> MINUS . unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    unary_statement                shift and go to state 61
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 31

    (36) multiply_statement -> unary_statement .

    TIMES           reduce using rule 36 (multiply_statement -> unary_statement .)
    DIVIDE          reduce using rule 36 (multiply_statement -> unary_statement .)
    MOD             reduce using rule 36 (multiply_statement -> unary_statement .)
    PLUS            reduce using rule 36 (multiply_statement -> unary_statement .)
    MINUS           reduce using rule 36 (multiply_statement -> unary_statement .)
    LT              reduce using rule 36 (multiply_statement -> unary_statement .)
    GT              reduce using rule 36 (multiply_statement -> unary_statement .)
    LTEQ            reduce using rule 36 (multiply_statement -> unary_statement .)
    GTEQ            reduce using rule 36 (multiply_statement -> unary_statement .)
    EQ              reduce using rule 36 (multiply_statement -> unary_statement .)
    NEQ             reduce using rule 36 (multiply_statement -> unary_statement .)
    AND             reduce using rule 36 (multiply_statement -> unary_statement .)
    OR              reduce using rule 36 (multiply_statement -> unary_statement .)
    $end            reduce using rule 36 (multiply_statement -> unary_statement .)
    COLON           reduce using rule 36 (multiply_statement -> unary_statement .)
    RPAREN          reduce using rule 36 (multiply_statement -> unary_statement .)
    COMMA           reduce using rule 36 (multiply_statement -> unary_statement .)
    ENDWHILE        reduce using rule 36 (multiply_statement -> unary_statement .)
    ELSE            reduce using rule 36 (multiply_statement -> unary_statement .)
    ENDIF           reduce using rule 36 (multiply_statement -> unary_statement .)
    ENDFOR          reduce using rule 36 (multiply_statement -> unary_statement .)


state 32

    (40) unary_statement -> exponent .

    TIMES           reduce using rule 40 (unary_statement -> exponent .)
    DIVIDE          reduce using rule 40 (unary_statement -> exponent .)
    MOD             reduce using rule 40 (unary_statement -> exponent .)
    PLUS            reduce using rule 40 (unary_statement -> exponent .)
    MINUS           reduce using rule 40 (unary_statement -> exponent .)
    LT              reduce using rule 40 (unary_statement -> exponent .)
    GT              reduce using rule 40 (unary_statement -> exponent .)
    LTEQ            reduce using rule 40 (unary_statement -> exponent .)
    GTEQ            reduce using rule 40 (unary_statement -> exponent .)
    EQ              reduce using rule 40 (unary_statement -> exponent .)
    NEQ             reduce using rule 40 (unary_statement -> exponent .)
    AND             reduce using rule 40 (unary_statement -> exponent .)
    OR              reduce using rule 40 (unary_statement -> exponent .)
    $end            reduce using rule 40 (unary_statement -> exponent .)
    COLON           reduce using rule 40 (unary_statement -> exponent .)
    RPAREN          reduce using rule 40 (unary_statement -> exponent .)
    COMMA           reduce using rule 40 (unary_statement -> exponent .)
    ENDWHILE        reduce using rule 40 (unary_statement -> exponent .)
    ELSE            reduce using rule 40 (unary_statement -> exponent .)
    ENDIF           reduce using rule 40 (unary_statement -> exponent .)
    ENDFOR          reduce using rule 40 (unary_statement -> exponent .)


state 33

    (42) unary_statement -> NOT . unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    unary_statement                shift and go to state 63
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 34

    (48) atom -> INTEGER .

    POWER           reduce using rule 48 (atom -> INTEGER .)
    TIMES           reduce using rule 48 (atom -> INTEGER .)
    DIVIDE          reduce using rule 48 (atom -> INTEGER .)
    MOD             reduce using rule 48 (atom -> INTEGER .)
    PLUS            reduce using rule 48 (atom -> INTEGER .)
    MINUS           reduce using rule 48 (atom -> INTEGER .)
    LT              reduce using rule 48 (atom -> INTEGER .)
    GT              reduce using rule 48 (atom -> INTEGER .)
    LTEQ            reduce using rule 48 (atom -> INTEGER .)
    GTEQ            reduce using rule 48 (atom -> INTEGER .)
    EQ              reduce using rule 48 (atom -> INTEGER .)
    NEQ             reduce using rule 48 (atom -> INTEGER .)
    AND             reduce using rule 48 (atom -> INTEGER .)
    OR              reduce using rule 48 (atom -> INTEGER .)
    $end            reduce using rule 48 (atom -> INTEGER .)
    COLON           reduce using rule 48 (atom -> INTEGER .)
    RPAREN          reduce using rule 48 (atom -> INTEGER .)
    COMMA           reduce using rule 48 (atom -> INTEGER .)
    ENDWHILE        reduce using rule 48 (atom -> INTEGER .)
    ELSE            reduce using rule 48 (atom -> INTEGER .)
    ENDIF           reduce using rule 48 (atom -> INTEGER .)
    ENDFOR          reduce using rule 48 (atom -> INTEGER .)


state 35

    (49) atom -> FLOAT .

    POWER           reduce using rule 49 (atom -> FLOAT .)
    TIMES           reduce using rule 49 (atom -> FLOAT .)
    DIVIDE          reduce using rule 49 (atom -> FLOAT .)
    MOD             reduce using rule 49 (atom -> FLOAT .)
    PLUS            reduce using rule 49 (atom -> FLOAT .)
    MINUS           reduce using rule 49 (atom -> FLOAT .)
    LT              reduce using rule 49 (atom -> FLOAT .)
    GT              reduce using rule 49 (atom -> FLOAT .)
    LTEQ            reduce using rule 49 (atom -> FLOAT .)
    GTEQ            reduce using rule 49 (atom -> FLOAT .)
    EQ              reduce using rule 49 (atom -> FLOAT .)
    NEQ             reduce using rule 49 (atom -> FLOAT .)
    AND             reduce using rule 49 (atom -> FLOAT .)
    OR              reduce using rule 49 (atom -> FLOAT .)
    $end            reduce using rule 49 (atom -> FLOAT .)
    COLON           reduce using rule 49 (atom -> FLOAT .)
    RPAREN          reduce using rule 49 (atom -> FLOAT .)
    COMMA           reduce using rule 49 (atom -> FLOAT .)
    ENDWHILE        reduce using rule 49 (atom -> FLOAT .)
    ELSE            reduce using rule 49 (atom -> FLOAT .)
    ENDIF           reduce using rule 49 (atom -> FLOAT .)
    ENDFOR          reduce using rule 49 (atom -> FLOAT .)


state 36

    (50) atom -> STRING .

    POWER           reduce using rule 50 (atom -> STRING .)
    TIMES           reduce using rule 50 (atom -> STRING .)
    DIVIDE          reduce using rule 50 (atom -> STRING .)
    MOD             reduce using rule 50 (atom -> STRING .)
    PLUS            reduce using rule 50 (atom -> STRING .)
    MINUS           reduce using rule 50 (atom -> STRING .)
    LT              reduce using rule 50 (atom -> STRING .)
    GT              reduce using rule 50 (atom -> STRING .)
    LTEQ            reduce using rule 50 (atom -> STRING .)
    GTEQ            reduce using rule 50 (atom -> STRING .)
    EQ              reduce using rule 50 (atom -> STRING .)
    NEQ             reduce using rule 50 (atom -> STRING .)
    AND             reduce using rule 50 (atom -> STRING .)
    OR              reduce using rule 50 (atom -> STRING .)
    $end            reduce using rule 50 (atom -> STRING .)
    COLON           reduce using rule 50 (atom -> STRING .)
    RPAREN          reduce using rule 50 (atom -> STRING .)
    COMMA           reduce using rule 50 (atom -> STRING .)
    ENDWHILE        reduce using rule 50 (atom -> STRING .)
    ELSE            reduce using rule 50 (atom -> STRING .)
    ENDIF           reduce using rule 50 (atom -> STRING .)
    ENDFOR          reduce using rule 50 (atom -> STRING .)


state 37

    (51) atom -> TRUE .

    POWER           reduce using rule 51 (atom -> TRUE .)
    TIMES           reduce using rule 51 (atom -> TRUE .)
    DIVIDE          reduce using rule 51 (atom -> TRUE .)
    MOD             reduce using rule 51 (atom -> TRUE .)
    PLUS            reduce using rule 51 (atom -> TRUE .)
    MINUS           reduce using rule 51 (atom -> TRUE .)
    LT              reduce using rule 51 (atom -> TRUE .)
    GT              reduce using rule 51 (atom -> TRUE .)
    LTEQ            reduce using rule 51 (atom -> TRUE .)
    GTEQ            reduce using rule 51 (atom -> TRUE .)
    EQ              reduce using rule 51 (atom -> TRUE .)
    NEQ             reduce using rule 51 (atom -> TRUE .)
    AND             reduce using rule 51 (atom -> TRUE .)
    OR              reduce using rule 51 (atom -> TRUE .)
    $end            reduce using rule 51 (atom -> TRUE .)
    COLON           reduce using rule 51 (atom -> TRUE .)
    RPAREN          reduce using rule 51 (atom -> TRUE .)
    COMMA           reduce using rule 51 (atom -> TRUE .)
    ENDWHILE        reduce using rule 51 (atom -> TRUE .)
    ELSE            reduce using rule 51 (atom -> TRUE .)
    ENDIF           reduce using rule 51 (atom -> TRUE .)
    ENDFOR          reduce using rule 51 (atom -> TRUE .)


state 38

    (52) atom -> FALSE .

    POWER           reduce using rule 52 (atom -> FALSE .)
    TIMES           reduce using rule 52 (atom -> FALSE .)
    DIVIDE          reduce using rule 52 (atom -> FALSE .)
    MOD             reduce using rule 52 (atom -> FALSE .)
    PLUS            reduce using rule 52 (atom -> FALSE .)
    MINUS           reduce using rule 52 (atom -> FALSE .)
    LT              reduce using rule 52 (atom -> FALSE .)
    GT              reduce using rule 52 (atom -> FALSE .)
    LTEQ            reduce using rule 52 (atom -> FALSE .)
    GTEQ            reduce using rule 52 (atom -> FALSE .)
    EQ              reduce using rule 52 (atom -> FALSE .)
    NEQ             reduce using rule 52 (atom -> FALSE .)
    AND             reduce using rule 52 (atom -> FALSE .)
    OR              reduce using rule 52 (atom -> FALSE .)
    $end            reduce using rule 52 (atom -> FALSE .)
    COLON           reduce using rule 52 (atom -> FALSE .)
    RPAREN          reduce using rule 52 (atom -> FALSE .)
    COMMA           reduce using rule 52 (atom -> FALSE .)
    ENDWHILE        reduce using rule 52 (atom -> FALSE .)
    ELSE            reduce using rule 52 (atom -> FALSE .)
    ENDIF           reduce using rule 52 (atom -> FALSE .)
    ENDFOR          reduce using rule 52 (atom -> FALSE .)


state 39

    (8) iterative_statement -> WHILE expression . COLON start ENDWHILE

    COLON           shift and go to state 64


state 40

    (9) iterative_statement -> FOR EQUALS . expression COMMA expression COMMA expression COLON start ENDFOR
    (18) expression -> . assignment_statement
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 65
    assignment_statement           shift and go to state 15
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 41

    (10) conditional_statement -> IF expression . COLON start ELSE start ENDIF
    (11) conditional_statement -> IF expression . COLON start ENDIF

    COLON           shift and go to state 66


state 42

    (12) declarative_statement -> variable_type IDENTIFIER .
    (13) declarative_statement -> variable_type IDENTIFIER . EQUALS atom

    $end            reduce using rule 12 (declarative_statement -> variable_type IDENTIFIER .)
    ENDWHILE        reduce using rule 12 (declarative_statement -> variable_type IDENTIFIER .)
    ELSE            reduce using rule 12 (declarative_statement -> variable_type IDENTIFIER .)
    ENDIF           reduce using rule 12 (declarative_statement -> variable_type IDENTIFIER .)
    ENDFOR          reduce using rule 12 (declarative_statement -> variable_type IDENTIFIER .)
    EQUALS          shift and go to state 67


state 43

    (20) assignment_statement -> IDENTIFIER EQUALS . or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    or_statement                   shift and go to state 68
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 44

    (53) input_function -> INPUT LPAREN . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 69


state 45

    (47) term -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 70


state 46

    (54) output_function -> PRINT LPAREN . term RPAREN
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    term                           shift and go to state 71
    atom                           shift and go to state 14

state 47

    (44) exponent -> term POWER . unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    term                           shift and go to state 19
    unary_statement                shift and go to state 72
    exponent                       shift and go to state 32
    atom                           shift and go to state 14

state 48

    (22) or_statement -> or_statement OR . and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    and_statement                  shift and go to state 73
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 49

    (24) and_statement -> and_statement AND . equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    equality_statement             shift and go to state 74
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 50

    (26) equality_statement -> equality_statement EQ . relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    relational_statement           shift and go to state 75
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 51

    (27) equality_statement -> equality_statement NEQ . relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    relational_statement           shift and go to state 76
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 52

    (29) relational_statement -> relational_statement LT . add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    add_statement                  shift and go to state 77
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 53

    (30) relational_statement -> relational_statement GT . add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    add_statement                  shift and go to state 78
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 54

    (31) relational_statement -> relational_statement LTEQ . add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    add_statement                  shift and go to state 79
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 55

    (32) relational_statement -> relational_statement GTEQ . add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    add_statement                  shift and go to state 80
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 56

    (34) add_statement -> add_statement PLUS . multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    multiply_statement             shift and go to state 81
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 57

    (35) add_statement -> add_statement MINUS . multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    multiply_statement             shift and go to state 82
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 58

    (37) multiply_statement -> multiply_statement TIMES . unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    unary_statement                shift and go to state 83
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 59

    (38) multiply_statement -> multiply_statement DIVIDE . unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    unary_statement                shift and go to state 84
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 60

    (39) multiply_statement -> multiply_statement MOD . unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    IDENTIFIER      shift and go to state 62
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    unary_statement                shift and go to state 85
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 61

    (41) unary_statement -> MINUS unary_statement .

    TIMES           reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    DIVIDE          reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    MOD             reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    PLUS            reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    MINUS           reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    LT              reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    GT              reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    LTEQ            reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    GTEQ            reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    EQ              reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    NEQ             reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    AND             reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    OR              reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    $end            reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    COLON           reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    RPAREN          reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    COMMA           reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    ENDWHILE        reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    ELSE            reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    ENDIF           reduce using rule 41 (unary_statement -> MINUS unary_statement .)
    ENDFOR          reduce using rule 41 (unary_statement -> MINUS unary_statement .)


state 62

    (45) term -> IDENTIFIER .

    POWER           reduce using rule 45 (term -> IDENTIFIER .)
    TIMES           reduce using rule 45 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 45 (term -> IDENTIFIER .)
    MOD             reduce using rule 45 (term -> IDENTIFIER .)
    PLUS            reduce using rule 45 (term -> IDENTIFIER .)
    MINUS           reduce using rule 45 (term -> IDENTIFIER .)
    LT              reduce using rule 45 (term -> IDENTIFIER .)
    GT              reduce using rule 45 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 45 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 45 (term -> IDENTIFIER .)
    EQ              reduce using rule 45 (term -> IDENTIFIER .)
    NEQ             reduce using rule 45 (term -> IDENTIFIER .)
    AND             reduce using rule 45 (term -> IDENTIFIER .)
    OR              reduce using rule 45 (term -> IDENTIFIER .)
    $end            reduce using rule 45 (term -> IDENTIFIER .)
    COLON           reduce using rule 45 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 45 (term -> IDENTIFIER .)
    COMMA           reduce using rule 45 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 45 (term -> IDENTIFIER .)
    ELSE            reduce using rule 45 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 45 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 45 (term -> IDENTIFIER .)


state 63

    (42) unary_statement -> NOT unary_statement .

    TIMES           reduce using rule 42 (unary_statement -> NOT unary_statement .)
    DIVIDE          reduce using rule 42 (unary_statement -> NOT unary_statement .)
    MOD             reduce using rule 42 (unary_statement -> NOT unary_statement .)
    PLUS            reduce using rule 42 (unary_statement -> NOT unary_statement .)
    MINUS           reduce using rule 42 (unary_statement -> NOT unary_statement .)
    LT              reduce using rule 42 (unary_statement -> NOT unary_statement .)
    GT              reduce using rule 42 (unary_statement -> NOT unary_statement .)
    LTEQ            reduce using rule 42 (unary_statement -> NOT unary_statement .)
    GTEQ            reduce using rule 42 (unary_statement -> NOT unary_statement .)
    EQ              reduce using rule 42 (unary_statement -> NOT unary_statement .)
    NEQ             reduce using rule 42 (unary_statement -> NOT unary_statement .)
    AND             reduce using rule 42 (unary_statement -> NOT unary_statement .)
    OR              reduce using rule 42 (unary_statement -> NOT unary_statement .)
    $end            reduce using rule 42 (unary_statement -> NOT unary_statement .)
    COLON           reduce using rule 42 (unary_statement -> NOT unary_statement .)
    RPAREN          reduce using rule 42 (unary_statement -> NOT unary_statement .)
    COMMA           reduce using rule 42 (unary_statement -> NOT unary_statement .)
    ENDWHILE        reduce using rule 42 (unary_statement -> NOT unary_statement .)
    ELSE            reduce using rule 42 (unary_statement -> NOT unary_statement .)
    ENDIF           reduce using rule 42 (unary_statement -> NOT unary_statement .)
    ENDFOR          reduce using rule 42 (unary_statement -> NOT unary_statement .)


state 64

    (8) iterative_statement -> WHILE expression COLON . start ENDWHILE
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . declarative_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) declarative_statement -> . variable_type IDENTIFIER
    (13) declarative_statement -> . variable_type IDENTIFIER EQUALS atom
    (18) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (14) variable_type -> . TYP_INT
    (15) variable_type -> . TYP_FLOAT
    (16) variable_type -> . TYP_STR
    (17) variable_type -> . TYP_BOOL
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 11
    INPUT           shift and go to state 16
    PRINT           shift and go to state 18
    TYP_INT         shift and go to state 20
    TYP_FLOAT       shift and go to state 21
    TYP_STR         shift and go to state 22
    TYP_BOOL        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 6
    start                          shift and go to state 86
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    declarative_statement          shift and go to state 5
    input_function                 shift and go to state 7
    output_function                shift and go to state 8
    variable_type                  shift and go to state 12
    atom                           shift and go to state 14
    assignment_statement           shift and go to state 15
    term                           shift and go to state 19
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32

state 65

    (9) iterative_statement -> FOR EQUALS expression . COMMA expression COMMA expression COLON start ENDFOR

    COMMA           shift and go to state 87


state 66

    (10) conditional_statement -> IF expression COLON . start ELSE start ENDIF
    (11) conditional_statement -> IF expression COLON . start ENDIF
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . declarative_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) declarative_statement -> . variable_type IDENTIFIER
    (13) declarative_statement -> . variable_type IDENTIFIER EQUALS atom
    (18) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (14) variable_type -> . TYP_INT
    (15) variable_type -> . TYP_FLOAT
    (16) variable_type -> . TYP_STR
    (17) variable_type -> . TYP_BOOL
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 11
    INPUT           shift and go to state 16
    PRINT           shift and go to state 18
    TYP_INT         shift and go to state 20
    TYP_FLOAT       shift and go to state 21
    TYP_STR         shift and go to state 22
    TYP_BOOL        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 6
    start                          shift and go to state 88
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    declarative_statement          shift and go to state 5
    input_function                 shift and go to state 7
    output_function                shift and go to state 8
    variable_type                  shift and go to state 12
    atom                           shift and go to state 14
    assignment_statement           shift and go to state 15
    term                           shift and go to state 19
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32

state 67

    (13) declarative_statement -> variable_type IDENTIFIER EQUALS . atom
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    atom                           shift and go to state 89

state 68

    (20) assignment_statement -> IDENTIFIER EQUALS or_statement .
    (22) or_statement -> or_statement . OR and_statement

    $end            reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COLON           reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    RPAREN          reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COMMA           reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDWHILE        reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ELSE            reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDIF           reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDFOR          reduce using rule 20 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    OR              shift and go to state 48


state 69

    (53) input_function -> INPUT LPAREN IDENTIFIER . RPAREN

    RPAREN          shift and go to state 90


state 70

    (47) term -> LPAREN expression RPAREN .

    POWER           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 47 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 47 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    LTEQ            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    GTEQ            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 47 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 47 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 47 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    COLON           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 47 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    ENDWHILE        reduce using rule 47 (term -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 47 (term -> LPAREN expression RPAREN .)
    ENDIF           reduce using rule 47 (term -> LPAREN expression RPAREN .)
    ENDFOR          reduce using rule 47 (term -> LPAREN expression RPAREN .)


state 71

    (54) output_function -> PRINT LPAREN term . RPAREN

    RPAREN          shift and go to state 91


state 72

    (44) exponent -> term POWER unary_statement .

    TIMES           reduce using rule 44 (exponent -> term POWER unary_statement .)
    DIVIDE          reduce using rule 44 (exponent -> term POWER unary_statement .)
    MOD             reduce using rule 44 (exponent -> term POWER unary_statement .)
    PLUS            reduce using rule 44 (exponent -> term POWER unary_statement .)
    MINUS           reduce using rule 44 (exponent -> term POWER unary_statement .)
    LT              reduce using rule 44 (exponent -> term POWER unary_statement .)
    GT              reduce using rule 44 (exponent -> term POWER unary_statement .)
    LTEQ            reduce using rule 44 (exponent -> term POWER unary_statement .)
    GTEQ            reduce using rule 44 (exponent -> term POWER unary_statement .)
    EQ              reduce using rule 44 (exponent -> term POWER unary_statement .)
    NEQ             reduce using rule 44 (exponent -> term POWER unary_statement .)
    AND             reduce using rule 44 (exponent -> term POWER unary_statement .)
    OR              reduce using rule 44 (exponent -> term POWER unary_statement .)
    $end            reduce using rule 44 (exponent -> term POWER unary_statement .)
    COLON           reduce using rule 44 (exponent -> term POWER unary_statement .)
    RPAREN          reduce using rule 44 (exponent -> term POWER unary_statement .)
    COMMA           reduce using rule 44 (exponent -> term POWER unary_statement .)
    ENDWHILE        reduce using rule 44 (exponent -> term POWER unary_statement .)
    ELSE            reduce using rule 44 (exponent -> term POWER unary_statement .)
    ENDIF           reduce using rule 44 (exponent -> term POWER unary_statement .)
    ENDFOR          reduce using rule 44 (exponent -> term POWER unary_statement .)


state 73

    (22) or_statement -> or_statement OR and_statement .
    (24) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    $end            reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    COLON           reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    RPAREN          reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    COMMA           reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    ENDWHILE        reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    ELSE            reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    ENDIF           reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    ENDFOR          reduce using rule 22 (or_statement -> or_statement OR and_statement .)
    AND             shift and go to state 49


state 74

    (24) and_statement -> and_statement AND equality_statement .
    (26) equality_statement -> equality_statement . EQ relational_statement
    (27) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    OR              reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    $end            reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    COLON           reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    RPAREN          reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    COMMA           reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    ENDWHILE        reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    ELSE            reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    ENDIF           reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    ENDFOR          reduce using rule 24 (and_statement -> and_statement AND equality_statement .)
    EQ              shift and go to state 50
    NEQ             shift and go to state 51


state 75

    (26) equality_statement -> equality_statement EQ relational_statement .
    (29) relational_statement -> relational_statement . LT add_statement
    (30) relational_statement -> relational_statement . GT add_statement
    (31) relational_statement -> relational_statement . LTEQ add_statement
    (32) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    NEQ             reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    AND             reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    OR              reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    $end            reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    COLON           reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    RPAREN          reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    COMMA           reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    ENDWHILE        reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    ELSE            reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    ENDIF           reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    ENDFOR          reduce using rule 26 (equality_statement -> equality_statement EQ relational_statement .)
    LT              shift and go to state 52
    GT              shift and go to state 53
    LTEQ            shift and go to state 54
    GTEQ            shift and go to state 55


state 76

    (27) equality_statement -> equality_statement NEQ relational_statement .
    (29) relational_statement -> relational_statement . LT add_statement
    (30) relational_statement -> relational_statement . GT add_statement
    (31) relational_statement -> relational_statement . LTEQ add_statement
    (32) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    NEQ             reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    AND             reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    OR              reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    $end            reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    COLON           reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    RPAREN          reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    COMMA           reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDWHILE        reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    ELSE            reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDIF           reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDFOR          reduce using rule 27 (equality_statement -> equality_statement NEQ relational_statement .)
    LT              shift and go to state 52
    GT              shift and go to state 53
    LTEQ            shift and go to state 54
    GTEQ            shift and go to state 55


state 77

    (29) relational_statement -> relational_statement LT add_statement .
    (34) add_statement -> add_statement . PLUS multiply_statement
    (35) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    GT              reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    LTEQ            reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    GTEQ            reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    EQ              reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    NEQ             reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    AND             reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    OR              reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    $end            reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    COLON           reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    RPAREN          reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    COMMA           reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    ENDWHILE        reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    ELSE            reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    ENDIF           reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    ENDFOR          reduce using rule 29 (relational_statement -> relational_statement LT add_statement .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 78

    (30) relational_statement -> relational_statement GT add_statement .
    (34) add_statement -> add_statement . PLUS multiply_statement
    (35) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    GT              reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    LTEQ            reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    GTEQ            reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    EQ              reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    NEQ             reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    AND             reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    OR              reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    $end            reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    COLON           reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    RPAREN          reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    COMMA           reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    ENDWHILE        reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    ELSE            reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    ENDIF           reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    ENDFOR          reduce using rule 30 (relational_statement -> relational_statement GT add_statement .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 79

    (31) relational_statement -> relational_statement LTEQ add_statement .
    (34) add_statement -> add_statement . PLUS multiply_statement
    (35) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    GT              reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    LTEQ            reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    GTEQ            reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    EQ              reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    NEQ             reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    AND             reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    OR              reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    $end            reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    COLON           reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    RPAREN          reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    COMMA           reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDWHILE        reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    ELSE            reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDIF           reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDFOR          reduce using rule 31 (relational_statement -> relational_statement LTEQ add_statement .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 80

    (32) relational_statement -> relational_statement GTEQ add_statement .
    (34) add_statement -> add_statement . PLUS multiply_statement
    (35) add_statement -> add_statement . MINUS multiply_statement

    LT              reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    GT              reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    LTEQ            reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    GTEQ            reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    EQ              reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    NEQ             reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    AND             reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    OR              reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    $end            reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    COLON           reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    RPAREN          reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    COMMA           reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDWHILE        reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    ELSE            reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDIF           reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDFOR          reduce using rule 32 (relational_statement -> relational_statement GTEQ add_statement .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 81

    (34) add_statement -> add_statement PLUS multiply_statement .
    (37) multiply_statement -> multiply_statement . TIMES unary_statement
    (38) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (39) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    MINUS           reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    LT              reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    GT              reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    LTEQ            reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    GTEQ            reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    EQ              reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    NEQ             reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    AND             reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    OR              reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    $end            reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    COLON           reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    RPAREN          reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    COMMA           reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    ENDWHILE        reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    ELSE            reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    ENDIF           reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    ENDFOR          reduce using rule 34 (add_statement -> add_statement PLUS multiply_statement .)
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60


state 82

    (35) add_statement -> add_statement MINUS multiply_statement .
    (37) multiply_statement -> multiply_statement . TIMES unary_statement
    (38) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (39) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    MINUS           reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    LT              reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    GT              reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    LTEQ            reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    GTEQ            reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    EQ              reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    NEQ             reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    AND             reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    OR              reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    $end            reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    COLON           reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    RPAREN          reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    COMMA           reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    ENDWHILE        reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    ELSE            reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    ENDIF           reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    ENDFOR          reduce using rule 35 (add_statement -> add_statement MINUS multiply_statement .)
    TIMES           shift and go to state 58
    DIVIDE          shift and go to state 59
    MOD             shift and go to state 60


state 83

    (37) multiply_statement -> multiply_statement TIMES unary_statement .

    TIMES           reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    DIVIDE          reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MOD             reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    PLUS            reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MINUS           reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LT              reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GT              reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LTEQ            reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GTEQ            reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    EQ              reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    NEQ             reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    AND             reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    OR              reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    $end            reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COLON           reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    RPAREN          reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COMMA           reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDWHILE        reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ELSE            reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDIF           reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDFOR          reduce using rule 37 (multiply_statement -> multiply_statement TIMES unary_statement .)


state 84

    (38) multiply_statement -> multiply_statement DIVIDE unary_statement .

    TIMES           reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    DIVIDE          reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MOD             reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    PLUS            reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MINUS           reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LT              reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GT              reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LTEQ            reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GTEQ            reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    EQ              reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    NEQ             reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    AND             reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    OR              reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    $end            reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COLON           reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    RPAREN          reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COMMA           reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDWHILE        reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ELSE            reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDIF           reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDFOR          reduce using rule 38 (multiply_statement -> multiply_statement DIVIDE unary_statement .)


state 85

    (39) multiply_statement -> multiply_statement MOD unary_statement .

    TIMES           reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    DIVIDE          reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    MOD             reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    PLUS            reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    MINUS           reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    LT              reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    GT              reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    LTEQ            reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    GTEQ            reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    EQ              reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    NEQ             reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    AND             reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    OR              reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    $end            reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    COLON           reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    RPAREN          reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    COMMA           reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDWHILE        reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    ELSE            reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDIF           reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDFOR          reduce using rule 39 (multiply_statement -> multiply_statement MOD unary_statement .)


state 86

    (8) iterative_statement -> WHILE expression COLON start . ENDWHILE

    ENDWHILE        shift and go to state 92


state 87

    (9) iterative_statement -> FOR EQUALS expression COMMA . expression COMMA expression COLON start ENDFOR
    (18) expression -> . assignment_statement
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 93
    assignment_statement           shift and go to state 15
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 88

    (10) conditional_statement -> IF expression COLON start . ELSE start ENDIF
    (11) conditional_statement -> IF expression COLON start . ENDIF

    ELSE            shift and go to state 94
    ENDIF           shift and go to state 95


state 89

    (13) declarative_statement -> variable_type IDENTIFIER EQUALS atom .

    $end            reduce using rule 13 (declarative_statement -> variable_type IDENTIFIER EQUALS atom .)
    ENDWHILE        reduce using rule 13 (declarative_statement -> variable_type IDENTIFIER EQUALS atom .)
    ELSE            reduce using rule 13 (declarative_statement -> variable_type IDENTIFIER EQUALS atom .)
    ENDIF           reduce using rule 13 (declarative_statement -> variable_type IDENTIFIER EQUALS atom .)
    ENDFOR          reduce using rule 13 (declarative_statement -> variable_type IDENTIFIER EQUALS atom .)


state 90

    (53) input_function -> INPUT LPAREN IDENTIFIER RPAREN .

    $end            reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDWHILE        reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ELSE            reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDIF           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDFOR          reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)


state 91

    (54) output_function -> PRINT LPAREN term RPAREN .

    $end            reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ENDWHILE        reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ELSE            reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ENDIF           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ENDFOR          reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)


state 92

    (8) iterative_statement -> WHILE expression COLON start ENDWHILE .

    $end            reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDWHILE        reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ELSE            reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDIF           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDFOR          reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)


state 93

    (9) iterative_statement -> FOR EQUALS expression COMMA expression . COMMA expression COLON start ENDFOR

    COMMA           shift and go to state 96


state 94

    (10) conditional_statement -> IF expression COLON start ELSE . start ENDIF
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . declarative_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) declarative_statement -> . variable_type IDENTIFIER
    (13) declarative_statement -> . variable_type IDENTIFIER EQUALS atom
    (18) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (14) variable_type -> . TYP_INT
    (15) variable_type -> . TYP_FLOAT
    (16) variable_type -> . TYP_STR
    (17) variable_type -> . TYP_BOOL
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 11
    INPUT           shift and go to state 16
    PRINT           shift and go to state 18
    TYP_INT         shift and go to state 20
    TYP_FLOAT       shift and go to state 21
    TYP_STR         shift and go to state 22
    TYP_BOOL        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 6
    start                          shift and go to state 97
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    declarative_statement          shift and go to state 5
    input_function                 shift and go to state 7
    output_function                shift and go to state 8
    variable_type                  shift and go to state 12
    atom                           shift and go to state 14
    assignment_statement           shift and go to state 15
    term                           shift and go to state 19
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32

state 95

    (11) conditional_statement -> IF expression COLON start ENDIF .

    $end            reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDWHILE        reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ELSE            reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDIF           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDFOR          reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)


state 96

    (9) iterative_statement -> FOR EQUALS expression COMMA expression COMMA . expression COLON start ENDFOR
    (18) expression -> . assignment_statement
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 98
    assignment_statement           shift and go to state 15
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32
    term                           shift and go to state 19
    atom                           shift and go to state 14

state 97

    (10) conditional_statement -> IF expression COLON start ELSE start . ENDIF

    ENDIF           shift and go to state 99


state 98

    (9) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression . COLON start ENDFOR

    COLON           shift and go to state 100


state 99

    (10) conditional_statement -> IF expression COLON start ELSE start ENDIF .

    $end            reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDWHILE        reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ELSE            reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDIF           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDFOR          reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)


state 100

    (9) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON . start ENDFOR
    (1) start -> . code_entity
    (2) code_entity -> . iterative_statement
    (3) code_entity -> . conditional_statement
    (4) code_entity -> . declarative_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) declarative_statement -> . variable_type IDENTIFIER
    (13) declarative_statement -> . variable_type IDENTIFIER EQUALS atom
    (18) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (14) variable_type -> . TYP_INT
    (15) variable_type -> . TYP_FLOAT
    (16) variable_type -> . TYP_STR
    (17) variable_type -> . TYP_BOOL
    (19) assignment_statement -> . or_statement
    (20) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (21) or_statement -> . and_statement
    (22) or_statement -> . or_statement OR and_statement
    (23) and_statement -> . equality_statement
    (24) and_statement -> . and_statement AND equality_statement
    (25) equality_statement -> . relational_statement
    (26) equality_statement -> . equality_statement EQ relational_statement
    (27) equality_statement -> . equality_statement NEQ relational_statement
    (28) relational_statement -> . add_statement
    (29) relational_statement -> . relational_statement LT add_statement
    (30) relational_statement -> . relational_statement GT add_statement
    (31) relational_statement -> . relational_statement LTEQ add_statement
    (32) relational_statement -> . relational_statement GTEQ add_statement
    (33) add_statement -> . multiply_statement
    (34) add_statement -> . add_statement PLUS multiply_statement
    (35) add_statement -> . add_statement MINUS multiply_statement
    (36) multiply_statement -> . unary_statement
    (37) multiply_statement -> . multiply_statement TIMES unary_statement
    (38) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (39) multiply_statement -> . multiply_statement MOD unary_statement
    (40) unary_statement -> . exponent
    (41) unary_statement -> . MINUS unary_statement
    (42) unary_statement -> . NOT unary_statement
    (43) exponent -> . term
    (44) exponent -> . term POWER unary_statement
    (45) term -> . IDENTIFIER
    (46) term -> . atom
    (47) term -> . LPAREN expression RPAREN
    (48) atom -> . INTEGER
    (49) atom -> . FLOAT
    (50) atom -> . STRING
    (51) atom -> . TRUE
    (52) atom -> . FALSE

    WHILE           shift and go to state 9
    FOR             shift and go to state 10
    IF              shift and go to state 11
    INPUT           shift and go to state 16
    PRINT           shift and go to state 18
    TYP_INT         shift and go to state 20
    TYP_FLOAT       shift and go to state 21
    TYP_STR         shift and go to state 22
    TYP_BOOL        shift and go to state 23
    IDENTIFIER      shift and go to state 13
    MINUS           shift and go to state 30
    NOT             shift and go to state 33
    LPAREN          shift and go to state 17
    INTEGER         shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    TRUE            shift and go to state 37
    FALSE           shift and go to state 38

    expression                     shift and go to state 6
    start                          shift and go to state 101
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    declarative_statement          shift and go to state 5
    input_function                 shift and go to state 7
    output_function                shift and go to state 8
    variable_type                  shift and go to state 12
    atom                           shift and go to state 14
    assignment_statement           shift and go to state 15
    term                           shift and go to state 19
    or_statement                   shift and go to state 24
    and_statement                  shift and go to state 25
    equality_statement             shift and go to state 26
    relational_statement           shift and go to state 27
    add_statement                  shift and go to state 28
    multiply_statement             shift and go to state 29
    unary_statement                shift and go to state 31
    exponent                       shift and go to state 32

state 101

    (9) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start . ENDFOR

    ENDFOR          shift and go to state 102


state 102

    (9) iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .

    $end            reduce using rule 9 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDWHILE        reduce using rule 9 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ELSE            reduce using rule 9 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDIF           reduce using rule 9 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDFOR          reduce using rule 9 (iterative_statement -> FOR EQUALS expression COMMA expression COMMA expression COLON start ENDFOR .)

