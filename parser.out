Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> <empty>
Rule 2     start -> code_entity start
Rule 3     code_entity -> iterative_statement
Rule 4     code_entity -> conditional_statement
Rule 5     code_entity -> expression
Rule 6     code_entity -> input_function
Rule 7     code_entity -> output_function
Rule 8     code_entity -> array_append
Rule 9     iterative_statement -> WHILE or_statement COLON start ENDWHILE
Rule 10    iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
Rule 11    conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF
Rule 12    conditional_statement -> IF or_statement COLON start ENDIF
Rule 13    expression -> assignment_statement
Rule 14    assignment_statement -> or_statement
Rule 15    assignment_statement -> IDENTIFIER EQUALS or_statement
Rule 16    assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
Rule 17    assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
Rule 18    or_statement -> and_statement
Rule 19    or_statement -> or_statement OR and_statement
Rule 20    and_statement -> equality_statement
Rule 21    and_statement -> and_statement AND equality_statement
Rule 22    equality_statement -> relational_statement
Rule 23    equality_statement -> equality_statement EQ relational_statement
Rule 24    equality_statement -> equality_statement NEQ relational_statement
Rule 25    relational_statement -> add_statement
Rule 26    relational_statement -> relational_statement LT add_statement
Rule 27    relational_statement -> relational_statement GT add_statement
Rule 28    relational_statement -> relational_statement LTEQ add_statement
Rule 29    relational_statement -> relational_statement GTEQ add_statement
Rule 30    add_statement -> multiply_statement
Rule 31    add_statement -> add_statement PLUS multiply_statement
Rule 32    add_statement -> add_statement MINUS multiply_statement
Rule 33    multiply_statement -> unary_statement
Rule 34    multiply_statement -> multiply_statement TIMES unary_statement
Rule 35    multiply_statement -> multiply_statement DIVIDE unary_statement
Rule 36    multiply_statement -> multiply_statement FLRDIV unary_statement
Rule 37    multiply_statement -> multiply_statement MOD unary_statement
Rule 38    unary_statement -> exponent
Rule 39    unary_statement -> MINUS unary_statement
Rule 40    unary_statement -> NOT unary_statement
Rule 41    exponent -> term
Rule 42    exponent -> term POWER unary_statement
Rule 43    term -> IDENTIFIER
Rule 44    term -> atom
Rule 45    term -> LPAREN or_statement RPAREN
Rule 46    atom -> INTEGER
Rule 47    atom -> FLOAT
Rule 48    atom -> STRING
Rule 49    atom -> TRUE
Rule 50    atom -> FALSE
Rule 51    atom -> LBRACKET elements RBRACKET
Rule 52    atom -> IDENTIFIER LBRACKET INTEGER RBRACKET
Rule 53    atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET
Rule 54    elements -> elements INTEGER
Rule 55    elements -> elements FLOAT
Rule 56    elements -> <empty>
Rule 57    input_function -> INPUT LPAREN IDENTIFIER RPAREN
Rule 58    output_function -> PRINT LPAREN term RPAREN
Rule 59    array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
Rule 60    array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
Rule 61    array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN

Terminals, with rules where they appear

AND                  : 21
APPEND               : 59 60 61
COLON                : 9 10 11 11 12
COMMA                : 10 10
DIVIDE               : 35
ELSE                 : 11
ENDFOR               : 10
ENDIF                : 11 12
ENDWHILE             : 9
EQ                   : 23
EQUALS               : 15 16 17
FALSE                : 50
FLOAT                : 47 55 60
FLRDIV               : 36
FOR                  : 10
GT                   : 27
GTEQ                 : 29
IDENTIFIER           : 15 16 17 17 43 52 53 53 57 59 60 61 61
IF                   : 11 12
INPUT                : 57
INTEGER              : 16 46 52 54 59
LBRACKET             : 16 17 51 52 53
LPAREN               : 45 57 58 59 60 61
LT                   : 26
LTEQ                 : 28
MINUS                : 32 39
MOD                  : 37
NEQ                  : 24
NOT                  : 40
OR                   : 19
PERIOD               : 59 60 61
PLUS                 : 31
POWER                : 42
PRINT                : 58
RBRACKET             : 16 17 51 52 53
RPAREN               : 45 57 58 59 60 61
STRING               : 48
TIMES                : 34
TRUE                 : 49
WHILE                : 9
error                : 

Nonterminals, with rules where they appear

add_statement        : 25 26 27 28 29 31 32
and_statement        : 18 19 21
array_append         : 8
assignment_statement : 10 10 13
atom                 : 44
code_entity          : 2
conditional_statement : 4
elements             : 51 54 55
equality_statement   : 20 21 23 24
exponent             : 38
expression           : 5
input_function       : 6
iterative_statement  : 3
multiply_statement   : 30 31 32 34 35 36 37
or_statement         : 9 10 11 12 14 15 16 17 19 45
output_function      : 7
relational_statement : 22 23 24 26 27 28 29
start                : 2 9 10 11 11 12 0
term                 : 41 42 58
unary_statement      : 33 34 35 36 37 39 40 42

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> .
    (2) start -> . code_entity start
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) code_entity -> . array_append
    (9) iterative_statement -> . WHILE or_statement COLON start ENDWHILE
    (10) iterative_statement -> . FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (11) conditional_statement -> . IF or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> . IF or_statement COLON start ENDIF
    (13) expression -> . assignment_statement
    (57) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (58) output_function -> . PRINT LPAREN term RPAREN
    (59) array_append -> . IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> . IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> . IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    $end            reduce using rule 1 (start -> .)
    WHILE           shift and go to state 9
    FOR             shift and go to state 11
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    PRINT           shift and go to state 17
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    start                          shift and go to state 1
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    array_append                   shift and go to state 8
    or_statement                   shift and go to state 10
    assignment_statement           shift and go to state 12
    term                           shift and go to state 18
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 1

    (0) S' -> start .



state 2

    (2) start -> code_entity . start
    (1) start -> .
    (2) start -> . code_entity start
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) code_entity -> . array_append
    (9) iterative_statement -> . WHILE or_statement COLON start ENDWHILE
    (10) iterative_statement -> . FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (11) conditional_statement -> . IF or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> . IF or_statement COLON start ENDIF
    (13) expression -> . assignment_statement
    (57) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (58) output_function -> . PRINT LPAREN term RPAREN
    (59) array_append -> . IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> . IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> . IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    $end            reduce using rule 1 (start -> .)
    ENDWHILE        reduce using rule 1 (start -> .)
    ELSE            reduce using rule 1 (start -> .)
    ENDIF           reduce using rule 1 (start -> .)
    ENDFOR          reduce using rule 1 (start -> .)
    WHILE           shift and go to state 9
    FOR             shift and go to state 11
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    PRINT           shift and go to state 17
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    code_entity                    shift and go to state 2
    start                          shift and go to state 35
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    array_append                   shift and go to state 8
    or_statement                   shift and go to state 10
    assignment_statement           shift and go to state 12
    term                           shift and go to state 18
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 3

    (3) code_entity -> iterative_statement .

    WHILE           reduce using rule 3 (code_entity -> iterative_statement .)
    FOR             reduce using rule 3 (code_entity -> iterative_statement .)
    IF              reduce using rule 3 (code_entity -> iterative_statement .)
    INPUT           reduce using rule 3 (code_entity -> iterative_statement .)
    PRINT           reduce using rule 3 (code_entity -> iterative_statement .)
    IDENTIFIER      reduce using rule 3 (code_entity -> iterative_statement .)
    MINUS           reduce using rule 3 (code_entity -> iterative_statement .)
    NOT             reduce using rule 3 (code_entity -> iterative_statement .)
    LPAREN          reduce using rule 3 (code_entity -> iterative_statement .)
    INTEGER         reduce using rule 3 (code_entity -> iterative_statement .)
    FLOAT           reduce using rule 3 (code_entity -> iterative_statement .)
    STRING          reduce using rule 3 (code_entity -> iterative_statement .)
    TRUE            reduce using rule 3 (code_entity -> iterative_statement .)
    FALSE           reduce using rule 3 (code_entity -> iterative_statement .)
    LBRACKET        reduce using rule 3 (code_entity -> iterative_statement .)
    $end            reduce using rule 3 (code_entity -> iterative_statement .)
    ENDWHILE        reduce using rule 3 (code_entity -> iterative_statement .)
    ELSE            reduce using rule 3 (code_entity -> iterative_statement .)
    ENDIF           reduce using rule 3 (code_entity -> iterative_statement .)
    ENDFOR          reduce using rule 3 (code_entity -> iterative_statement .)


state 4

    (4) code_entity -> conditional_statement .

    WHILE           reduce using rule 4 (code_entity -> conditional_statement .)
    FOR             reduce using rule 4 (code_entity -> conditional_statement .)
    IF              reduce using rule 4 (code_entity -> conditional_statement .)
    INPUT           reduce using rule 4 (code_entity -> conditional_statement .)
    PRINT           reduce using rule 4 (code_entity -> conditional_statement .)
    IDENTIFIER      reduce using rule 4 (code_entity -> conditional_statement .)
    MINUS           reduce using rule 4 (code_entity -> conditional_statement .)
    NOT             reduce using rule 4 (code_entity -> conditional_statement .)
    LPAREN          reduce using rule 4 (code_entity -> conditional_statement .)
    INTEGER         reduce using rule 4 (code_entity -> conditional_statement .)
    FLOAT           reduce using rule 4 (code_entity -> conditional_statement .)
    STRING          reduce using rule 4 (code_entity -> conditional_statement .)
    TRUE            reduce using rule 4 (code_entity -> conditional_statement .)
    FALSE           reduce using rule 4 (code_entity -> conditional_statement .)
    LBRACKET        reduce using rule 4 (code_entity -> conditional_statement .)
    $end            reduce using rule 4 (code_entity -> conditional_statement .)
    ENDWHILE        reduce using rule 4 (code_entity -> conditional_statement .)
    ELSE            reduce using rule 4 (code_entity -> conditional_statement .)
    ENDIF           reduce using rule 4 (code_entity -> conditional_statement .)
    ENDFOR          reduce using rule 4 (code_entity -> conditional_statement .)


state 5

    (5) code_entity -> expression .

    WHILE           reduce using rule 5 (code_entity -> expression .)
    FOR             reduce using rule 5 (code_entity -> expression .)
    IF              reduce using rule 5 (code_entity -> expression .)
    INPUT           reduce using rule 5 (code_entity -> expression .)
    PRINT           reduce using rule 5 (code_entity -> expression .)
    IDENTIFIER      reduce using rule 5 (code_entity -> expression .)
    MINUS           reduce using rule 5 (code_entity -> expression .)
    NOT             reduce using rule 5 (code_entity -> expression .)
    LPAREN          reduce using rule 5 (code_entity -> expression .)
    INTEGER         reduce using rule 5 (code_entity -> expression .)
    FLOAT           reduce using rule 5 (code_entity -> expression .)
    STRING          reduce using rule 5 (code_entity -> expression .)
    TRUE            reduce using rule 5 (code_entity -> expression .)
    FALSE           reduce using rule 5 (code_entity -> expression .)
    LBRACKET        reduce using rule 5 (code_entity -> expression .)
    $end            reduce using rule 5 (code_entity -> expression .)
    ENDWHILE        reduce using rule 5 (code_entity -> expression .)
    ELSE            reduce using rule 5 (code_entity -> expression .)
    ENDIF           reduce using rule 5 (code_entity -> expression .)
    ENDFOR          reduce using rule 5 (code_entity -> expression .)


state 6

    (6) code_entity -> input_function .

    WHILE           reduce using rule 6 (code_entity -> input_function .)
    FOR             reduce using rule 6 (code_entity -> input_function .)
    IF              reduce using rule 6 (code_entity -> input_function .)
    INPUT           reduce using rule 6 (code_entity -> input_function .)
    PRINT           reduce using rule 6 (code_entity -> input_function .)
    IDENTIFIER      reduce using rule 6 (code_entity -> input_function .)
    MINUS           reduce using rule 6 (code_entity -> input_function .)
    NOT             reduce using rule 6 (code_entity -> input_function .)
    LPAREN          reduce using rule 6 (code_entity -> input_function .)
    INTEGER         reduce using rule 6 (code_entity -> input_function .)
    FLOAT           reduce using rule 6 (code_entity -> input_function .)
    STRING          reduce using rule 6 (code_entity -> input_function .)
    TRUE            reduce using rule 6 (code_entity -> input_function .)
    FALSE           reduce using rule 6 (code_entity -> input_function .)
    LBRACKET        reduce using rule 6 (code_entity -> input_function .)
    $end            reduce using rule 6 (code_entity -> input_function .)
    ENDWHILE        reduce using rule 6 (code_entity -> input_function .)
    ELSE            reduce using rule 6 (code_entity -> input_function .)
    ENDIF           reduce using rule 6 (code_entity -> input_function .)
    ENDFOR          reduce using rule 6 (code_entity -> input_function .)


state 7

    (7) code_entity -> output_function .

    WHILE           reduce using rule 7 (code_entity -> output_function .)
    FOR             reduce using rule 7 (code_entity -> output_function .)
    IF              reduce using rule 7 (code_entity -> output_function .)
    INPUT           reduce using rule 7 (code_entity -> output_function .)
    PRINT           reduce using rule 7 (code_entity -> output_function .)
    IDENTIFIER      reduce using rule 7 (code_entity -> output_function .)
    MINUS           reduce using rule 7 (code_entity -> output_function .)
    NOT             reduce using rule 7 (code_entity -> output_function .)
    LPAREN          reduce using rule 7 (code_entity -> output_function .)
    INTEGER         reduce using rule 7 (code_entity -> output_function .)
    FLOAT           reduce using rule 7 (code_entity -> output_function .)
    STRING          reduce using rule 7 (code_entity -> output_function .)
    TRUE            reduce using rule 7 (code_entity -> output_function .)
    FALSE           reduce using rule 7 (code_entity -> output_function .)
    LBRACKET        reduce using rule 7 (code_entity -> output_function .)
    $end            reduce using rule 7 (code_entity -> output_function .)
    ENDWHILE        reduce using rule 7 (code_entity -> output_function .)
    ELSE            reduce using rule 7 (code_entity -> output_function .)
    ENDIF           reduce using rule 7 (code_entity -> output_function .)
    ENDFOR          reduce using rule 7 (code_entity -> output_function .)


state 8

    (8) code_entity -> array_append .

    WHILE           reduce using rule 8 (code_entity -> array_append .)
    FOR             reduce using rule 8 (code_entity -> array_append .)
    IF              reduce using rule 8 (code_entity -> array_append .)
    INPUT           reduce using rule 8 (code_entity -> array_append .)
    PRINT           reduce using rule 8 (code_entity -> array_append .)
    IDENTIFIER      reduce using rule 8 (code_entity -> array_append .)
    MINUS           reduce using rule 8 (code_entity -> array_append .)
    NOT             reduce using rule 8 (code_entity -> array_append .)
    LPAREN          reduce using rule 8 (code_entity -> array_append .)
    INTEGER         reduce using rule 8 (code_entity -> array_append .)
    FLOAT           reduce using rule 8 (code_entity -> array_append .)
    STRING          reduce using rule 8 (code_entity -> array_append .)
    TRUE            reduce using rule 8 (code_entity -> array_append .)
    FALSE           reduce using rule 8 (code_entity -> array_append .)
    LBRACKET        reduce using rule 8 (code_entity -> array_append .)
    $end            reduce using rule 8 (code_entity -> array_append .)
    ENDWHILE        reduce using rule 8 (code_entity -> array_append .)
    ELSE            reduce using rule 8 (code_entity -> array_append .)
    ENDIF           reduce using rule 8 (code_entity -> array_append .)
    ENDFOR          reduce using rule 8 (code_entity -> array_append .)


state 9

    (9) iterative_statement -> WHILE . or_statement COLON start ENDWHILE
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 36
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 10

    (14) assignment_statement -> or_statement .
    (19) or_statement -> or_statement . OR and_statement

    WHILE           reduce using rule 14 (assignment_statement -> or_statement .)
    FOR             reduce using rule 14 (assignment_statement -> or_statement .)
    IF              reduce using rule 14 (assignment_statement -> or_statement .)
    INPUT           reduce using rule 14 (assignment_statement -> or_statement .)
    PRINT           reduce using rule 14 (assignment_statement -> or_statement .)
    IDENTIFIER      reduce using rule 14 (assignment_statement -> or_statement .)
    MINUS           reduce using rule 14 (assignment_statement -> or_statement .)
    NOT             reduce using rule 14 (assignment_statement -> or_statement .)
    LPAREN          reduce using rule 14 (assignment_statement -> or_statement .)
    INTEGER         reduce using rule 14 (assignment_statement -> or_statement .)
    FLOAT           reduce using rule 14 (assignment_statement -> or_statement .)
    STRING          reduce using rule 14 (assignment_statement -> or_statement .)
    TRUE            reduce using rule 14 (assignment_statement -> or_statement .)
    FALSE           reduce using rule 14 (assignment_statement -> or_statement .)
    LBRACKET        reduce using rule 14 (assignment_statement -> or_statement .)
    $end            reduce using rule 14 (assignment_statement -> or_statement .)
    ENDWHILE        reduce using rule 14 (assignment_statement -> or_statement .)
    ELSE            reduce using rule 14 (assignment_statement -> or_statement .)
    ENDIF           reduce using rule 14 (assignment_statement -> or_statement .)
    ENDFOR          reduce using rule 14 (assignment_statement -> or_statement .)
    COMMA           reduce using rule 14 (assignment_statement -> or_statement .)
    COLON           reduce using rule 14 (assignment_statement -> or_statement .)
    OR              shift and go to state 38


state 11

    (10) iterative_statement -> FOR . assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 40
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    assignment_statement           shift and go to state 39
    or_statement                   shift and go to state 10
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 12

    (13) expression -> assignment_statement .

    WHILE           reduce using rule 13 (expression -> assignment_statement .)
    FOR             reduce using rule 13 (expression -> assignment_statement .)
    IF              reduce using rule 13 (expression -> assignment_statement .)
    INPUT           reduce using rule 13 (expression -> assignment_statement .)
    PRINT           reduce using rule 13 (expression -> assignment_statement .)
    IDENTIFIER      reduce using rule 13 (expression -> assignment_statement .)
    MINUS           reduce using rule 13 (expression -> assignment_statement .)
    NOT             reduce using rule 13 (expression -> assignment_statement .)
    LPAREN          reduce using rule 13 (expression -> assignment_statement .)
    INTEGER         reduce using rule 13 (expression -> assignment_statement .)
    FLOAT           reduce using rule 13 (expression -> assignment_statement .)
    STRING          reduce using rule 13 (expression -> assignment_statement .)
    TRUE            reduce using rule 13 (expression -> assignment_statement .)
    FALSE           reduce using rule 13 (expression -> assignment_statement .)
    LBRACKET        reduce using rule 13 (expression -> assignment_statement .)
    $end            reduce using rule 13 (expression -> assignment_statement .)
    ENDWHILE        reduce using rule 13 (expression -> assignment_statement .)
    ELSE            reduce using rule 13 (expression -> assignment_statement .)
    ENDIF           reduce using rule 13 (expression -> assignment_statement .)
    ENDFOR          reduce using rule 13 (expression -> assignment_statement .)


state 13

    (11) conditional_statement -> IF . or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> IF . or_statement COLON start ENDIF
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 41
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 14

    (57) input_function -> INPUT . LPAREN IDENTIFIER RPAREN

    LPAREN          shift and go to state 42


state 15

    (45) term -> LPAREN . or_statement RPAREN
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 43
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 16

    (59) array_append -> IDENTIFIER . PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> IDENTIFIER . PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> IDENTIFIER . PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (15) assignment_statement -> IDENTIFIER . EQUALS or_statement
    (16) assignment_statement -> IDENTIFIER . LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> IDENTIFIER . LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (43) term -> IDENTIFIER .
    (52) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET
    (53) atom -> IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    PERIOD          shift and go to state 44
    EQUALS          shift and go to state 45
    LBRACKET        shift and go to state 46
    POWER           reduce using rule 43 (term -> IDENTIFIER .)
    TIMES           reduce using rule 43 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 43 (term -> IDENTIFIER .)
    FLRDIV          reduce using rule 43 (term -> IDENTIFIER .)
    MOD             reduce using rule 43 (term -> IDENTIFIER .)
    PLUS            reduce using rule 43 (term -> IDENTIFIER .)
    MINUS           reduce using rule 43 (term -> IDENTIFIER .)
    LT              reduce using rule 43 (term -> IDENTIFIER .)
    GT              reduce using rule 43 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 43 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 43 (term -> IDENTIFIER .)
    EQ              reduce using rule 43 (term -> IDENTIFIER .)
    NEQ             reduce using rule 43 (term -> IDENTIFIER .)
    AND             reduce using rule 43 (term -> IDENTIFIER .)
    OR              reduce using rule 43 (term -> IDENTIFIER .)
    WHILE           reduce using rule 43 (term -> IDENTIFIER .)
    FOR             reduce using rule 43 (term -> IDENTIFIER .)
    IF              reduce using rule 43 (term -> IDENTIFIER .)
    INPUT           reduce using rule 43 (term -> IDENTIFIER .)
    PRINT           reduce using rule 43 (term -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 43 (term -> IDENTIFIER .)
    NOT             reduce using rule 43 (term -> IDENTIFIER .)
    LPAREN          reduce using rule 43 (term -> IDENTIFIER .)
    INTEGER         reduce using rule 43 (term -> IDENTIFIER .)
    FLOAT           reduce using rule 43 (term -> IDENTIFIER .)
    STRING          reduce using rule 43 (term -> IDENTIFIER .)
    TRUE            reduce using rule 43 (term -> IDENTIFIER .)
    FALSE           reduce using rule 43 (term -> IDENTIFIER .)
    $end            reduce using rule 43 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 43 (term -> IDENTIFIER .)
    ELSE            reduce using rule 43 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 43 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 43 (term -> IDENTIFIER .)

  ! LBRACKET        [ reduce using rule 43 (term -> IDENTIFIER .) ]


state 17

    (58) output_function -> PRINT . LPAREN term RPAREN

    LPAREN          shift and go to state 47


state 18

    (41) exponent -> term .
    (42) exponent -> term . POWER unary_statement

    TIMES           reduce using rule 41 (exponent -> term .)
    DIVIDE          reduce using rule 41 (exponent -> term .)
    FLRDIV          reduce using rule 41 (exponent -> term .)
    MOD             reduce using rule 41 (exponent -> term .)
    PLUS            reduce using rule 41 (exponent -> term .)
    MINUS           reduce using rule 41 (exponent -> term .)
    LT              reduce using rule 41 (exponent -> term .)
    GT              reduce using rule 41 (exponent -> term .)
    LTEQ            reduce using rule 41 (exponent -> term .)
    GTEQ            reduce using rule 41 (exponent -> term .)
    EQ              reduce using rule 41 (exponent -> term .)
    NEQ             reduce using rule 41 (exponent -> term .)
    AND             reduce using rule 41 (exponent -> term .)
    OR              reduce using rule 41 (exponent -> term .)
    WHILE           reduce using rule 41 (exponent -> term .)
    FOR             reduce using rule 41 (exponent -> term .)
    IF              reduce using rule 41 (exponent -> term .)
    INPUT           reduce using rule 41 (exponent -> term .)
    PRINT           reduce using rule 41 (exponent -> term .)
    IDENTIFIER      reduce using rule 41 (exponent -> term .)
    NOT             reduce using rule 41 (exponent -> term .)
    LPAREN          reduce using rule 41 (exponent -> term .)
    INTEGER         reduce using rule 41 (exponent -> term .)
    FLOAT           reduce using rule 41 (exponent -> term .)
    STRING          reduce using rule 41 (exponent -> term .)
    TRUE            reduce using rule 41 (exponent -> term .)
    FALSE           reduce using rule 41 (exponent -> term .)
    LBRACKET        reduce using rule 41 (exponent -> term .)
    $end            reduce using rule 41 (exponent -> term .)
    ENDWHILE        reduce using rule 41 (exponent -> term .)
    ELSE            reduce using rule 41 (exponent -> term .)
    ENDIF           reduce using rule 41 (exponent -> term .)
    ENDFOR          reduce using rule 41 (exponent -> term .)
    COLON           reduce using rule 41 (exponent -> term .)
    COMMA           reduce using rule 41 (exponent -> term .)
    RPAREN          reduce using rule 41 (exponent -> term .)
    POWER           shift and go to state 48


state 19

    (46) atom -> INTEGER .

    POWER           reduce using rule 46 (atom -> INTEGER .)
    TIMES           reduce using rule 46 (atom -> INTEGER .)
    DIVIDE          reduce using rule 46 (atom -> INTEGER .)
    FLRDIV          reduce using rule 46 (atom -> INTEGER .)
    MOD             reduce using rule 46 (atom -> INTEGER .)
    PLUS            reduce using rule 46 (atom -> INTEGER .)
    MINUS           reduce using rule 46 (atom -> INTEGER .)
    LT              reduce using rule 46 (atom -> INTEGER .)
    GT              reduce using rule 46 (atom -> INTEGER .)
    LTEQ            reduce using rule 46 (atom -> INTEGER .)
    GTEQ            reduce using rule 46 (atom -> INTEGER .)
    EQ              reduce using rule 46 (atom -> INTEGER .)
    NEQ             reduce using rule 46 (atom -> INTEGER .)
    AND             reduce using rule 46 (atom -> INTEGER .)
    OR              reduce using rule 46 (atom -> INTEGER .)
    WHILE           reduce using rule 46 (atom -> INTEGER .)
    FOR             reduce using rule 46 (atom -> INTEGER .)
    IF              reduce using rule 46 (atom -> INTEGER .)
    INPUT           reduce using rule 46 (atom -> INTEGER .)
    PRINT           reduce using rule 46 (atom -> INTEGER .)
    IDENTIFIER      reduce using rule 46 (atom -> INTEGER .)
    NOT             reduce using rule 46 (atom -> INTEGER .)
    LPAREN          reduce using rule 46 (atom -> INTEGER .)
    INTEGER         reduce using rule 46 (atom -> INTEGER .)
    FLOAT           reduce using rule 46 (atom -> INTEGER .)
    STRING          reduce using rule 46 (atom -> INTEGER .)
    TRUE            reduce using rule 46 (atom -> INTEGER .)
    FALSE           reduce using rule 46 (atom -> INTEGER .)
    LBRACKET        reduce using rule 46 (atom -> INTEGER .)
    $end            reduce using rule 46 (atom -> INTEGER .)
    ENDWHILE        reduce using rule 46 (atom -> INTEGER .)
    ELSE            reduce using rule 46 (atom -> INTEGER .)
    ENDIF           reduce using rule 46 (atom -> INTEGER .)
    ENDFOR          reduce using rule 46 (atom -> INTEGER .)
    COLON           reduce using rule 46 (atom -> INTEGER .)
    COMMA           reduce using rule 46 (atom -> INTEGER .)
    RPAREN          reduce using rule 46 (atom -> INTEGER .)


state 20

    (47) atom -> FLOAT .

    POWER           reduce using rule 47 (atom -> FLOAT .)
    TIMES           reduce using rule 47 (atom -> FLOAT .)
    DIVIDE          reduce using rule 47 (atom -> FLOAT .)
    FLRDIV          reduce using rule 47 (atom -> FLOAT .)
    MOD             reduce using rule 47 (atom -> FLOAT .)
    PLUS            reduce using rule 47 (atom -> FLOAT .)
    MINUS           reduce using rule 47 (atom -> FLOAT .)
    LT              reduce using rule 47 (atom -> FLOAT .)
    GT              reduce using rule 47 (atom -> FLOAT .)
    LTEQ            reduce using rule 47 (atom -> FLOAT .)
    GTEQ            reduce using rule 47 (atom -> FLOAT .)
    EQ              reduce using rule 47 (atom -> FLOAT .)
    NEQ             reduce using rule 47 (atom -> FLOAT .)
    AND             reduce using rule 47 (atom -> FLOAT .)
    OR              reduce using rule 47 (atom -> FLOAT .)
    WHILE           reduce using rule 47 (atom -> FLOAT .)
    FOR             reduce using rule 47 (atom -> FLOAT .)
    IF              reduce using rule 47 (atom -> FLOAT .)
    INPUT           reduce using rule 47 (atom -> FLOAT .)
    PRINT           reduce using rule 47 (atom -> FLOAT .)
    IDENTIFIER      reduce using rule 47 (atom -> FLOAT .)
    NOT             reduce using rule 47 (atom -> FLOAT .)
    LPAREN          reduce using rule 47 (atom -> FLOAT .)
    INTEGER         reduce using rule 47 (atom -> FLOAT .)
    FLOAT           reduce using rule 47 (atom -> FLOAT .)
    STRING          reduce using rule 47 (atom -> FLOAT .)
    TRUE            reduce using rule 47 (atom -> FLOAT .)
    FALSE           reduce using rule 47 (atom -> FLOAT .)
    LBRACKET        reduce using rule 47 (atom -> FLOAT .)
    $end            reduce using rule 47 (atom -> FLOAT .)
    ENDWHILE        reduce using rule 47 (atom -> FLOAT .)
    ELSE            reduce using rule 47 (atom -> FLOAT .)
    ENDIF           reduce using rule 47 (atom -> FLOAT .)
    ENDFOR          reduce using rule 47 (atom -> FLOAT .)
    COLON           reduce using rule 47 (atom -> FLOAT .)
    COMMA           reduce using rule 47 (atom -> FLOAT .)
    RPAREN          reduce using rule 47 (atom -> FLOAT .)


state 21

    (51) atom -> LBRACKET . elements RBRACKET
    (54) elements -> . elements INTEGER
    (55) elements -> . elements FLOAT
    (56) elements -> .

    RBRACKET        reduce using rule 56 (elements -> .)
    INTEGER         reduce using rule 56 (elements -> .)
    FLOAT           reduce using rule 56 (elements -> .)

    elements                       shift and go to state 49

state 22

    (18) or_statement -> and_statement .
    (21) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 18 (or_statement -> and_statement .)
    WHILE           reduce using rule 18 (or_statement -> and_statement .)
    FOR             reduce using rule 18 (or_statement -> and_statement .)
    IF              reduce using rule 18 (or_statement -> and_statement .)
    INPUT           reduce using rule 18 (or_statement -> and_statement .)
    PRINT           reduce using rule 18 (or_statement -> and_statement .)
    IDENTIFIER      reduce using rule 18 (or_statement -> and_statement .)
    MINUS           reduce using rule 18 (or_statement -> and_statement .)
    NOT             reduce using rule 18 (or_statement -> and_statement .)
    LPAREN          reduce using rule 18 (or_statement -> and_statement .)
    INTEGER         reduce using rule 18 (or_statement -> and_statement .)
    FLOAT           reduce using rule 18 (or_statement -> and_statement .)
    STRING          reduce using rule 18 (or_statement -> and_statement .)
    TRUE            reduce using rule 18 (or_statement -> and_statement .)
    FALSE           reduce using rule 18 (or_statement -> and_statement .)
    LBRACKET        reduce using rule 18 (or_statement -> and_statement .)
    $end            reduce using rule 18 (or_statement -> and_statement .)
    ENDWHILE        reduce using rule 18 (or_statement -> and_statement .)
    ELSE            reduce using rule 18 (or_statement -> and_statement .)
    ENDIF           reduce using rule 18 (or_statement -> and_statement .)
    ENDFOR          reduce using rule 18 (or_statement -> and_statement .)
    COLON           reduce using rule 18 (or_statement -> and_statement .)
    COMMA           reduce using rule 18 (or_statement -> and_statement .)
    RPAREN          reduce using rule 18 (or_statement -> and_statement .)
    AND             shift and go to state 50


state 23

    (20) and_statement -> equality_statement .
    (23) equality_statement -> equality_statement . EQ relational_statement
    (24) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 20 (and_statement -> equality_statement .)
    OR              reduce using rule 20 (and_statement -> equality_statement .)
    WHILE           reduce using rule 20 (and_statement -> equality_statement .)
    FOR             reduce using rule 20 (and_statement -> equality_statement .)
    IF              reduce using rule 20 (and_statement -> equality_statement .)
    INPUT           reduce using rule 20 (and_statement -> equality_statement .)
    PRINT           reduce using rule 20 (and_statement -> equality_statement .)
    IDENTIFIER      reduce using rule 20 (and_statement -> equality_statement .)
    MINUS           reduce using rule 20 (and_statement -> equality_statement .)
    NOT             reduce using rule 20 (and_statement -> equality_statement .)
    LPAREN          reduce using rule 20 (and_statement -> equality_statement .)
    INTEGER         reduce using rule 20 (and_statement -> equality_statement .)
    FLOAT           reduce using rule 20 (and_statement -> equality_statement .)
    STRING          reduce using rule 20 (and_statement -> equality_statement .)
    TRUE            reduce using rule 20 (and_statement -> equality_statement .)
    FALSE           reduce using rule 20 (and_statement -> equality_statement .)
    LBRACKET        reduce using rule 20 (and_statement -> equality_statement .)
    $end            reduce using rule 20 (and_statement -> equality_statement .)
    ENDWHILE        reduce using rule 20 (and_statement -> equality_statement .)
    ELSE            reduce using rule 20 (and_statement -> equality_statement .)
    ENDIF           reduce using rule 20 (and_statement -> equality_statement .)
    ENDFOR          reduce using rule 20 (and_statement -> equality_statement .)
    COLON           reduce using rule 20 (and_statement -> equality_statement .)
    COMMA           reduce using rule 20 (and_statement -> equality_statement .)
    RPAREN          reduce using rule 20 (and_statement -> equality_statement .)
    EQ              shift and go to state 51
    NEQ             shift and go to state 52


state 24

    (22) equality_statement -> relational_statement .
    (26) relational_statement -> relational_statement . LT add_statement
    (27) relational_statement -> relational_statement . GT add_statement
    (28) relational_statement -> relational_statement . LTEQ add_statement
    (29) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 22 (equality_statement -> relational_statement .)
    NEQ             reduce using rule 22 (equality_statement -> relational_statement .)
    AND             reduce using rule 22 (equality_statement -> relational_statement .)
    OR              reduce using rule 22 (equality_statement -> relational_statement .)
    WHILE           reduce using rule 22 (equality_statement -> relational_statement .)
    FOR             reduce using rule 22 (equality_statement -> relational_statement .)
    IF              reduce using rule 22 (equality_statement -> relational_statement .)
    INPUT           reduce using rule 22 (equality_statement -> relational_statement .)
    PRINT           reduce using rule 22 (equality_statement -> relational_statement .)
    IDENTIFIER      reduce using rule 22 (equality_statement -> relational_statement .)
    MINUS           reduce using rule 22 (equality_statement -> relational_statement .)
    NOT             reduce using rule 22 (equality_statement -> relational_statement .)
    LPAREN          reduce using rule 22 (equality_statement -> relational_statement .)
    INTEGER         reduce using rule 22 (equality_statement -> relational_statement .)
    FLOAT           reduce using rule 22 (equality_statement -> relational_statement .)
    STRING          reduce using rule 22 (equality_statement -> relational_statement .)
    TRUE            reduce using rule 22 (equality_statement -> relational_statement .)
    FALSE           reduce using rule 22 (equality_statement -> relational_statement .)
    LBRACKET        reduce using rule 22 (equality_statement -> relational_statement .)
    $end            reduce using rule 22 (equality_statement -> relational_statement .)
    ENDWHILE        reduce using rule 22 (equality_statement -> relational_statement .)
    ELSE            reduce using rule 22 (equality_statement -> relational_statement .)
    ENDIF           reduce using rule 22 (equality_statement -> relational_statement .)
    ENDFOR          reduce using rule 22 (equality_statement -> relational_statement .)
    COLON           reduce using rule 22 (equality_statement -> relational_statement .)
    COMMA           reduce using rule 22 (equality_statement -> relational_statement .)
    RPAREN          reduce using rule 22 (equality_statement -> relational_statement .)
    LT              shift and go to state 53
    GT              shift and go to state 54
    LTEQ            shift and go to state 55
    GTEQ            shift and go to state 56


state 25

    (25) relational_statement -> add_statement .
    (31) add_statement -> add_statement . PLUS multiply_statement
    (32) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 25 (relational_statement -> add_statement .)
    GT              reduce using rule 25 (relational_statement -> add_statement .)
    LTEQ            reduce using rule 25 (relational_statement -> add_statement .)
    GTEQ            reduce using rule 25 (relational_statement -> add_statement .)
    EQ              reduce using rule 25 (relational_statement -> add_statement .)
    NEQ             reduce using rule 25 (relational_statement -> add_statement .)
    AND             reduce using rule 25 (relational_statement -> add_statement .)
    OR              reduce using rule 25 (relational_statement -> add_statement .)
    WHILE           reduce using rule 25 (relational_statement -> add_statement .)
    FOR             reduce using rule 25 (relational_statement -> add_statement .)
    IF              reduce using rule 25 (relational_statement -> add_statement .)
    INPUT           reduce using rule 25 (relational_statement -> add_statement .)
    PRINT           reduce using rule 25 (relational_statement -> add_statement .)
    IDENTIFIER      reduce using rule 25 (relational_statement -> add_statement .)
    NOT             reduce using rule 25 (relational_statement -> add_statement .)
    LPAREN          reduce using rule 25 (relational_statement -> add_statement .)
    INTEGER         reduce using rule 25 (relational_statement -> add_statement .)
    FLOAT           reduce using rule 25 (relational_statement -> add_statement .)
    STRING          reduce using rule 25 (relational_statement -> add_statement .)
    TRUE            reduce using rule 25 (relational_statement -> add_statement .)
    FALSE           reduce using rule 25 (relational_statement -> add_statement .)
    LBRACKET        reduce using rule 25 (relational_statement -> add_statement .)
    $end            reduce using rule 25 (relational_statement -> add_statement .)
    ENDWHILE        reduce using rule 25 (relational_statement -> add_statement .)
    ELSE            reduce using rule 25 (relational_statement -> add_statement .)
    ENDIF           reduce using rule 25 (relational_statement -> add_statement .)
    ENDFOR          reduce using rule 25 (relational_statement -> add_statement .)
    COLON           reduce using rule 25 (relational_statement -> add_statement .)
    COMMA           reduce using rule 25 (relational_statement -> add_statement .)
    RPAREN          reduce using rule 25 (relational_statement -> add_statement .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58

  ! MINUS           [ reduce using rule 25 (relational_statement -> add_statement .) ]


state 26

    (30) add_statement -> multiply_statement .
    (34) multiply_statement -> multiply_statement . TIMES unary_statement
    (35) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (36) multiply_statement -> multiply_statement . FLRDIV unary_statement
    (37) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 30 (add_statement -> multiply_statement .)
    MINUS           reduce using rule 30 (add_statement -> multiply_statement .)
    LT              reduce using rule 30 (add_statement -> multiply_statement .)
    GT              reduce using rule 30 (add_statement -> multiply_statement .)
    LTEQ            reduce using rule 30 (add_statement -> multiply_statement .)
    GTEQ            reduce using rule 30 (add_statement -> multiply_statement .)
    EQ              reduce using rule 30 (add_statement -> multiply_statement .)
    NEQ             reduce using rule 30 (add_statement -> multiply_statement .)
    AND             reduce using rule 30 (add_statement -> multiply_statement .)
    OR              reduce using rule 30 (add_statement -> multiply_statement .)
    WHILE           reduce using rule 30 (add_statement -> multiply_statement .)
    FOR             reduce using rule 30 (add_statement -> multiply_statement .)
    IF              reduce using rule 30 (add_statement -> multiply_statement .)
    INPUT           reduce using rule 30 (add_statement -> multiply_statement .)
    PRINT           reduce using rule 30 (add_statement -> multiply_statement .)
    IDENTIFIER      reduce using rule 30 (add_statement -> multiply_statement .)
    NOT             reduce using rule 30 (add_statement -> multiply_statement .)
    LPAREN          reduce using rule 30 (add_statement -> multiply_statement .)
    INTEGER         reduce using rule 30 (add_statement -> multiply_statement .)
    FLOAT           reduce using rule 30 (add_statement -> multiply_statement .)
    STRING          reduce using rule 30 (add_statement -> multiply_statement .)
    TRUE            reduce using rule 30 (add_statement -> multiply_statement .)
    FALSE           reduce using rule 30 (add_statement -> multiply_statement .)
    LBRACKET        reduce using rule 30 (add_statement -> multiply_statement .)
    $end            reduce using rule 30 (add_statement -> multiply_statement .)
    ENDWHILE        reduce using rule 30 (add_statement -> multiply_statement .)
    ELSE            reduce using rule 30 (add_statement -> multiply_statement .)
    ENDIF           reduce using rule 30 (add_statement -> multiply_statement .)
    ENDFOR          reduce using rule 30 (add_statement -> multiply_statement .)
    COLON           reduce using rule 30 (add_statement -> multiply_statement .)
    COMMA           reduce using rule 30 (add_statement -> multiply_statement .)
    RPAREN          reduce using rule 30 (add_statement -> multiply_statement .)
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    FLRDIV          shift and go to state 61
    MOD             shift and go to state 62


state 27

    (39) unary_statement -> MINUS . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    unary_statement                shift and go to state 63
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 28

    (33) multiply_statement -> unary_statement .

    TIMES           reduce using rule 33 (multiply_statement -> unary_statement .)
    DIVIDE          reduce using rule 33 (multiply_statement -> unary_statement .)
    FLRDIV          reduce using rule 33 (multiply_statement -> unary_statement .)
    MOD             reduce using rule 33 (multiply_statement -> unary_statement .)
    PLUS            reduce using rule 33 (multiply_statement -> unary_statement .)
    MINUS           reduce using rule 33 (multiply_statement -> unary_statement .)
    LT              reduce using rule 33 (multiply_statement -> unary_statement .)
    GT              reduce using rule 33 (multiply_statement -> unary_statement .)
    LTEQ            reduce using rule 33 (multiply_statement -> unary_statement .)
    GTEQ            reduce using rule 33 (multiply_statement -> unary_statement .)
    EQ              reduce using rule 33 (multiply_statement -> unary_statement .)
    NEQ             reduce using rule 33 (multiply_statement -> unary_statement .)
    AND             reduce using rule 33 (multiply_statement -> unary_statement .)
    OR              reduce using rule 33 (multiply_statement -> unary_statement .)
    WHILE           reduce using rule 33 (multiply_statement -> unary_statement .)
    FOR             reduce using rule 33 (multiply_statement -> unary_statement .)
    IF              reduce using rule 33 (multiply_statement -> unary_statement .)
    INPUT           reduce using rule 33 (multiply_statement -> unary_statement .)
    PRINT           reduce using rule 33 (multiply_statement -> unary_statement .)
    IDENTIFIER      reduce using rule 33 (multiply_statement -> unary_statement .)
    NOT             reduce using rule 33 (multiply_statement -> unary_statement .)
    LPAREN          reduce using rule 33 (multiply_statement -> unary_statement .)
    INTEGER         reduce using rule 33 (multiply_statement -> unary_statement .)
    FLOAT           reduce using rule 33 (multiply_statement -> unary_statement .)
    STRING          reduce using rule 33 (multiply_statement -> unary_statement .)
    TRUE            reduce using rule 33 (multiply_statement -> unary_statement .)
    FALSE           reduce using rule 33 (multiply_statement -> unary_statement .)
    LBRACKET        reduce using rule 33 (multiply_statement -> unary_statement .)
    $end            reduce using rule 33 (multiply_statement -> unary_statement .)
    ENDWHILE        reduce using rule 33 (multiply_statement -> unary_statement .)
    ELSE            reduce using rule 33 (multiply_statement -> unary_statement .)
    ENDIF           reduce using rule 33 (multiply_statement -> unary_statement .)
    ENDFOR          reduce using rule 33 (multiply_statement -> unary_statement .)
    COLON           reduce using rule 33 (multiply_statement -> unary_statement .)
    COMMA           reduce using rule 33 (multiply_statement -> unary_statement .)
    RPAREN          reduce using rule 33 (multiply_statement -> unary_statement .)


state 29

    (38) unary_statement -> exponent .

    TIMES           reduce using rule 38 (unary_statement -> exponent .)
    DIVIDE          reduce using rule 38 (unary_statement -> exponent .)
    FLRDIV          reduce using rule 38 (unary_statement -> exponent .)
    MOD             reduce using rule 38 (unary_statement -> exponent .)
    PLUS            reduce using rule 38 (unary_statement -> exponent .)
    MINUS           reduce using rule 38 (unary_statement -> exponent .)
    LT              reduce using rule 38 (unary_statement -> exponent .)
    GT              reduce using rule 38 (unary_statement -> exponent .)
    LTEQ            reduce using rule 38 (unary_statement -> exponent .)
    GTEQ            reduce using rule 38 (unary_statement -> exponent .)
    EQ              reduce using rule 38 (unary_statement -> exponent .)
    NEQ             reduce using rule 38 (unary_statement -> exponent .)
    AND             reduce using rule 38 (unary_statement -> exponent .)
    OR              reduce using rule 38 (unary_statement -> exponent .)
    WHILE           reduce using rule 38 (unary_statement -> exponent .)
    FOR             reduce using rule 38 (unary_statement -> exponent .)
    IF              reduce using rule 38 (unary_statement -> exponent .)
    INPUT           reduce using rule 38 (unary_statement -> exponent .)
    PRINT           reduce using rule 38 (unary_statement -> exponent .)
    IDENTIFIER      reduce using rule 38 (unary_statement -> exponent .)
    NOT             reduce using rule 38 (unary_statement -> exponent .)
    LPAREN          reduce using rule 38 (unary_statement -> exponent .)
    INTEGER         reduce using rule 38 (unary_statement -> exponent .)
    FLOAT           reduce using rule 38 (unary_statement -> exponent .)
    STRING          reduce using rule 38 (unary_statement -> exponent .)
    TRUE            reduce using rule 38 (unary_statement -> exponent .)
    FALSE           reduce using rule 38 (unary_statement -> exponent .)
    LBRACKET        reduce using rule 38 (unary_statement -> exponent .)
    $end            reduce using rule 38 (unary_statement -> exponent .)
    ENDWHILE        reduce using rule 38 (unary_statement -> exponent .)
    ELSE            reduce using rule 38 (unary_statement -> exponent .)
    ENDIF           reduce using rule 38 (unary_statement -> exponent .)
    ENDFOR          reduce using rule 38 (unary_statement -> exponent .)
    COLON           reduce using rule 38 (unary_statement -> exponent .)
    COMMA           reduce using rule 38 (unary_statement -> exponent .)
    RPAREN          reduce using rule 38 (unary_statement -> exponent .)


state 30

    (40) unary_statement -> NOT . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    unary_statement                shift and go to state 64
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 31

    (44) term -> atom .

    POWER           reduce using rule 44 (term -> atom .)
    TIMES           reduce using rule 44 (term -> atom .)
    DIVIDE          reduce using rule 44 (term -> atom .)
    FLRDIV          reduce using rule 44 (term -> atom .)
    MOD             reduce using rule 44 (term -> atom .)
    PLUS            reduce using rule 44 (term -> atom .)
    MINUS           reduce using rule 44 (term -> atom .)
    LT              reduce using rule 44 (term -> atom .)
    GT              reduce using rule 44 (term -> atom .)
    LTEQ            reduce using rule 44 (term -> atom .)
    GTEQ            reduce using rule 44 (term -> atom .)
    EQ              reduce using rule 44 (term -> atom .)
    NEQ             reduce using rule 44 (term -> atom .)
    AND             reduce using rule 44 (term -> atom .)
    OR              reduce using rule 44 (term -> atom .)
    WHILE           reduce using rule 44 (term -> atom .)
    FOR             reduce using rule 44 (term -> atom .)
    IF              reduce using rule 44 (term -> atom .)
    INPUT           reduce using rule 44 (term -> atom .)
    PRINT           reduce using rule 44 (term -> atom .)
    IDENTIFIER      reduce using rule 44 (term -> atom .)
    NOT             reduce using rule 44 (term -> atom .)
    LPAREN          reduce using rule 44 (term -> atom .)
    INTEGER         reduce using rule 44 (term -> atom .)
    FLOAT           reduce using rule 44 (term -> atom .)
    STRING          reduce using rule 44 (term -> atom .)
    TRUE            reduce using rule 44 (term -> atom .)
    FALSE           reduce using rule 44 (term -> atom .)
    LBRACKET        reduce using rule 44 (term -> atom .)
    $end            reduce using rule 44 (term -> atom .)
    ENDWHILE        reduce using rule 44 (term -> atom .)
    ELSE            reduce using rule 44 (term -> atom .)
    ENDIF           reduce using rule 44 (term -> atom .)
    ENDFOR          reduce using rule 44 (term -> atom .)
    COLON           reduce using rule 44 (term -> atom .)
    COMMA           reduce using rule 44 (term -> atom .)
    RPAREN          reduce using rule 44 (term -> atom .)


state 32

    (48) atom -> STRING .

    POWER           reduce using rule 48 (atom -> STRING .)
    TIMES           reduce using rule 48 (atom -> STRING .)
    DIVIDE          reduce using rule 48 (atom -> STRING .)
    FLRDIV          reduce using rule 48 (atom -> STRING .)
    MOD             reduce using rule 48 (atom -> STRING .)
    PLUS            reduce using rule 48 (atom -> STRING .)
    MINUS           reduce using rule 48 (atom -> STRING .)
    LT              reduce using rule 48 (atom -> STRING .)
    GT              reduce using rule 48 (atom -> STRING .)
    LTEQ            reduce using rule 48 (atom -> STRING .)
    GTEQ            reduce using rule 48 (atom -> STRING .)
    EQ              reduce using rule 48 (atom -> STRING .)
    NEQ             reduce using rule 48 (atom -> STRING .)
    AND             reduce using rule 48 (atom -> STRING .)
    OR              reduce using rule 48 (atom -> STRING .)
    WHILE           reduce using rule 48 (atom -> STRING .)
    FOR             reduce using rule 48 (atom -> STRING .)
    IF              reduce using rule 48 (atom -> STRING .)
    INPUT           reduce using rule 48 (atom -> STRING .)
    PRINT           reduce using rule 48 (atom -> STRING .)
    IDENTIFIER      reduce using rule 48 (atom -> STRING .)
    NOT             reduce using rule 48 (atom -> STRING .)
    LPAREN          reduce using rule 48 (atom -> STRING .)
    INTEGER         reduce using rule 48 (atom -> STRING .)
    FLOAT           reduce using rule 48 (atom -> STRING .)
    STRING          reduce using rule 48 (atom -> STRING .)
    TRUE            reduce using rule 48 (atom -> STRING .)
    FALSE           reduce using rule 48 (atom -> STRING .)
    LBRACKET        reduce using rule 48 (atom -> STRING .)
    $end            reduce using rule 48 (atom -> STRING .)
    ENDWHILE        reduce using rule 48 (atom -> STRING .)
    ELSE            reduce using rule 48 (atom -> STRING .)
    ENDIF           reduce using rule 48 (atom -> STRING .)
    ENDFOR          reduce using rule 48 (atom -> STRING .)
    COLON           reduce using rule 48 (atom -> STRING .)
    COMMA           reduce using rule 48 (atom -> STRING .)
    RPAREN          reduce using rule 48 (atom -> STRING .)


state 33

    (49) atom -> TRUE .

    POWER           reduce using rule 49 (atom -> TRUE .)
    TIMES           reduce using rule 49 (atom -> TRUE .)
    DIVIDE          reduce using rule 49 (atom -> TRUE .)
    FLRDIV          reduce using rule 49 (atom -> TRUE .)
    MOD             reduce using rule 49 (atom -> TRUE .)
    PLUS            reduce using rule 49 (atom -> TRUE .)
    MINUS           reduce using rule 49 (atom -> TRUE .)
    LT              reduce using rule 49 (atom -> TRUE .)
    GT              reduce using rule 49 (atom -> TRUE .)
    LTEQ            reduce using rule 49 (atom -> TRUE .)
    GTEQ            reduce using rule 49 (atom -> TRUE .)
    EQ              reduce using rule 49 (atom -> TRUE .)
    NEQ             reduce using rule 49 (atom -> TRUE .)
    AND             reduce using rule 49 (atom -> TRUE .)
    OR              reduce using rule 49 (atom -> TRUE .)
    WHILE           reduce using rule 49 (atom -> TRUE .)
    FOR             reduce using rule 49 (atom -> TRUE .)
    IF              reduce using rule 49 (atom -> TRUE .)
    INPUT           reduce using rule 49 (atom -> TRUE .)
    PRINT           reduce using rule 49 (atom -> TRUE .)
    IDENTIFIER      reduce using rule 49 (atom -> TRUE .)
    NOT             reduce using rule 49 (atom -> TRUE .)
    LPAREN          reduce using rule 49 (atom -> TRUE .)
    INTEGER         reduce using rule 49 (atom -> TRUE .)
    FLOAT           reduce using rule 49 (atom -> TRUE .)
    STRING          reduce using rule 49 (atom -> TRUE .)
    TRUE            reduce using rule 49 (atom -> TRUE .)
    FALSE           reduce using rule 49 (atom -> TRUE .)
    LBRACKET        reduce using rule 49 (atom -> TRUE .)
    $end            reduce using rule 49 (atom -> TRUE .)
    ENDWHILE        reduce using rule 49 (atom -> TRUE .)
    ELSE            reduce using rule 49 (atom -> TRUE .)
    ENDIF           reduce using rule 49 (atom -> TRUE .)
    ENDFOR          reduce using rule 49 (atom -> TRUE .)
    COLON           reduce using rule 49 (atom -> TRUE .)
    COMMA           reduce using rule 49 (atom -> TRUE .)
    RPAREN          reduce using rule 49 (atom -> TRUE .)


state 34

    (50) atom -> FALSE .

    POWER           reduce using rule 50 (atom -> FALSE .)
    TIMES           reduce using rule 50 (atom -> FALSE .)
    DIVIDE          reduce using rule 50 (atom -> FALSE .)
    FLRDIV          reduce using rule 50 (atom -> FALSE .)
    MOD             reduce using rule 50 (atom -> FALSE .)
    PLUS            reduce using rule 50 (atom -> FALSE .)
    MINUS           reduce using rule 50 (atom -> FALSE .)
    LT              reduce using rule 50 (atom -> FALSE .)
    GT              reduce using rule 50 (atom -> FALSE .)
    LTEQ            reduce using rule 50 (atom -> FALSE .)
    GTEQ            reduce using rule 50 (atom -> FALSE .)
    EQ              reduce using rule 50 (atom -> FALSE .)
    NEQ             reduce using rule 50 (atom -> FALSE .)
    AND             reduce using rule 50 (atom -> FALSE .)
    OR              reduce using rule 50 (atom -> FALSE .)
    WHILE           reduce using rule 50 (atom -> FALSE .)
    FOR             reduce using rule 50 (atom -> FALSE .)
    IF              reduce using rule 50 (atom -> FALSE .)
    INPUT           reduce using rule 50 (atom -> FALSE .)
    PRINT           reduce using rule 50 (atom -> FALSE .)
    IDENTIFIER      reduce using rule 50 (atom -> FALSE .)
    NOT             reduce using rule 50 (atom -> FALSE .)
    LPAREN          reduce using rule 50 (atom -> FALSE .)
    INTEGER         reduce using rule 50 (atom -> FALSE .)
    FLOAT           reduce using rule 50 (atom -> FALSE .)
    STRING          reduce using rule 50 (atom -> FALSE .)
    TRUE            reduce using rule 50 (atom -> FALSE .)
    FALSE           reduce using rule 50 (atom -> FALSE .)
    LBRACKET        reduce using rule 50 (atom -> FALSE .)
    $end            reduce using rule 50 (atom -> FALSE .)
    ENDWHILE        reduce using rule 50 (atom -> FALSE .)
    ELSE            reduce using rule 50 (atom -> FALSE .)
    ENDIF           reduce using rule 50 (atom -> FALSE .)
    ENDFOR          reduce using rule 50 (atom -> FALSE .)
    COLON           reduce using rule 50 (atom -> FALSE .)
    COMMA           reduce using rule 50 (atom -> FALSE .)
    RPAREN          reduce using rule 50 (atom -> FALSE .)


state 35

    (2) start -> code_entity start .

    $end            reduce using rule 2 (start -> code_entity start .)
    ENDWHILE        reduce using rule 2 (start -> code_entity start .)
    ELSE            reduce using rule 2 (start -> code_entity start .)
    ENDIF           reduce using rule 2 (start -> code_entity start .)
    ENDFOR          reduce using rule 2 (start -> code_entity start .)


state 36

    (9) iterative_statement -> WHILE or_statement . COLON start ENDWHILE
    (19) or_statement -> or_statement . OR and_statement

    COLON           shift and go to state 65
    OR              shift and go to state 38


state 37

    (43) term -> IDENTIFIER .
    (52) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET
    (53) atom -> IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    POWER           reduce using rule 43 (term -> IDENTIFIER .)
    TIMES           reduce using rule 43 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 43 (term -> IDENTIFIER .)
    FLRDIV          reduce using rule 43 (term -> IDENTIFIER .)
    MOD             reduce using rule 43 (term -> IDENTIFIER .)
    PLUS            reduce using rule 43 (term -> IDENTIFIER .)
    MINUS           reduce using rule 43 (term -> IDENTIFIER .)
    LT              reduce using rule 43 (term -> IDENTIFIER .)
    GT              reduce using rule 43 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 43 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 43 (term -> IDENTIFIER .)
    EQ              reduce using rule 43 (term -> IDENTIFIER .)
    NEQ             reduce using rule 43 (term -> IDENTIFIER .)
    AND             reduce using rule 43 (term -> IDENTIFIER .)
    COLON           reduce using rule 43 (term -> IDENTIFIER .)
    OR              reduce using rule 43 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 43 (term -> IDENTIFIER .)
    WHILE           reduce using rule 43 (term -> IDENTIFIER .)
    FOR             reduce using rule 43 (term -> IDENTIFIER .)
    IF              reduce using rule 43 (term -> IDENTIFIER .)
    INPUT           reduce using rule 43 (term -> IDENTIFIER .)
    PRINT           reduce using rule 43 (term -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 43 (term -> IDENTIFIER .)
    NOT             reduce using rule 43 (term -> IDENTIFIER .)
    LPAREN          reduce using rule 43 (term -> IDENTIFIER .)
    INTEGER         reduce using rule 43 (term -> IDENTIFIER .)
    FLOAT           reduce using rule 43 (term -> IDENTIFIER .)
    STRING          reduce using rule 43 (term -> IDENTIFIER .)
    TRUE            reduce using rule 43 (term -> IDENTIFIER .)
    FALSE           reduce using rule 43 (term -> IDENTIFIER .)
    $end            reduce using rule 43 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 43 (term -> IDENTIFIER .)
    ELSE            reduce using rule 43 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 43 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 43 (term -> IDENTIFIER .)
    COMMA           reduce using rule 43 (term -> IDENTIFIER .)
    LBRACKET        shift and go to state 66

  ! LBRACKET        [ reduce using rule 43 (term -> IDENTIFIER .) ]


state 38

    (19) or_statement -> or_statement OR . and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    and_statement                  shift and go to state 67
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 39

    (10) iterative_statement -> FOR assignment_statement . COMMA or_statement COMMA assignment_statement COLON start ENDFOR

    COMMA           shift and go to state 68


state 40

    (15) assignment_statement -> IDENTIFIER . EQUALS or_statement
    (16) assignment_statement -> IDENTIFIER . LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> IDENTIFIER . LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (43) term -> IDENTIFIER .
    (52) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET
    (53) atom -> IDENTIFIER . LBRACKET IDENTIFIER RBRACKET

    EQUALS          shift and go to state 45
    LBRACKET        shift and go to state 46
    POWER           reduce using rule 43 (term -> IDENTIFIER .)
    TIMES           reduce using rule 43 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 43 (term -> IDENTIFIER .)
    FLRDIV          reduce using rule 43 (term -> IDENTIFIER .)
    MOD             reduce using rule 43 (term -> IDENTIFIER .)
    PLUS            reduce using rule 43 (term -> IDENTIFIER .)
    MINUS           reduce using rule 43 (term -> IDENTIFIER .)
    LT              reduce using rule 43 (term -> IDENTIFIER .)
    GT              reduce using rule 43 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 43 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 43 (term -> IDENTIFIER .)
    EQ              reduce using rule 43 (term -> IDENTIFIER .)
    NEQ             reduce using rule 43 (term -> IDENTIFIER .)
    AND             reduce using rule 43 (term -> IDENTIFIER .)
    OR              reduce using rule 43 (term -> IDENTIFIER .)
    COMMA           reduce using rule 43 (term -> IDENTIFIER .)
    COLON           reduce using rule 43 (term -> IDENTIFIER .)


state 41

    (11) conditional_statement -> IF or_statement . COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> IF or_statement . COLON start ENDIF
    (19) or_statement -> or_statement . OR and_statement

    COLON           shift and go to state 69
    OR              shift and go to state 38


state 42

    (57) input_function -> INPUT LPAREN . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 70


state 43

    (45) term -> LPAREN or_statement . RPAREN
    (19) or_statement -> or_statement . OR and_statement

    RPAREN          shift and go to state 71
    OR              shift and go to state 38


state 44

    (59) array_append -> IDENTIFIER PERIOD . APPEND LPAREN INTEGER RPAREN
    (60) array_append -> IDENTIFIER PERIOD . APPEND LPAREN FLOAT RPAREN
    (61) array_append -> IDENTIFIER PERIOD . APPEND LPAREN IDENTIFIER RPAREN

    APPEND          shift and go to state 72


state 45

    (15) assignment_statement -> IDENTIFIER EQUALS . or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 73
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 46

    (16) assignment_statement -> IDENTIFIER LBRACKET . INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> IDENTIFIER LBRACKET . IDENTIFIER RBRACKET EQUALS or_statement
    (52) atom -> IDENTIFIER LBRACKET . INTEGER RBRACKET
    (53) atom -> IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    INTEGER         shift and go to state 75
    IDENTIFIER      shift and go to state 74


state 47

    (58) output_function -> PRINT LPAREN . term RPAREN
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    term                           shift and go to state 76
    atom                           shift and go to state 31

state 48

    (42) exponent -> term POWER . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    term                           shift and go to state 18
    unary_statement                shift and go to state 77
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 49

    (51) atom -> LBRACKET elements . RBRACKET
    (54) elements -> elements . INTEGER
    (55) elements -> elements . FLOAT

    RBRACKET        shift and go to state 78
    INTEGER         shift and go to state 79
    FLOAT           shift and go to state 80


state 50

    (21) and_statement -> and_statement AND . equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    equality_statement             shift and go to state 81
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 51

    (23) equality_statement -> equality_statement EQ . relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    relational_statement           shift and go to state 82
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 52

    (24) equality_statement -> equality_statement NEQ . relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    relational_statement           shift and go to state 83
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 53

    (26) relational_statement -> relational_statement LT . add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    add_statement                  shift and go to state 84
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 54

    (27) relational_statement -> relational_statement GT . add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    add_statement                  shift and go to state 85
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 55

    (28) relational_statement -> relational_statement LTEQ . add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    add_statement                  shift and go to state 86
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 56

    (29) relational_statement -> relational_statement GTEQ . add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    add_statement                  shift and go to state 87
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 57

    (31) add_statement -> add_statement PLUS . multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    multiply_statement             shift and go to state 88
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 58

    (32) add_statement -> add_statement MINUS . multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    multiply_statement             shift and go to state 89
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 59

    (34) multiply_statement -> multiply_statement TIMES . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    unary_statement                shift and go to state 90
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 60

    (35) multiply_statement -> multiply_statement DIVIDE . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    unary_statement                shift and go to state 91
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 61

    (36) multiply_statement -> multiply_statement FLRDIV . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    unary_statement                shift and go to state 92
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 62

    (37) multiply_statement -> multiply_statement MOD . unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    unary_statement                shift and go to state 93
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 63

    (39) unary_statement -> MINUS unary_statement .

    TIMES           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    DIVIDE          reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    FLRDIV          reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    MOD             reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    PLUS            reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    MINUS           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    LT              reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    GT              reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    LTEQ            reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    GTEQ            reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    EQ              reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    NEQ             reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    AND             reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    OR              reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    WHILE           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    FOR             reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    IF              reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    INPUT           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    PRINT           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    IDENTIFIER      reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    NOT             reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    LPAREN          reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    INTEGER         reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    FLOAT           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    STRING          reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    TRUE            reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    FALSE           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    LBRACKET        reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    $end            reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    ENDWHILE        reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    ELSE            reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    ENDIF           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    ENDFOR          reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    COLON           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    COMMA           reduce using rule 39 (unary_statement -> MINUS unary_statement .)
    RPAREN          reduce using rule 39 (unary_statement -> MINUS unary_statement .)


state 64

    (40) unary_statement -> NOT unary_statement .

    TIMES           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    DIVIDE          reduce using rule 40 (unary_statement -> NOT unary_statement .)
    FLRDIV          reduce using rule 40 (unary_statement -> NOT unary_statement .)
    MOD             reduce using rule 40 (unary_statement -> NOT unary_statement .)
    PLUS            reduce using rule 40 (unary_statement -> NOT unary_statement .)
    MINUS           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    LT              reduce using rule 40 (unary_statement -> NOT unary_statement .)
    GT              reduce using rule 40 (unary_statement -> NOT unary_statement .)
    LTEQ            reduce using rule 40 (unary_statement -> NOT unary_statement .)
    GTEQ            reduce using rule 40 (unary_statement -> NOT unary_statement .)
    EQ              reduce using rule 40 (unary_statement -> NOT unary_statement .)
    NEQ             reduce using rule 40 (unary_statement -> NOT unary_statement .)
    AND             reduce using rule 40 (unary_statement -> NOT unary_statement .)
    OR              reduce using rule 40 (unary_statement -> NOT unary_statement .)
    WHILE           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    FOR             reduce using rule 40 (unary_statement -> NOT unary_statement .)
    IF              reduce using rule 40 (unary_statement -> NOT unary_statement .)
    INPUT           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    PRINT           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    IDENTIFIER      reduce using rule 40 (unary_statement -> NOT unary_statement .)
    NOT             reduce using rule 40 (unary_statement -> NOT unary_statement .)
    LPAREN          reduce using rule 40 (unary_statement -> NOT unary_statement .)
    INTEGER         reduce using rule 40 (unary_statement -> NOT unary_statement .)
    FLOAT           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    STRING          reduce using rule 40 (unary_statement -> NOT unary_statement .)
    TRUE            reduce using rule 40 (unary_statement -> NOT unary_statement .)
    FALSE           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    LBRACKET        reduce using rule 40 (unary_statement -> NOT unary_statement .)
    $end            reduce using rule 40 (unary_statement -> NOT unary_statement .)
    ENDWHILE        reduce using rule 40 (unary_statement -> NOT unary_statement .)
    ELSE            reduce using rule 40 (unary_statement -> NOT unary_statement .)
    ENDIF           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    ENDFOR          reduce using rule 40 (unary_statement -> NOT unary_statement .)
    COLON           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    COMMA           reduce using rule 40 (unary_statement -> NOT unary_statement .)
    RPAREN          reduce using rule 40 (unary_statement -> NOT unary_statement .)


state 65

    (9) iterative_statement -> WHILE or_statement COLON . start ENDWHILE
    (1) start -> .
    (2) start -> . code_entity start
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) code_entity -> . array_append
    (9) iterative_statement -> . WHILE or_statement COLON start ENDWHILE
    (10) iterative_statement -> . FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (11) conditional_statement -> . IF or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> . IF or_statement COLON start ENDIF
    (13) expression -> . assignment_statement
    (57) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (58) output_function -> . PRINT LPAREN term RPAREN
    (59) array_append -> . IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> . IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> . IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    ENDWHILE        reduce using rule 1 (start -> .)
    WHILE           shift and go to state 9
    FOR             shift and go to state 11
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    PRINT           shift and go to state 17
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 10
    start                          shift and go to state 94
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    array_append                   shift and go to state 8
    assignment_statement           shift and go to state 12
    term                           shift and go to state 18
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 66

    (52) atom -> IDENTIFIER LBRACKET . INTEGER RBRACKET
    (53) atom -> IDENTIFIER LBRACKET . IDENTIFIER RBRACKET

    INTEGER         shift and go to state 96
    IDENTIFIER      shift and go to state 95


state 67

    (19) or_statement -> or_statement OR and_statement .
    (21) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    WHILE           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    FOR             reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    IF              reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    INPUT           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    PRINT           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    IDENTIFIER      reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    MINUS           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    NOT             reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    LPAREN          reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    INTEGER         reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    FLOAT           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    STRING          reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    TRUE            reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    FALSE           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    LBRACKET        reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    $end            reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    ENDWHILE        reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    ELSE            reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    ENDIF           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    ENDFOR          reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    COLON           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    COMMA           reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    RPAREN          reduce using rule 19 (or_statement -> or_statement OR and_statement .)
    AND             shift and go to state 50


state 68

    (10) iterative_statement -> FOR assignment_statement COMMA . or_statement COMMA assignment_statement COLON start ENDFOR
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 97
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 69

    (11) conditional_statement -> IF or_statement COLON . start ELSE COLON start ENDIF
    (12) conditional_statement -> IF or_statement COLON . start ENDIF
    (1) start -> .
    (2) start -> . code_entity start
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) code_entity -> . array_append
    (9) iterative_statement -> . WHILE or_statement COLON start ENDWHILE
    (10) iterative_statement -> . FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (11) conditional_statement -> . IF or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> . IF or_statement COLON start ENDIF
    (13) expression -> . assignment_statement
    (57) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (58) output_function -> . PRINT LPAREN term RPAREN
    (59) array_append -> . IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> . IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> . IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    ELSE            reduce using rule 1 (start -> .)
    ENDIF           reduce using rule 1 (start -> .)
    WHILE           shift and go to state 9
    FOR             shift and go to state 11
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    PRINT           shift and go to state 17
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 10
    start                          shift and go to state 98
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    array_append                   shift and go to state 8
    assignment_statement           shift and go to state 12
    term                           shift and go to state 18
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 70

    (57) input_function -> INPUT LPAREN IDENTIFIER . RPAREN

    RPAREN          shift and go to state 99


state 71

    (45) term -> LPAREN or_statement RPAREN .

    POWER           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    TIMES           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    DIVIDE          reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    FLRDIV          reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    MOD             reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    PLUS            reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    MINUS           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    LT              reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    GT              reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    LTEQ            reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    GTEQ            reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    EQ              reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    NEQ             reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    AND             reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    OR              reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    WHILE           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    FOR             reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    IF              reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    INPUT           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    PRINT           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    IDENTIFIER      reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    NOT             reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    LPAREN          reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    INTEGER         reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    FLOAT           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    STRING          reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    TRUE            reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    FALSE           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    LBRACKET        reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    $end            reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    ENDWHILE        reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    ELSE            reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    ENDIF           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    ENDFOR          reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    COLON           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    COMMA           reduce using rule 45 (term -> LPAREN or_statement RPAREN .)
    RPAREN          reduce using rule 45 (term -> LPAREN or_statement RPAREN .)


state 72

    (59) array_append -> IDENTIFIER PERIOD APPEND . LPAREN INTEGER RPAREN
    (60) array_append -> IDENTIFIER PERIOD APPEND . LPAREN FLOAT RPAREN
    (61) array_append -> IDENTIFIER PERIOD APPEND . LPAREN IDENTIFIER RPAREN

    LPAREN          shift and go to state 100


state 73

    (15) assignment_statement -> IDENTIFIER EQUALS or_statement .
    (19) or_statement -> or_statement . OR and_statement

    WHILE           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    FOR             reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    IF              reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    INPUT           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    PRINT           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    IDENTIFIER      reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    MINUS           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    NOT             reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    LPAREN          reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    INTEGER         reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    FLOAT           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    STRING          reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    TRUE            reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    FALSE           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    LBRACKET        reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    $end            reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDWHILE        reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ELSE            reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDIF           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDFOR          reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COMMA           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COLON           reduce using rule 15 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    OR              shift and go to state 38


state 74

    (17) assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER . RBRACKET EQUALS or_statement
    (53) atom -> IDENTIFIER LBRACKET IDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 101


state 75

    (16) assignment_statement -> IDENTIFIER LBRACKET INTEGER . RBRACKET EQUALS or_statement
    (52) atom -> IDENTIFIER LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 102


state 76

    (58) output_function -> PRINT LPAREN term . RPAREN

    RPAREN          shift and go to state 103


state 77

    (42) exponent -> term POWER unary_statement .

    TIMES           reduce using rule 42 (exponent -> term POWER unary_statement .)
    DIVIDE          reduce using rule 42 (exponent -> term POWER unary_statement .)
    FLRDIV          reduce using rule 42 (exponent -> term POWER unary_statement .)
    MOD             reduce using rule 42 (exponent -> term POWER unary_statement .)
    PLUS            reduce using rule 42 (exponent -> term POWER unary_statement .)
    MINUS           reduce using rule 42 (exponent -> term POWER unary_statement .)
    LT              reduce using rule 42 (exponent -> term POWER unary_statement .)
    GT              reduce using rule 42 (exponent -> term POWER unary_statement .)
    LTEQ            reduce using rule 42 (exponent -> term POWER unary_statement .)
    GTEQ            reduce using rule 42 (exponent -> term POWER unary_statement .)
    EQ              reduce using rule 42 (exponent -> term POWER unary_statement .)
    NEQ             reduce using rule 42 (exponent -> term POWER unary_statement .)
    AND             reduce using rule 42 (exponent -> term POWER unary_statement .)
    OR              reduce using rule 42 (exponent -> term POWER unary_statement .)
    WHILE           reduce using rule 42 (exponent -> term POWER unary_statement .)
    FOR             reduce using rule 42 (exponent -> term POWER unary_statement .)
    IF              reduce using rule 42 (exponent -> term POWER unary_statement .)
    INPUT           reduce using rule 42 (exponent -> term POWER unary_statement .)
    PRINT           reduce using rule 42 (exponent -> term POWER unary_statement .)
    IDENTIFIER      reduce using rule 42 (exponent -> term POWER unary_statement .)
    NOT             reduce using rule 42 (exponent -> term POWER unary_statement .)
    LPAREN          reduce using rule 42 (exponent -> term POWER unary_statement .)
    INTEGER         reduce using rule 42 (exponent -> term POWER unary_statement .)
    FLOAT           reduce using rule 42 (exponent -> term POWER unary_statement .)
    STRING          reduce using rule 42 (exponent -> term POWER unary_statement .)
    TRUE            reduce using rule 42 (exponent -> term POWER unary_statement .)
    FALSE           reduce using rule 42 (exponent -> term POWER unary_statement .)
    LBRACKET        reduce using rule 42 (exponent -> term POWER unary_statement .)
    $end            reduce using rule 42 (exponent -> term POWER unary_statement .)
    ENDWHILE        reduce using rule 42 (exponent -> term POWER unary_statement .)
    ELSE            reduce using rule 42 (exponent -> term POWER unary_statement .)
    ENDIF           reduce using rule 42 (exponent -> term POWER unary_statement .)
    ENDFOR          reduce using rule 42 (exponent -> term POWER unary_statement .)
    COLON           reduce using rule 42 (exponent -> term POWER unary_statement .)
    COMMA           reduce using rule 42 (exponent -> term POWER unary_statement .)
    RPAREN          reduce using rule 42 (exponent -> term POWER unary_statement .)


state 78

    (51) atom -> LBRACKET elements RBRACKET .

    POWER           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    TIMES           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    DIVIDE          reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    FLRDIV          reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    MOD             reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    PLUS            reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    MINUS           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    LT              reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    GT              reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    LTEQ            reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    GTEQ            reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    EQ              reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    NEQ             reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    AND             reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    OR              reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    WHILE           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    FOR             reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    IF              reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    INPUT           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    PRINT           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    IDENTIFIER      reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    NOT             reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    LPAREN          reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    INTEGER         reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    FLOAT           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    STRING          reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    TRUE            reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    FALSE           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    LBRACKET        reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    $end            reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    ENDWHILE        reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    ELSE            reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    ENDIF           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    ENDFOR          reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    COLON           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    COMMA           reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)
    RPAREN          reduce using rule 51 (atom -> LBRACKET elements RBRACKET .)


state 79

    (54) elements -> elements INTEGER .

    RBRACKET        reduce using rule 54 (elements -> elements INTEGER .)
    INTEGER         reduce using rule 54 (elements -> elements INTEGER .)
    FLOAT           reduce using rule 54 (elements -> elements INTEGER .)


state 80

    (55) elements -> elements FLOAT .

    RBRACKET        reduce using rule 55 (elements -> elements FLOAT .)
    INTEGER         reduce using rule 55 (elements -> elements FLOAT .)
    FLOAT           reduce using rule 55 (elements -> elements FLOAT .)


state 81

    (21) and_statement -> and_statement AND equality_statement .
    (23) equality_statement -> equality_statement . EQ relational_statement
    (24) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    OR              reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    WHILE           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    FOR             reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    IF              reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    INPUT           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    PRINT           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    IDENTIFIER      reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    MINUS           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    NOT             reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    LPAREN          reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    INTEGER         reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    FLOAT           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    STRING          reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    TRUE            reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    FALSE           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    LBRACKET        reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    $end            reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    ENDWHILE        reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    ELSE            reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    ENDIF           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    ENDFOR          reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    COLON           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    COMMA           reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    RPAREN          reduce using rule 21 (and_statement -> and_statement AND equality_statement .)
    EQ              shift and go to state 51
    NEQ             shift and go to state 52


state 82

    (23) equality_statement -> equality_statement EQ relational_statement .
    (26) relational_statement -> relational_statement . LT add_statement
    (27) relational_statement -> relational_statement . GT add_statement
    (28) relational_statement -> relational_statement . LTEQ add_statement
    (29) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    NEQ             reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    AND             reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    OR              reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    WHILE           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    FOR             reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    IF              reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    INPUT           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    PRINT           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    IDENTIFIER      reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    MINUS           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    NOT             reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    LPAREN          reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    INTEGER         reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    FLOAT           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    STRING          reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    TRUE            reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    FALSE           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    LBRACKET        reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    $end            reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    ENDWHILE        reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    ELSE            reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    ENDIF           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    ENDFOR          reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    COLON           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    COMMA           reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    RPAREN          reduce using rule 23 (equality_statement -> equality_statement EQ relational_statement .)
    LT              shift and go to state 53
    GT              shift and go to state 54
    LTEQ            shift and go to state 55
    GTEQ            shift and go to state 56


state 83

    (24) equality_statement -> equality_statement NEQ relational_statement .
    (26) relational_statement -> relational_statement . LT add_statement
    (27) relational_statement -> relational_statement . GT add_statement
    (28) relational_statement -> relational_statement . LTEQ add_statement
    (29) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    NEQ             reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    AND             reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    OR              reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    WHILE           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    FOR             reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    IF              reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    INPUT           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    PRINT           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    IDENTIFIER      reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    MINUS           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    NOT             reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    LPAREN          reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    INTEGER         reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    FLOAT           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    STRING          reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    TRUE            reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    FALSE           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    LBRACKET        reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    $end            reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDWHILE        reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    ELSE            reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDIF           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDFOR          reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    COLON           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    COMMA           reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    RPAREN          reduce using rule 24 (equality_statement -> equality_statement NEQ relational_statement .)
    LT              shift and go to state 53
    GT              shift and go to state 54
    LTEQ            shift and go to state 55
    GTEQ            shift and go to state 56


state 84

    (26) relational_statement -> relational_statement LT add_statement .
    (31) add_statement -> add_statement . PLUS multiply_statement
    (32) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    GT              reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    LTEQ            reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    GTEQ            reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    EQ              reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    NEQ             reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    AND             reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    OR              reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    WHILE           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    FOR             reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    IF              reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    INPUT           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    PRINT           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    IDENTIFIER      reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    NOT             reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    LPAREN          reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    INTEGER         reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    FLOAT           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    STRING          reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    TRUE            reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    FALSE           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    LBRACKET        reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    $end            reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    ENDWHILE        reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    ELSE            reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    ENDIF           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    ENDFOR          reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    COLON           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    COMMA           reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    RPAREN          reduce using rule 26 (relational_statement -> relational_statement LT add_statement .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58

  ! MINUS           [ reduce using rule 26 (relational_statement -> relational_statement LT add_statement .) ]


state 85

    (27) relational_statement -> relational_statement GT add_statement .
    (31) add_statement -> add_statement . PLUS multiply_statement
    (32) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    GT              reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    LTEQ            reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    GTEQ            reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    EQ              reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    NEQ             reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    AND             reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    OR              reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    WHILE           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    FOR             reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    IF              reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    INPUT           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    PRINT           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    IDENTIFIER      reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    NOT             reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    LPAREN          reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    INTEGER         reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    FLOAT           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    STRING          reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    TRUE            reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    FALSE           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    LBRACKET        reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    $end            reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    ENDWHILE        reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    ELSE            reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    ENDIF           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    ENDFOR          reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    COLON           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    COMMA           reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    RPAREN          reduce using rule 27 (relational_statement -> relational_statement GT add_statement .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58

  ! MINUS           [ reduce using rule 27 (relational_statement -> relational_statement GT add_statement .) ]


state 86

    (28) relational_statement -> relational_statement LTEQ add_statement .
    (31) add_statement -> add_statement . PLUS multiply_statement
    (32) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    GT              reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    LTEQ            reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    GTEQ            reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    EQ              reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    NEQ             reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    AND             reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    OR              reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    WHILE           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    FOR             reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    IF              reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    INPUT           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    PRINT           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    IDENTIFIER      reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    NOT             reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    LPAREN          reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    INTEGER         reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    FLOAT           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    STRING          reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    TRUE            reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    FALSE           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    LBRACKET        reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    $end            reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDWHILE        reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    ELSE            reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDIF           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDFOR          reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    COLON           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    COMMA           reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    RPAREN          reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58

  ! MINUS           [ reduce using rule 28 (relational_statement -> relational_statement LTEQ add_statement .) ]


state 87

    (29) relational_statement -> relational_statement GTEQ add_statement .
    (31) add_statement -> add_statement . PLUS multiply_statement
    (32) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    GT              reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    LTEQ            reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    GTEQ            reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    EQ              reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    NEQ             reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    AND             reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    OR              reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    WHILE           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    FOR             reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    IF              reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    INPUT           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    PRINT           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    IDENTIFIER      reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    NOT             reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    LPAREN          reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    INTEGER         reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    FLOAT           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    STRING          reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    TRUE            reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    FALSE           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    LBRACKET        reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    $end            reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDWHILE        reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    ELSE            reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDIF           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDFOR          reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    COLON           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    COMMA           reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    RPAREN          reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .)
    PLUS            shift and go to state 57
    MINUS           shift and go to state 58

  ! MINUS           [ reduce using rule 29 (relational_statement -> relational_statement GTEQ add_statement .) ]


state 88

    (31) add_statement -> add_statement PLUS multiply_statement .
    (34) multiply_statement -> multiply_statement . TIMES unary_statement
    (35) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (36) multiply_statement -> multiply_statement . FLRDIV unary_statement
    (37) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    MINUS           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    LT              reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    GT              reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    LTEQ            reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    GTEQ            reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    EQ              reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    NEQ             reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    AND             reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    OR              reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    WHILE           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    FOR             reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    IF              reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    INPUT           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    PRINT           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    IDENTIFIER      reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    NOT             reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    LPAREN          reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    INTEGER         reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    FLOAT           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    STRING          reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    TRUE            reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    FALSE           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    LBRACKET        reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    $end            reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    ENDWHILE        reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    ELSE            reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    ENDIF           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    ENDFOR          reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    COLON           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    COMMA           reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    RPAREN          reduce using rule 31 (add_statement -> add_statement PLUS multiply_statement .)
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    FLRDIV          shift and go to state 61
    MOD             shift and go to state 62


state 89

    (32) add_statement -> add_statement MINUS multiply_statement .
    (34) multiply_statement -> multiply_statement . TIMES unary_statement
    (35) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (36) multiply_statement -> multiply_statement . FLRDIV unary_statement
    (37) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    MINUS           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    LT              reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    GT              reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    LTEQ            reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    GTEQ            reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    EQ              reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    NEQ             reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    AND             reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    OR              reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    WHILE           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    FOR             reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    IF              reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    INPUT           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    PRINT           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    IDENTIFIER      reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    NOT             reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    LPAREN          reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    INTEGER         reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    FLOAT           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    STRING          reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    TRUE            reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    FALSE           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    LBRACKET        reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    $end            reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    ENDWHILE        reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    ELSE            reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    ENDIF           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    ENDFOR          reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    COLON           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    COMMA           reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    RPAREN          reduce using rule 32 (add_statement -> add_statement MINUS multiply_statement .)
    TIMES           shift and go to state 59
    DIVIDE          shift and go to state 60
    FLRDIV          shift and go to state 61
    MOD             shift and go to state 62


state 90

    (34) multiply_statement -> multiply_statement TIMES unary_statement .

    TIMES           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    DIVIDE          reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FLRDIV          reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MOD             reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    PLUS            reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MINUS           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LT              reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GT              reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LTEQ            reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GTEQ            reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    EQ              reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    NEQ             reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    AND             reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    OR              reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    WHILE           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FOR             reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    IF              reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    INPUT           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    PRINT           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    IDENTIFIER      reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    NOT             reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LPAREN          reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    INTEGER         reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FLOAT           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    STRING          reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    TRUE            reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FALSE           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LBRACKET        reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    $end            reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDWHILE        reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ELSE            reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDIF           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDFOR          reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COLON           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COMMA           reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)
    RPAREN          reduce using rule 34 (multiply_statement -> multiply_statement TIMES unary_statement .)


state 91

    (35) multiply_statement -> multiply_statement DIVIDE unary_statement .

    TIMES           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    DIVIDE          reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FLRDIV          reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MOD             reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    PLUS            reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MINUS           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LT              reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GT              reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LTEQ            reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GTEQ            reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    EQ              reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    NEQ             reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    AND             reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    OR              reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    WHILE           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FOR             reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    IF              reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    INPUT           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    PRINT           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    IDENTIFIER      reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    NOT             reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LPAREN          reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    INTEGER         reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FLOAT           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    STRING          reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    TRUE            reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FALSE           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LBRACKET        reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    $end            reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDWHILE        reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ELSE            reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDIF           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDFOR          reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COLON           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COMMA           reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    RPAREN          reduce using rule 35 (multiply_statement -> multiply_statement DIVIDE unary_statement .)


state 92

    (36) multiply_statement -> multiply_statement FLRDIV unary_statement .

    TIMES           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    DIVIDE          reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    FLRDIV          reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    MOD             reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    PLUS            reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    MINUS           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    LT              reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    GT              reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    LTEQ            reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    GTEQ            reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    EQ              reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    NEQ             reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    AND             reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    OR              reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    WHILE           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    FOR             reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    IF              reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    INPUT           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    PRINT           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    IDENTIFIER      reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    NOT             reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    LPAREN          reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    INTEGER         reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    FLOAT           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    STRING          reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    TRUE            reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    FALSE           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    LBRACKET        reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    $end            reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    ENDWHILE        reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    ELSE            reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    ENDIF           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    ENDFOR          reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    COLON           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    COMMA           reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)
    RPAREN          reduce using rule 36 (multiply_statement -> multiply_statement FLRDIV unary_statement .)


state 93

    (37) multiply_statement -> multiply_statement MOD unary_statement .

    TIMES           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    DIVIDE          reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    FLRDIV          reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    MOD             reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    PLUS            reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    MINUS           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    LT              reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    GT              reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    LTEQ            reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    GTEQ            reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    EQ              reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    NEQ             reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    AND             reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    OR              reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    WHILE           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    FOR             reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    IF              reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    INPUT           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    PRINT           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    IDENTIFIER      reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    NOT             reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    LPAREN          reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    INTEGER         reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    FLOAT           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    STRING          reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    TRUE            reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    FALSE           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    LBRACKET        reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    $end            reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDWHILE        reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    ELSE            reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDIF           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDFOR          reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    COLON           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    COMMA           reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)
    RPAREN          reduce using rule 37 (multiply_statement -> multiply_statement MOD unary_statement .)


state 94

    (9) iterative_statement -> WHILE or_statement COLON start . ENDWHILE

    ENDWHILE        shift and go to state 104


state 95

    (53) atom -> IDENTIFIER LBRACKET IDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 105


state 96

    (52) atom -> IDENTIFIER LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 106


state 97

    (10) iterative_statement -> FOR assignment_statement COMMA or_statement . COMMA assignment_statement COLON start ENDFOR
    (19) or_statement -> or_statement . OR and_statement

    COMMA           shift and go to state 107
    OR              shift and go to state 38


state 98

    (11) conditional_statement -> IF or_statement COLON start . ELSE COLON start ENDIF
    (12) conditional_statement -> IF or_statement COLON start . ENDIF

    ELSE            shift and go to state 108
    ENDIF           shift and go to state 109


state 99

    (57) input_function -> INPUT LPAREN IDENTIFIER RPAREN .

    WHILE           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    FOR             reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    IF              reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    INPUT           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    PRINT           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    IDENTIFIER      reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    MINUS           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    NOT             reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    LPAREN          reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    INTEGER         reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    FLOAT           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    STRING          reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    TRUE            reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    FALSE           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    LBRACKET        reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    $end            reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDWHILE        reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ELSE            reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDIF           reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDFOR          reduce using rule 57 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)


state 100

    (59) array_append -> IDENTIFIER PERIOD APPEND LPAREN . INTEGER RPAREN
    (60) array_append -> IDENTIFIER PERIOD APPEND LPAREN . FLOAT RPAREN
    (61) array_append -> IDENTIFIER PERIOD APPEND LPAREN . IDENTIFIER RPAREN

    INTEGER         shift and go to state 111
    FLOAT           shift and go to state 112
    IDENTIFIER      shift and go to state 110


state 101

    (17) assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET . EQUALS or_statement
    (53) atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .

    EQUALS          shift and go to state 113
    POWER           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    TIMES           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    DIVIDE          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FLRDIV          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    MOD             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    PLUS            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    MINUS           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LT              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    GT              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LTEQ            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    GTEQ            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    EQ              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    NEQ             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    AND             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    OR              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    WHILE           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FOR             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    IF              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    INPUT           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    PRINT           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    IDENTIFIER      reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    NOT             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LPAREN          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    INTEGER         reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FLOAT           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    STRING          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    TRUE            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FALSE           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LBRACKET        reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    $end            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ENDWHILE        reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ELSE            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ENDIF           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ENDFOR          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    COMMA           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    COLON           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)


state 102

    (16) assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET . EQUALS or_statement
    (52) atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .

    EQUALS          shift and go to state 114
    POWER           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TIMES           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    DIVIDE          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FLRDIV          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MOD             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PLUS            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MINUS           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LT              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GT              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LTEQ            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GTEQ            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    EQ              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NEQ             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    AND             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    OR              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    WHILE           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FOR             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    IF              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    INPUT           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PRINT           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    IDENTIFIER      reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NOT             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LPAREN          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    INTEGER         reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FLOAT           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    STRING          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TRUE            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FALSE           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LBRACKET        reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    $end            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDWHILE        reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ELSE            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDIF           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDFOR          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COLON           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)


state 103

    (58) output_function -> PRINT LPAREN term RPAREN .

    WHILE           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    FOR             reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    IF              reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    INPUT           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    PRINT           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    IDENTIFIER      reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    MINUS           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    NOT             reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    LPAREN          reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    INTEGER         reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    FLOAT           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    STRING          reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    TRUE            reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    FALSE           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    LBRACKET        reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    $end            reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    ENDWHILE        reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    ELSE            reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    ENDIF           reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)
    ENDFOR          reduce using rule 58 (output_function -> PRINT LPAREN term RPAREN .)


state 104

    (9) iterative_statement -> WHILE or_statement COLON start ENDWHILE .

    WHILE           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    FOR             reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    IF              reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    INPUT           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    PRINT           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    IDENTIFIER      reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    MINUS           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    NOT             reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    LPAREN          reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    INTEGER         reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    FLOAT           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    STRING          reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    TRUE            reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    FALSE           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    LBRACKET        reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    $end            reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    ENDWHILE        reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    ELSE            reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    ENDIF           reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)
    ENDFOR          reduce using rule 9 (iterative_statement -> WHILE or_statement COLON start ENDWHILE .)


state 105

    (53) atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .

    POWER           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    TIMES           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    DIVIDE          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FLRDIV          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    MOD             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    PLUS            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    MINUS           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LT              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    GT              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LTEQ            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    GTEQ            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    EQ              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    NEQ             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    AND             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    COLON           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    OR              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    RPAREN          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    WHILE           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FOR             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    IF              reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    INPUT           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    PRINT           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    IDENTIFIER      reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    NOT             reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LPAREN          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    INTEGER         reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FLOAT           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    STRING          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    TRUE            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    FALSE           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    LBRACKET        reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    $end            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ENDWHILE        reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ELSE            reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ENDIF           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    ENDFOR          reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)
    COMMA           reduce using rule 53 (atom -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET .)


state 106

    (52) atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .

    POWER           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TIMES           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    DIVIDE          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FLRDIV          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MOD             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PLUS            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MINUS           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LT              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GT              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LTEQ            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GTEQ            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    EQ              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NEQ             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    AND             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COLON           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    OR              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    RPAREN          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    WHILE           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FOR             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    IF              reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    INPUT           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PRINT           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    IDENTIFIER      reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NOT             reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LPAREN          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    INTEGER         reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FLOAT           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    STRING          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TRUE            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FALSE           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LBRACKET        reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    $end            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDWHILE        reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ELSE            reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDIF           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDFOR          reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 52 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)


state 107

    (10) iterative_statement -> FOR assignment_statement COMMA or_statement COMMA . assignment_statement COLON start ENDFOR
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    IDENTIFIER      shift and go to state 40
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    assignment_statement           shift and go to state 115
    or_statement                   shift and go to state 10
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 108

    (11) conditional_statement -> IF or_statement COLON start ELSE . COLON start ENDIF

    COLON           shift and go to state 116


state 109

    (12) conditional_statement -> IF or_statement COLON start ENDIF .

    WHILE           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    FOR             reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    IF              reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    INPUT           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    PRINT           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    IDENTIFIER      reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    MINUS           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    NOT             reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    LPAREN          reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    INTEGER         reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    FLOAT           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    STRING          reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    TRUE            reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    FALSE           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    LBRACKET        reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    $end            reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    ENDWHILE        reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    ELSE            reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    ENDIF           reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)
    ENDFOR          reduce using rule 12 (conditional_statement -> IF or_statement COLON start ENDIF .)


state 110

    (61) array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER . RPAREN

    RPAREN          shift and go to state 117


state 111

    (59) array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER . RPAREN

    RPAREN          shift and go to state 118


state 112

    (60) array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT . RPAREN

    RPAREN          shift and go to state 119


state 113

    (17) assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS . or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 120
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 114

    (16) assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS . or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    IDENTIFIER      shift and go to state 37
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 121
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    term                           shift and go to state 18
    atom                           shift and go to state 31

state 115

    (10) iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement . COLON start ENDFOR

    COLON           shift and go to state 122


state 116

    (11) conditional_statement -> IF or_statement COLON start ELSE COLON . start ENDIF
    (1) start -> .
    (2) start -> . code_entity start
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) code_entity -> . array_append
    (9) iterative_statement -> . WHILE or_statement COLON start ENDWHILE
    (10) iterative_statement -> . FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (11) conditional_statement -> . IF or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> . IF or_statement COLON start ENDIF
    (13) expression -> . assignment_statement
    (57) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (58) output_function -> . PRINT LPAREN term RPAREN
    (59) array_append -> . IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> . IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> . IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    ENDIF           reduce using rule 1 (start -> .)
    WHILE           shift and go to state 9
    FOR             shift and go to state 11
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    PRINT           shift and go to state 17
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    or_statement                   shift and go to state 10
    start                          shift and go to state 123
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    array_append                   shift and go to state 8
    assignment_statement           shift and go to state 12
    term                           shift and go to state 18
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 117

    (61) array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .

    WHILE           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    FOR             reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    IF              reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    INPUT           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    PRINT           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    IDENTIFIER      reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    MINUS           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    NOT             reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    LPAREN          reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    INTEGER         reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    FLOAT           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    STRING          reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    TRUE            reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    FALSE           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    LBRACKET        reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    $end            reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    ENDWHILE        reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    ELSE            reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    ENDIF           reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)
    ENDFOR          reduce using rule 61 (array_append -> IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN .)


state 118

    (59) array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .

    WHILE           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    FOR             reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    IF              reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    INPUT           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    PRINT           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    IDENTIFIER      reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    MINUS           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    NOT             reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    LPAREN          reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    INTEGER         reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    FLOAT           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    STRING          reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    TRUE            reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    FALSE           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    LBRACKET        reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    $end            reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    ENDWHILE        reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    ELSE            reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    ENDIF           reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)
    ENDFOR          reduce using rule 59 (array_append -> IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN .)


state 119

    (60) array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .

    WHILE           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    FOR             reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    IF              reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    INPUT           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    PRINT           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    IDENTIFIER      reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    MINUS           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    NOT             reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    LPAREN          reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    INTEGER         reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    FLOAT           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    STRING          reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    TRUE            reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    FALSE           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    LBRACKET        reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    $end            reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    ENDWHILE        reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    ELSE            reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    ENDIF           reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)
    ENDFOR          reduce using rule 60 (array_append -> IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN .)


state 120

    (17) assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .
    (19) or_statement -> or_statement . OR and_statement

    WHILE           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    FOR             reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    IF              reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    INPUT           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    PRINT           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    IDENTIFIER      reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    MINUS           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    NOT             reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    LPAREN          reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    INTEGER         reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    FLOAT           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    STRING          reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    TRUE            reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    FALSE           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    LBRACKET        reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    $end            reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    ENDWHILE        reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    ELSE            reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    ENDIF           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    ENDFOR          reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    COMMA           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    COLON           reduce using rule 17 (assignment_statement -> IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement .)
    OR              shift and go to state 38


state 121

    (16) assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .
    (19) or_statement -> or_statement . OR and_statement

    WHILE           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    FOR             reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    IF              reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    INPUT           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    PRINT           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    IDENTIFIER      reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    MINUS           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    NOT             reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    LPAREN          reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    INTEGER         reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    FLOAT           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    STRING          reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    TRUE            reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    FALSE           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    LBRACKET        reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    $end            reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    ENDWHILE        reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    ELSE            reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    ENDIF           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    ENDFOR          reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    COMMA           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    COLON           reduce using rule 16 (assignment_statement -> IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement .)
    OR              shift and go to state 38


state 122

    (10) iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON . start ENDFOR
    (1) start -> .
    (2) start -> . code_entity start
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) code_entity -> . array_append
    (9) iterative_statement -> . WHILE or_statement COLON start ENDWHILE
    (10) iterative_statement -> . FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR
    (11) conditional_statement -> . IF or_statement COLON start ELSE COLON start ENDIF
    (12) conditional_statement -> . IF or_statement COLON start ENDIF
    (13) expression -> . assignment_statement
    (57) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (58) output_function -> . PRINT LPAREN term RPAREN
    (59) array_append -> . IDENTIFIER PERIOD APPEND LPAREN INTEGER RPAREN
    (60) array_append -> . IDENTIFIER PERIOD APPEND LPAREN FLOAT RPAREN
    (61) array_append -> . IDENTIFIER PERIOD APPEND LPAREN IDENTIFIER RPAREN
    (14) assignment_statement -> . or_statement
    (15) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (16) assignment_statement -> . IDENTIFIER LBRACKET INTEGER RBRACKET EQUALS or_statement
    (17) assignment_statement -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET EQUALS or_statement
    (18) or_statement -> . and_statement
    (19) or_statement -> . or_statement OR and_statement
    (20) and_statement -> . equality_statement
    (21) and_statement -> . and_statement AND equality_statement
    (22) equality_statement -> . relational_statement
    (23) equality_statement -> . equality_statement EQ relational_statement
    (24) equality_statement -> . equality_statement NEQ relational_statement
    (25) relational_statement -> . add_statement
    (26) relational_statement -> . relational_statement LT add_statement
    (27) relational_statement -> . relational_statement GT add_statement
    (28) relational_statement -> . relational_statement LTEQ add_statement
    (29) relational_statement -> . relational_statement GTEQ add_statement
    (30) add_statement -> . multiply_statement
    (31) add_statement -> . add_statement PLUS multiply_statement
    (32) add_statement -> . add_statement MINUS multiply_statement
    (33) multiply_statement -> . unary_statement
    (34) multiply_statement -> . multiply_statement TIMES unary_statement
    (35) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (36) multiply_statement -> . multiply_statement FLRDIV unary_statement
    (37) multiply_statement -> . multiply_statement MOD unary_statement
    (38) unary_statement -> . exponent
    (39) unary_statement -> . MINUS unary_statement
    (40) unary_statement -> . NOT unary_statement
    (41) exponent -> . term
    (42) exponent -> . term POWER unary_statement
    (43) term -> . IDENTIFIER
    (44) term -> . atom
    (45) term -> . LPAREN or_statement RPAREN
    (46) atom -> . INTEGER
    (47) atom -> . FLOAT
    (48) atom -> . STRING
    (49) atom -> . TRUE
    (50) atom -> . FALSE
    (51) atom -> . LBRACKET elements RBRACKET
    (52) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET
    (53) atom -> . IDENTIFIER LBRACKET IDENTIFIER RBRACKET

    ENDFOR          reduce using rule 1 (start -> .)
    WHILE           shift and go to state 9
    FOR             shift and go to state 11
    IF              shift and go to state 13
    INPUT           shift and go to state 14
    PRINT           shift and go to state 17
    IDENTIFIER      shift and go to state 16
    MINUS           shift and go to state 27
    NOT             shift and go to state 30
    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 19
    FLOAT           shift and go to state 20
    STRING          shift and go to state 32
    TRUE            shift and go to state 33
    FALSE           shift and go to state 34
    LBRACKET        shift and go to state 21

    assignment_statement           shift and go to state 12
    or_statement                   shift and go to state 10
    start                          shift and go to state 124
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    array_append                   shift and go to state 8
    term                           shift and go to state 18
    and_statement                  shift and go to state 22
    equality_statement             shift and go to state 23
    relational_statement           shift and go to state 24
    add_statement                  shift and go to state 25
    multiply_statement             shift and go to state 26
    unary_statement                shift and go to state 28
    exponent                       shift and go to state 29
    atom                           shift and go to state 31

state 123

    (11) conditional_statement -> IF or_statement COLON start ELSE COLON start . ENDIF

    ENDIF           shift and go to state 125


state 124

    (10) iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start . ENDFOR

    ENDFOR          shift and go to state 126


state 125

    (11) conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .

    WHILE           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    FOR             reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    IF              reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    INPUT           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    PRINT           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    IDENTIFIER      reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    MINUS           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    NOT             reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    LPAREN          reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    INTEGER         reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    FLOAT           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    STRING          reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    TRUE            reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    FALSE           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    LBRACKET        reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    $end            reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    ENDWHILE        reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    ELSE            reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    ENDIF           reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)
    ENDFOR          reduce using rule 11 (conditional_statement -> IF or_statement COLON start ELSE COLON start ENDIF .)


state 126

    (10) iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .

    WHILE           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    FOR             reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    IF              reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    INPUT           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    PRINT           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    IDENTIFIER      reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    MINUS           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    NOT             reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    LPAREN          reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    INTEGER         reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    FLOAT           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    STRING          reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    TRUE            reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    FALSE           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    LBRACKET        reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    $end            reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    ENDWHILE        reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    ELSE            reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    ENDIF           reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)
    ENDFOR          reduce using rule 10 (iterative_statement -> FOR assignment_statement COMMA or_statement COMMA assignment_statement COLON start ENDFOR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 16 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 25 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
