Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> <empty>
Rule 2     start -> start code_entity
Rule 3     code_entity -> iterative_statement
Rule 4     code_entity -> conditional_statement
Rule 5     code_entity -> expression
Rule 6     code_entity -> input_function
Rule 7     code_entity -> output_function
Rule 8     iterative_statement -> WHILE expression COLON start ENDWHILE
Rule 9     iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR
Rule 10    conditional_statement -> IF expression COLON start ELSE start ENDIF
Rule 11    conditional_statement -> IF expression COLON start ENDIF
Rule 12    expression -> assignment_statement
Rule 13    assignment_statement -> or_statement
Rule 14    assignment_statement -> IDENTIFIER EQUALS or_statement
Rule 15    or_statement -> and_statement
Rule 16    or_statement -> or_statement OR and_statement
Rule 17    and_statement -> equality_statement
Rule 18    and_statement -> and_statement AND equality_statement
Rule 19    equality_statement -> relational_statement
Rule 20    equality_statement -> equality_statement EQ relational_statement
Rule 21    equality_statement -> equality_statement NEQ relational_statement
Rule 22    relational_statement -> add_statement
Rule 23    relational_statement -> relational_statement LT add_statement
Rule 24    relational_statement -> relational_statement GT add_statement
Rule 25    relational_statement -> relational_statement LTEQ add_statement
Rule 26    relational_statement -> relational_statement GTEQ add_statement
Rule 27    add_statement -> multiply_statement
Rule 28    add_statement -> add_statement PLUS multiply_statement
Rule 29    add_statement -> add_statement MINUS multiply_statement
Rule 30    multiply_statement -> unary_statement
Rule 31    multiply_statement -> multiply_statement TIMES unary_statement
Rule 32    multiply_statement -> multiply_statement DIVIDE unary_statement
Rule 33    multiply_statement -> multiply_statement MOD unary_statement
Rule 34    unary_statement -> exponent
Rule 35    unary_statement -> MINUS unary_statement
Rule 36    unary_statement -> NOT unary_statement
Rule 37    exponent -> term
Rule 38    exponent -> term POWER unary_statement
Rule 39    term -> IDENTIFIER
Rule 40    term -> atom
Rule 41    term -> LPAREN expression RPAREN
Rule 42    atom -> INTEGER
Rule 43    atom -> FLOAT
Rule 44    atom -> CHARACTER
Rule 45    atom -> STRING
Rule 46    atom -> TRUE
Rule 47    atom -> FALSE
Rule 48    atom -> LBRACKET elements RBRACKET
Rule 49    atom -> IDENTIFIER LBRACKET INTEGER RBRACKET
Rule 50    elements -> elements INTEGER
Rule 51    elements -> elements FLOAT
Rule 52    elements -> <empty>
Rule 53    input_function -> INPUT LPAREN IDENTIFIER RPAREN
Rule 54    output_function -> PRINT LPAREN term RPAREN

Terminals, with rules where they appear

AND                  : 18
CHARACTER            : 44
COLON                : 8 9 10 11
COMMA                : 9 9
DIVIDE               : 32
ELSE                 : 10
ENDFOR               : 9
ENDIF                : 10 11
ENDWHILE             : 8
EQ                   : 20
EQUALS               : 14
FALSE                : 47
FLOAT                : 43 51
FOR                  : 9
GT                   : 24
GTEQ                 : 26
IDENTIFIER           : 14 39 49 53
IF                   : 10 11
INPUT                : 53
INTEGER              : 42 49 50
LBRACKET             : 48 49
LPAREN               : 41 53 54
LT                   : 23
LTEQ                 : 25
MINUS                : 29 35
MOD                  : 33
NEQ                  : 21
NOT                  : 36
OR                   : 16
PLUS                 : 28
POWER                : 38
PRINT                : 54
RBRACKET             : 48 49
RPAREN               : 41 53 54
STRING               : 45
TIMES                : 31
TRUE                 : 46
WHILE                : 8
error                : 

Nonterminals, with rules where they appear

add_statement        : 22 23 24 25 26 28 29
and_statement        : 15 16 18
assignment_statement : 12
atom                 : 40
code_entity          : 2
conditional_statement : 4
elements             : 48 50 51
equality_statement   : 17 18 20 21
exponent             : 34
expression           : 5 8 9 9 9 10 11 41
input_function       : 6
iterative_statement  : 3
multiply_statement   : 27 28 29 31 32 33
or_statement         : 13 14 16
output_function      : 7
relational_statement : 19 20 21 23 24 25 26
start                : 2 8 9 10 10 11 0
term                 : 37 38 54
unary_statement      : 30 31 32 33 35 36 38

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> .
    (2) start -> . start code_entity

    WHILE           reduce using rule 1 (start -> .)
    FOR             reduce using rule 1 (start -> .)
    IF              reduce using rule 1 (start -> .)
    INPUT           reduce using rule 1 (start -> .)
    PRINT           reduce using rule 1 (start -> .)
    IDENTIFIER      reduce using rule 1 (start -> .)
    MINUS           reduce using rule 1 (start -> .)
    NOT             reduce using rule 1 (start -> .)
    LPAREN          reduce using rule 1 (start -> .)
    INTEGER         reduce using rule 1 (start -> .)
    FLOAT           reduce using rule 1 (start -> .)
    CHARACTER       reduce using rule 1 (start -> .)
    STRING          reduce using rule 1 (start -> .)
    TRUE            reduce using rule 1 (start -> .)
    FALSE           reduce using rule 1 (start -> .)
    LBRACKET        reduce using rule 1 (start -> .)
    $end            reduce using rule 1 (start -> .)

    start                          shift and go to state 1

state 1

    (0) S' -> start .
    (2) start -> start . code_entity
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    expression                     shift and go to state 5
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 2

    (2) start -> start code_entity .

    WHILE           reduce using rule 2 (start -> start code_entity .)
    FOR             reduce using rule 2 (start -> start code_entity .)
    IF              reduce using rule 2 (start -> start code_entity .)
    INPUT           reduce using rule 2 (start -> start code_entity .)
    PRINT           reduce using rule 2 (start -> start code_entity .)
    IDENTIFIER      reduce using rule 2 (start -> start code_entity .)
    MINUS           reduce using rule 2 (start -> start code_entity .)
    NOT             reduce using rule 2 (start -> start code_entity .)
    LPAREN          reduce using rule 2 (start -> start code_entity .)
    INTEGER         reduce using rule 2 (start -> start code_entity .)
    FLOAT           reduce using rule 2 (start -> start code_entity .)
    CHARACTER       reduce using rule 2 (start -> start code_entity .)
    STRING          reduce using rule 2 (start -> start code_entity .)
    TRUE            reduce using rule 2 (start -> start code_entity .)
    FALSE           reduce using rule 2 (start -> start code_entity .)
    LBRACKET        reduce using rule 2 (start -> start code_entity .)
    $end            reduce using rule 2 (start -> start code_entity .)
    ENDWHILE        reduce using rule 2 (start -> start code_entity .)
    ELSE            reduce using rule 2 (start -> start code_entity .)
    ENDIF           reduce using rule 2 (start -> start code_entity .)
    ENDFOR          reduce using rule 2 (start -> start code_entity .)


state 3

    (3) code_entity -> iterative_statement .

    WHILE           reduce using rule 3 (code_entity -> iterative_statement .)
    FOR             reduce using rule 3 (code_entity -> iterative_statement .)
    IF              reduce using rule 3 (code_entity -> iterative_statement .)
    INPUT           reduce using rule 3 (code_entity -> iterative_statement .)
    PRINT           reduce using rule 3 (code_entity -> iterative_statement .)
    IDENTIFIER      reduce using rule 3 (code_entity -> iterative_statement .)
    MINUS           reduce using rule 3 (code_entity -> iterative_statement .)
    NOT             reduce using rule 3 (code_entity -> iterative_statement .)
    LPAREN          reduce using rule 3 (code_entity -> iterative_statement .)
    INTEGER         reduce using rule 3 (code_entity -> iterative_statement .)
    FLOAT           reduce using rule 3 (code_entity -> iterative_statement .)
    CHARACTER       reduce using rule 3 (code_entity -> iterative_statement .)
    STRING          reduce using rule 3 (code_entity -> iterative_statement .)
    TRUE            reduce using rule 3 (code_entity -> iterative_statement .)
    FALSE           reduce using rule 3 (code_entity -> iterative_statement .)
    LBRACKET        reduce using rule 3 (code_entity -> iterative_statement .)
    $end            reduce using rule 3 (code_entity -> iterative_statement .)
    ENDWHILE        reduce using rule 3 (code_entity -> iterative_statement .)
    ELSE            reduce using rule 3 (code_entity -> iterative_statement .)
    ENDIF           reduce using rule 3 (code_entity -> iterative_statement .)
    ENDFOR          reduce using rule 3 (code_entity -> iterative_statement .)


state 4

    (4) code_entity -> conditional_statement .

    WHILE           reduce using rule 4 (code_entity -> conditional_statement .)
    FOR             reduce using rule 4 (code_entity -> conditional_statement .)
    IF              reduce using rule 4 (code_entity -> conditional_statement .)
    INPUT           reduce using rule 4 (code_entity -> conditional_statement .)
    PRINT           reduce using rule 4 (code_entity -> conditional_statement .)
    IDENTIFIER      reduce using rule 4 (code_entity -> conditional_statement .)
    MINUS           reduce using rule 4 (code_entity -> conditional_statement .)
    NOT             reduce using rule 4 (code_entity -> conditional_statement .)
    LPAREN          reduce using rule 4 (code_entity -> conditional_statement .)
    INTEGER         reduce using rule 4 (code_entity -> conditional_statement .)
    FLOAT           reduce using rule 4 (code_entity -> conditional_statement .)
    CHARACTER       reduce using rule 4 (code_entity -> conditional_statement .)
    STRING          reduce using rule 4 (code_entity -> conditional_statement .)
    TRUE            reduce using rule 4 (code_entity -> conditional_statement .)
    FALSE           reduce using rule 4 (code_entity -> conditional_statement .)
    LBRACKET        reduce using rule 4 (code_entity -> conditional_statement .)
    $end            reduce using rule 4 (code_entity -> conditional_statement .)
    ENDWHILE        reduce using rule 4 (code_entity -> conditional_statement .)
    ELSE            reduce using rule 4 (code_entity -> conditional_statement .)
    ENDIF           reduce using rule 4 (code_entity -> conditional_statement .)
    ENDFOR          reduce using rule 4 (code_entity -> conditional_statement .)


state 5

    (5) code_entity -> expression .

    WHILE           reduce using rule 5 (code_entity -> expression .)
    FOR             reduce using rule 5 (code_entity -> expression .)
    IF              reduce using rule 5 (code_entity -> expression .)
    INPUT           reduce using rule 5 (code_entity -> expression .)
    PRINT           reduce using rule 5 (code_entity -> expression .)
    IDENTIFIER      reduce using rule 5 (code_entity -> expression .)
    MINUS           reduce using rule 5 (code_entity -> expression .)
    NOT             reduce using rule 5 (code_entity -> expression .)
    LPAREN          reduce using rule 5 (code_entity -> expression .)
    INTEGER         reduce using rule 5 (code_entity -> expression .)
    FLOAT           reduce using rule 5 (code_entity -> expression .)
    CHARACTER       reduce using rule 5 (code_entity -> expression .)
    STRING          reduce using rule 5 (code_entity -> expression .)
    TRUE            reduce using rule 5 (code_entity -> expression .)
    FALSE           reduce using rule 5 (code_entity -> expression .)
    LBRACKET        reduce using rule 5 (code_entity -> expression .)
    $end            reduce using rule 5 (code_entity -> expression .)
    ENDWHILE        reduce using rule 5 (code_entity -> expression .)
    ELSE            reduce using rule 5 (code_entity -> expression .)
    ENDIF           reduce using rule 5 (code_entity -> expression .)
    ENDFOR          reduce using rule 5 (code_entity -> expression .)


state 6

    (6) code_entity -> input_function .

    WHILE           reduce using rule 6 (code_entity -> input_function .)
    FOR             reduce using rule 6 (code_entity -> input_function .)
    IF              reduce using rule 6 (code_entity -> input_function .)
    INPUT           reduce using rule 6 (code_entity -> input_function .)
    PRINT           reduce using rule 6 (code_entity -> input_function .)
    IDENTIFIER      reduce using rule 6 (code_entity -> input_function .)
    MINUS           reduce using rule 6 (code_entity -> input_function .)
    NOT             reduce using rule 6 (code_entity -> input_function .)
    LPAREN          reduce using rule 6 (code_entity -> input_function .)
    INTEGER         reduce using rule 6 (code_entity -> input_function .)
    FLOAT           reduce using rule 6 (code_entity -> input_function .)
    CHARACTER       reduce using rule 6 (code_entity -> input_function .)
    STRING          reduce using rule 6 (code_entity -> input_function .)
    TRUE            reduce using rule 6 (code_entity -> input_function .)
    FALSE           reduce using rule 6 (code_entity -> input_function .)
    LBRACKET        reduce using rule 6 (code_entity -> input_function .)
    $end            reduce using rule 6 (code_entity -> input_function .)
    ENDWHILE        reduce using rule 6 (code_entity -> input_function .)
    ELSE            reduce using rule 6 (code_entity -> input_function .)
    ENDIF           reduce using rule 6 (code_entity -> input_function .)
    ENDFOR          reduce using rule 6 (code_entity -> input_function .)


state 7

    (7) code_entity -> output_function .

    WHILE           reduce using rule 7 (code_entity -> output_function .)
    FOR             reduce using rule 7 (code_entity -> output_function .)
    IF              reduce using rule 7 (code_entity -> output_function .)
    INPUT           reduce using rule 7 (code_entity -> output_function .)
    PRINT           reduce using rule 7 (code_entity -> output_function .)
    IDENTIFIER      reduce using rule 7 (code_entity -> output_function .)
    MINUS           reduce using rule 7 (code_entity -> output_function .)
    NOT             reduce using rule 7 (code_entity -> output_function .)
    LPAREN          reduce using rule 7 (code_entity -> output_function .)
    INTEGER         reduce using rule 7 (code_entity -> output_function .)
    FLOAT           reduce using rule 7 (code_entity -> output_function .)
    CHARACTER       reduce using rule 7 (code_entity -> output_function .)
    STRING          reduce using rule 7 (code_entity -> output_function .)
    TRUE            reduce using rule 7 (code_entity -> output_function .)
    FALSE           reduce using rule 7 (code_entity -> output_function .)
    LBRACKET        reduce using rule 7 (code_entity -> output_function .)
    $end            reduce using rule 7 (code_entity -> output_function .)
    ENDWHILE        reduce using rule 7 (code_entity -> output_function .)
    ELSE            reduce using rule 7 (code_entity -> output_function .)
    ENDIF           reduce using rule 7 (code_entity -> output_function .)
    ENDFOR          reduce using rule 7 (code_entity -> output_function .)


state 8

    (8) iterative_statement -> WHILE . expression COLON start ENDWHILE
    (12) expression -> . assignment_statement
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 35
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 9

    (9) iterative_statement -> FOR . expression COMMA expression COMMA expression COLON start ENDFOR
    (12) expression -> . assignment_statement
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 36
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 10

    (10) conditional_statement -> IF . expression COLON start ELSE start ENDIF
    (11) conditional_statement -> IF . expression COLON start ENDIF
    (12) expression -> . assignment_statement
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 37
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 11

    (12) expression -> assignment_statement .

    WHILE           reduce using rule 12 (expression -> assignment_statement .)
    FOR             reduce using rule 12 (expression -> assignment_statement .)
    IF              reduce using rule 12 (expression -> assignment_statement .)
    INPUT           reduce using rule 12 (expression -> assignment_statement .)
    PRINT           reduce using rule 12 (expression -> assignment_statement .)
    IDENTIFIER      reduce using rule 12 (expression -> assignment_statement .)
    MINUS           reduce using rule 12 (expression -> assignment_statement .)
    NOT             reduce using rule 12 (expression -> assignment_statement .)
    LPAREN          reduce using rule 12 (expression -> assignment_statement .)
    INTEGER         reduce using rule 12 (expression -> assignment_statement .)
    FLOAT           reduce using rule 12 (expression -> assignment_statement .)
    CHARACTER       reduce using rule 12 (expression -> assignment_statement .)
    STRING          reduce using rule 12 (expression -> assignment_statement .)
    TRUE            reduce using rule 12 (expression -> assignment_statement .)
    FALSE           reduce using rule 12 (expression -> assignment_statement .)
    LBRACKET        reduce using rule 12 (expression -> assignment_statement .)
    $end            reduce using rule 12 (expression -> assignment_statement .)
    COLON           reduce using rule 12 (expression -> assignment_statement .)
    COMMA           reduce using rule 12 (expression -> assignment_statement .)
    RPAREN          reduce using rule 12 (expression -> assignment_statement .)
    ENDWHILE        reduce using rule 12 (expression -> assignment_statement .)
    ELSE            reduce using rule 12 (expression -> assignment_statement .)
    ENDIF           reduce using rule 12 (expression -> assignment_statement .)
    ENDFOR          reduce using rule 12 (expression -> assignment_statement .)


state 12

    (53) input_function -> INPUT . LPAREN IDENTIFIER RPAREN

    LPAREN          shift and go to state 38


state 13

    (41) term -> LPAREN . expression RPAREN
    (12) expression -> . assignment_statement
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 39
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 14

    (14) assignment_statement -> IDENTIFIER . EQUALS or_statement
    (39) term -> IDENTIFIER .
    (49) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    EQUALS          shift and go to state 40
    POWER           reduce using rule 39 (term -> IDENTIFIER .)
    TIMES           reduce using rule 39 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 39 (term -> IDENTIFIER .)
    MOD             reduce using rule 39 (term -> IDENTIFIER .)
    PLUS            reduce using rule 39 (term -> IDENTIFIER .)
    MINUS           reduce using rule 39 (term -> IDENTIFIER .)
    LT              reduce using rule 39 (term -> IDENTIFIER .)
    GT              reduce using rule 39 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 39 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 39 (term -> IDENTIFIER .)
    EQ              reduce using rule 39 (term -> IDENTIFIER .)
    NEQ             reduce using rule 39 (term -> IDENTIFIER .)
    AND             reduce using rule 39 (term -> IDENTIFIER .)
    OR              reduce using rule 39 (term -> IDENTIFIER .)
    WHILE           reduce using rule 39 (term -> IDENTIFIER .)
    FOR             reduce using rule 39 (term -> IDENTIFIER .)
    IF              reduce using rule 39 (term -> IDENTIFIER .)
    INPUT           reduce using rule 39 (term -> IDENTIFIER .)
    PRINT           reduce using rule 39 (term -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 39 (term -> IDENTIFIER .)
    NOT             reduce using rule 39 (term -> IDENTIFIER .)
    LPAREN          reduce using rule 39 (term -> IDENTIFIER .)
    INTEGER         reduce using rule 39 (term -> IDENTIFIER .)
    FLOAT           reduce using rule 39 (term -> IDENTIFIER .)
    CHARACTER       reduce using rule 39 (term -> IDENTIFIER .)
    STRING          reduce using rule 39 (term -> IDENTIFIER .)
    TRUE            reduce using rule 39 (term -> IDENTIFIER .)
    FALSE           reduce using rule 39 (term -> IDENTIFIER .)
    $end            reduce using rule 39 (term -> IDENTIFIER .)
    COLON           reduce using rule 39 (term -> IDENTIFIER .)
    COMMA           reduce using rule 39 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 39 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 39 (term -> IDENTIFIER .)
    ELSE            reduce using rule 39 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 39 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 39 (term -> IDENTIFIER .)
    LBRACKET        shift and go to state 41

  ! LBRACKET        [ reduce using rule 39 (term -> IDENTIFIER .) ]


state 15

    (54) output_function -> PRINT . LPAREN term RPAREN

    LPAREN          shift and go to state 42


state 16

    (37) exponent -> term .
    (38) exponent -> term . POWER unary_statement

    TIMES           reduce using rule 37 (exponent -> term .)
    DIVIDE          reduce using rule 37 (exponent -> term .)
    MOD             reduce using rule 37 (exponent -> term .)
    PLUS            reduce using rule 37 (exponent -> term .)
    MINUS           reduce using rule 37 (exponent -> term .)
    LT              reduce using rule 37 (exponent -> term .)
    GT              reduce using rule 37 (exponent -> term .)
    LTEQ            reduce using rule 37 (exponent -> term .)
    GTEQ            reduce using rule 37 (exponent -> term .)
    EQ              reduce using rule 37 (exponent -> term .)
    NEQ             reduce using rule 37 (exponent -> term .)
    AND             reduce using rule 37 (exponent -> term .)
    OR              reduce using rule 37 (exponent -> term .)
    WHILE           reduce using rule 37 (exponent -> term .)
    FOR             reduce using rule 37 (exponent -> term .)
    IF              reduce using rule 37 (exponent -> term .)
    INPUT           reduce using rule 37 (exponent -> term .)
    PRINT           reduce using rule 37 (exponent -> term .)
    IDENTIFIER      reduce using rule 37 (exponent -> term .)
    NOT             reduce using rule 37 (exponent -> term .)
    LPAREN          reduce using rule 37 (exponent -> term .)
    INTEGER         reduce using rule 37 (exponent -> term .)
    FLOAT           reduce using rule 37 (exponent -> term .)
    CHARACTER       reduce using rule 37 (exponent -> term .)
    STRING          reduce using rule 37 (exponent -> term .)
    TRUE            reduce using rule 37 (exponent -> term .)
    FALSE           reduce using rule 37 (exponent -> term .)
    LBRACKET        reduce using rule 37 (exponent -> term .)
    $end            reduce using rule 37 (exponent -> term .)
    COLON           reduce using rule 37 (exponent -> term .)
    COMMA           reduce using rule 37 (exponent -> term .)
    RPAREN          reduce using rule 37 (exponent -> term .)
    ENDWHILE        reduce using rule 37 (exponent -> term .)
    ELSE            reduce using rule 37 (exponent -> term .)
    ENDIF           reduce using rule 37 (exponent -> term .)
    ENDFOR          reduce using rule 37 (exponent -> term .)
    POWER           shift and go to state 43


state 17

    (13) assignment_statement -> or_statement .
    (16) or_statement -> or_statement . OR and_statement

    WHILE           reduce using rule 13 (assignment_statement -> or_statement .)
    FOR             reduce using rule 13 (assignment_statement -> or_statement .)
    IF              reduce using rule 13 (assignment_statement -> or_statement .)
    INPUT           reduce using rule 13 (assignment_statement -> or_statement .)
    PRINT           reduce using rule 13 (assignment_statement -> or_statement .)
    IDENTIFIER      reduce using rule 13 (assignment_statement -> or_statement .)
    MINUS           reduce using rule 13 (assignment_statement -> or_statement .)
    NOT             reduce using rule 13 (assignment_statement -> or_statement .)
    LPAREN          reduce using rule 13 (assignment_statement -> or_statement .)
    INTEGER         reduce using rule 13 (assignment_statement -> or_statement .)
    FLOAT           reduce using rule 13 (assignment_statement -> or_statement .)
    CHARACTER       reduce using rule 13 (assignment_statement -> or_statement .)
    STRING          reduce using rule 13 (assignment_statement -> or_statement .)
    TRUE            reduce using rule 13 (assignment_statement -> or_statement .)
    FALSE           reduce using rule 13 (assignment_statement -> or_statement .)
    LBRACKET        reduce using rule 13 (assignment_statement -> or_statement .)
    $end            reduce using rule 13 (assignment_statement -> or_statement .)
    COLON           reduce using rule 13 (assignment_statement -> or_statement .)
    COMMA           reduce using rule 13 (assignment_statement -> or_statement .)
    RPAREN          reduce using rule 13 (assignment_statement -> or_statement .)
    ENDWHILE        reduce using rule 13 (assignment_statement -> or_statement .)
    ELSE            reduce using rule 13 (assignment_statement -> or_statement .)
    ENDIF           reduce using rule 13 (assignment_statement -> or_statement .)
    ENDFOR          reduce using rule 13 (assignment_statement -> or_statement .)
    OR              shift and go to state 44


state 18

    (15) or_statement -> and_statement .
    (18) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 15 (or_statement -> and_statement .)
    WHILE           reduce using rule 15 (or_statement -> and_statement .)
    FOR             reduce using rule 15 (or_statement -> and_statement .)
    IF              reduce using rule 15 (or_statement -> and_statement .)
    INPUT           reduce using rule 15 (or_statement -> and_statement .)
    PRINT           reduce using rule 15 (or_statement -> and_statement .)
    IDENTIFIER      reduce using rule 15 (or_statement -> and_statement .)
    MINUS           reduce using rule 15 (or_statement -> and_statement .)
    NOT             reduce using rule 15 (or_statement -> and_statement .)
    LPAREN          reduce using rule 15 (or_statement -> and_statement .)
    INTEGER         reduce using rule 15 (or_statement -> and_statement .)
    FLOAT           reduce using rule 15 (or_statement -> and_statement .)
    CHARACTER       reduce using rule 15 (or_statement -> and_statement .)
    STRING          reduce using rule 15 (or_statement -> and_statement .)
    TRUE            reduce using rule 15 (or_statement -> and_statement .)
    FALSE           reduce using rule 15 (or_statement -> and_statement .)
    LBRACKET        reduce using rule 15 (or_statement -> and_statement .)
    $end            reduce using rule 15 (or_statement -> and_statement .)
    COLON           reduce using rule 15 (or_statement -> and_statement .)
    COMMA           reduce using rule 15 (or_statement -> and_statement .)
    RPAREN          reduce using rule 15 (or_statement -> and_statement .)
    ENDWHILE        reduce using rule 15 (or_statement -> and_statement .)
    ELSE            reduce using rule 15 (or_statement -> and_statement .)
    ENDIF           reduce using rule 15 (or_statement -> and_statement .)
    ENDFOR          reduce using rule 15 (or_statement -> and_statement .)
    AND             shift and go to state 45


state 19

    (17) and_statement -> equality_statement .
    (20) equality_statement -> equality_statement . EQ relational_statement
    (21) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 17 (and_statement -> equality_statement .)
    OR              reduce using rule 17 (and_statement -> equality_statement .)
    WHILE           reduce using rule 17 (and_statement -> equality_statement .)
    FOR             reduce using rule 17 (and_statement -> equality_statement .)
    IF              reduce using rule 17 (and_statement -> equality_statement .)
    INPUT           reduce using rule 17 (and_statement -> equality_statement .)
    PRINT           reduce using rule 17 (and_statement -> equality_statement .)
    IDENTIFIER      reduce using rule 17 (and_statement -> equality_statement .)
    MINUS           reduce using rule 17 (and_statement -> equality_statement .)
    NOT             reduce using rule 17 (and_statement -> equality_statement .)
    LPAREN          reduce using rule 17 (and_statement -> equality_statement .)
    INTEGER         reduce using rule 17 (and_statement -> equality_statement .)
    FLOAT           reduce using rule 17 (and_statement -> equality_statement .)
    CHARACTER       reduce using rule 17 (and_statement -> equality_statement .)
    STRING          reduce using rule 17 (and_statement -> equality_statement .)
    TRUE            reduce using rule 17 (and_statement -> equality_statement .)
    FALSE           reduce using rule 17 (and_statement -> equality_statement .)
    LBRACKET        reduce using rule 17 (and_statement -> equality_statement .)
    $end            reduce using rule 17 (and_statement -> equality_statement .)
    COLON           reduce using rule 17 (and_statement -> equality_statement .)
    COMMA           reduce using rule 17 (and_statement -> equality_statement .)
    RPAREN          reduce using rule 17 (and_statement -> equality_statement .)
    ENDWHILE        reduce using rule 17 (and_statement -> equality_statement .)
    ELSE            reduce using rule 17 (and_statement -> equality_statement .)
    ENDIF           reduce using rule 17 (and_statement -> equality_statement .)
    ENDFOR          reduce using rule 17 (and_statement -> equality_statement .)
    EQ              shift and go to state 46
    NEQ             shift and go to state 47


state 20

    (19) equality_statement -> relational_statement .
    (23) relational_statement -> relational_statement . LT add_statement
    (24) relational_statement -> relational_statement . GT add_statement
    (25) relational_statement -> relational_statement . LTEQ add_statement
    (26) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 19 (equality_statement -> relational_statement .)
    NEQ             reduce using rule 19 (equality_statement -> relational_statement .)
    AND             reduce using rule 19 (equality_statement -> relational_statement .)
    OR              reduce using rule 19 (equality_statement -> relational_statement .)
    WHILE           reduce using rule 19 (equality_statement -> relational_statement .)
    FOR             reduce using rule 19 (equality_statement -> relational_statement .)
    IF              reduce using rule 19 (equality_statement -> relational_statement .)
    INPUT           reduce using rule 19 (equality_statement -> relational_statement .)
    PRINT           reduce using rule 19 (equality_statement -> relational_statement .)
    IDENTIFIER      reduce using rule 19 (equality_statement -> relational_statement .)
    MINUS           reduce using rule 19 (equality_statement -> relational_statement .)
    NOT             reduce using rule 19 (equality_statement -> relational_statement .)
    LPAREN          reduce using rule 19 (equality_statement -> relational_statement .)
    INTEGER         reduce using rule 19 (equality_statement -> relational_statement .)
    FLOAT           reduce using rule 19 (equality_statement -> relational_statement .)
    CHARACTER       reduce using rule 19 (equality_statement -> relational_statement .)
    STRING          reduce using rule 19 (equality_statement -> relational_statement .)
    TRUE            reduce using rule 19 (equality_statement -> relational_statement .)
    FALSE           reduce using rule 19 (equality_statement -> relational_statement .)
    LBRACKET        reduce using rule 19 (equality_statement -> relational_statement .)
    $end            reduce using rule 19 (equality_statement -> relational_statement .)
    COLON           reduce using rule 19 (equality_statement -> relational_statement .)
    COMMA           reduce using rule 19 (equality_statement -> relational_statement .)
    RPAREN          reduce using rule 19 (equality_statement -> relational_statement .)
    ENDWHILE        reduce using rule 19 (equality_statement -> relational_statement .)
    ELSE            reduce using rule 19 (equality_statement -> relational_statement .)
    ENDIF           reduce using rule 19 (equality_statement -> relational_statement .)
    ENDFOR          reduce using rule 19 (equality_statement -> relational_statement .)
    LT              shift and go to state 48
    GT              shift and go to state 49
    LTEQ            shift and go to state 50
    GTEQ            shift and go to state 51


state 21

    (22) relational_statement -> add_statement .
    (28) add_statement -> add_statement . PLUS multiply_statement
    (29) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 22 (relational_statement -> add_statement .)
    GT              reduce using rule 22 (relational_statement -> add_statement .)
    LTEQ            reduce using rule 22 (relational_statement -> add_statement .)
    GTEQ            reduce using rule 22 (relational_statement -> add_statement .)
    EQ              reduce using rule 22 (relational_statement -> add_statement .)
    NEQ             reduce using rule 22 (relational_statement -> add_statement .)
    AND             reduce using rule 22 (relational_statement -> add_statement .)
    OR              reduce using rule 22 (relational_statement -> add_statement .)
    WHILE           reduce using rule 22 (relational_statement -> add_statement .)
    FOR             reduce using rule 22 (relational_statement -> add_statement .)
    IF              reduce using rule 22 (relational_statement -> add_statement .)
    INPUT           reduce using rule 22 (relational_statement -> add_statement .)
    PRINT           reduce using rule 22 (relational_statement -> add_statement .)
    IDENTIFIER      reduce using rule 22 (relational_statement -> add_statement .)
    NOT             reduce using rule 22 (relational_statement -> add_statement .)
    LPAREN          reduce using rule 22 (relational_statement -> add_statement .)
    INTEGER         reduce using rule 22 (relational_statement -> add_statement .)
    FLOAT           reduce using rule 22 (relational_statement -> add_statement .)
    CHARACTER       reduce using rule 22 (relational_statement -> add_statement .)
    STRING          reduce using rule 22 (relational_statement -> add_statement .)
    TRUE            reduce using rule 22 (relational_statement -> add_statement .)
    FALSE           reduce using rule 22 (relational_statement -> add_statement .)
    LBRACKET        reduce using rule 22 (relational_statement -> add_statement .)
    $end            reduce using rule 22 (relational_statement -> add_statement .)
    COLON           reduce using rule 22 (relational_statement -> add_statement .)
    COMMA           reduce using rule 22 (relational_statement -> add_statement .)
    RPAREN          reduce using rule 22 (relational_statement -> add_statement .)
    ENDWHILE        reduce using rule 22 (relational_statement -> add_statement .)
    ELSE            reduce using rule 22 (relational_statement -> add_statement .)
    ENDIF           reduce using rule 22 (relational_statement -> add_statement .)
    ENDFOR          reduce using rule 22 (relational_statement -> add_statement .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53

  ! MINUS           [ reduce using rule 22 (relational_statement -> add_statement .) ]


state 22

    (27) add_statement -> multiply_statement .
    (31) multiply_statement -> multiply_statement . TIMES unary_statement
    (32) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (33) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 27 (add_statement -> multiply_statement .)
    MINUS           reduce using rule 27 (add_statement -> multiply_statement .)
    LT              reduce using rule 27 (add_statement -> multiply_statement .)
    GT              reduce using rule 27 (add_statement -> multiply_statement .)
    LTEQ            reduce using rule 27 (add_statement -> multiply_statement .)
    GTEQ            reduce using rule 27 (add_statement -> multiply_statement .)
    EQ              reduce using rule 27 (add_statement -> multiply_statement .)
    NEQ             reduce using rule 27 (add_statement -> multiply_statement .)
    AND             reduce using rule 27 (add_statement -> multiply_statement .)
    OR              reduce using rule 27 (add_statement -> multiply_statement .)
    WHILE           reduce using rule 27 (add_statement -> multiply_statement .)
    FOR             reduce using rule 27 (add_statement -> multiply_statement .)
    IF              reduce using rule 27 (add_statement -> multiply_statement .)
    INPUT           reduce using rule 27 (add_statement -> multiply_statement .)
    PRINT           reduce using rule 27 (add_statement -> multiply_statement .)
    IDENTIFIER      reduce using rule 27 (add_statement -> multiply_statement .)
    NOT             reduce using rule 27 (add_statement -> multiply_statement .)
    LPAREN          reduce using rule 27 (add_statement -> multiply_statement .)
    INTEGER         reduce using rule 27 (add_statement -> multiply_statement .)
    FLOAT           reduce using rule 27 (add_statement -> multiply_statement .)
    CHARACTER       reduce using rule 27 (add_statement -> multiply_statement .)
    STRING          reduce using rule 27 (add_statement -> multiply_statement .)
    TRUE            reduce using rule 27 (add_statement -> multiply_statement .)
    FALSE           reduce using rule 27 (add_statement -> multiply_statement .)
    LBRACKET        reduce using rule 27 (add_statement -> multiply_statement .)
    $end            reduce using rule 27 (add_statement -> multiply_statement .)
    COLON           reduce using rule 27 (add_statement -> multiply_statement .)
    COMMA           reduce using rule 27 (add_statement -> multiply_statement .)
    RPAREN          reduce using rule 27 (add_statement -> multiply_statement .)
    ENDWHILE        reduce using rule 27 (add_statement -> multiply_statement .)
    ELSE            reduce using rule 27 (add_statement -> multiply_statement .)
    ENDIF           reduce using rule 27 (add_statement -> multiply_statement .)
    ENDFOR          reduce using rule 27 (add_statement -> multiply_statement .)
    TIMES           shift and go to state 54
    DIVIDE          shift and go to state 55
    MOD             shift and go to state 56


state 23

    (35) unary_statement -> MINUS . unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    unary_statement                shift and go to state 57
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 24

    (30) multiply_statement -> unary_statement .

    TIMES           reduce using rule 30 (multiply_statement -> unary_statement .)
    DIVIDE          reduce using rule 30 (multiply_statement -> unary_statement .)
    MOD             reduce using rule 30 (multiply_statement -> unary_statement .)
    PLUS            reduce using rule 30 (multiply_statement -> unary_statement .)
    MINUS           reduce using rule 30 (multiply_statement -> unary_statement .)
    LT              reduce using rule 30 (multiply_statement -> unary_statement .)
    GT              reduce using rule 30 (multiply_statement -> unary_statement .)
    LTEQ            reduce using rule 30 (multiply_statement -> unary_statement .)
    GTEQ            reduce using rule 30 (multiply_statement -> unary_statement .)
    EQ              reduce using rule 30 (multiply_statement -> unary_statement .)
    NEQ             reduce using rule 30 (multiply_statement -> unary_statement .)
    AND             reduce using rule 30 (multiply_statement -> unary_statement .)
    OR              reduce using rule 30 (multiply_statement -> unary_statement .)
    WHILE           reduce using rule 30 (multiply_statement -> unary_statement .)
    FOR             reduce using rule 30 (multiply_statement -> unary_statement .)
    IF              reduce using rule 30 (multiply_statement -> unary_statement .)
    INPUT           reduce using rule 30 (multiply_statement -> unary_statement .)
    PRINT           reduce using rule 30 (multiply_statement -> unary_statement .)
    IDENTIFIER      reduce using rule 30 (multiply_statement -> unary_statement .)
    NOT             reduce using rule 30 (multiply_statement -> unary_statement .)
    LPAREN          reduce using rule 30 (multiply_statement -> unary_statement .)
    INTEGER         reduce using rule 30 (multiply_statement -> unary_statement .)
    FLOAT           reduce using rule 30 (multiply_statement -> unary_statement .)
    CHARACTER       reduce using rule 30 (multiply_statement -> unary_statement .)
    STRING          reduce using rule 30 (multiply_statement -> unary_statement .)
    TRUE            reduce using rule 30 (multiply_statement -> unary_statement .)
    FALSE           reduce using rule 30 (multiply_statement -> unary_statement .)
    LBRACKET        reduce using rule 30 (multiply_statement -> unary_statement .)
    $end            reduce using rule 30 (multiply_statement -> unary_statement .)
    COLON           reduce using rule 30 (multiply_statement -> unary_statement .)
    COMMA           reduce using rule 30 (multiply_statement -> unary_statement .)
    RPAREN          reduce using rule 30 (multiply_statement -> unary_statement .)
    ENDWHILE        reduce using rule 30 (multiply_statement -> unary_statement .)
    ELSE            reduce using rule 30 (multiply_statement -> unary_statement .)
    ENDIF           reduce using rule 30 (multiply_statement -> unary_statement .)
    ENDFOR          reduce using rule 30 (multiply_statement -> unary_statement .)


state 25

    (34) unary_statement -> exponent .

    TIMES           reduce using rule 34 (unary_statement -> exponent .)
    DIVIDE          reduce using rule 34 (unary_statement -> exponent .)
    MOD             reduce using rule 34 (unary_statement -> exponent .)
    PLUS            reduce using rule 34 (unary_statement -> exponent .)
    MINUS           reduce using rule 34 (unary_statement -> exponent .)
    LT              reduce using rule 34 (unary_statement -> exponent .)
    GT              reduce using rule 34 (unary_statement -> exponent .)
    LTEQ            reduce using rule 34 (unary_statement -> exponent .)
    GTEQ            reduce using rule 34 (unary_statement -> exponent .)
    EQ              reduce using rule 34 (unary_statement -> exponent .)
    NEQ             reduce using rule 34 (unary_statement -> exponent .)
    AND             reduce using rule 34 (unary_statement -> exponent .)
    OR              reduce using rule 34 (unary_statement -> exponent .)
    WHILE           reduce using rule 34 (unary_statement -> exponent .)
    FOR             reduce using rule 34 (unary_statement -> exponent .)
    IF              reduce using rule 34 (unary_statement -> exponent .)
    INPUT           reduce using rule 34 (unary_statement -> exponent .)
    PRINT           reduce using rule 34 (unary_statement -> exponent .)
    IDENTIFIER      reduce using rule 34 (unary_statement -> exponent .)
    NOT             reduce using rule 34 (unary_statement -> exponent .)
    LPAREN          reduce using rule 34 (unary_statement -> exponent .)
    INTEGER         reduce using rule 34 (unary_statement -> exponent .)
    FLOAT           reduce using rule 34 (unary_statement -> exponent .)
    CHARACTER       reduce using rule 34 (unary_statement -> exponent .)
    STRING          reduce using rule 34 (unary_statement -> exponent .)
    TRUE            reduce using rule 34 (unary_statement -> exponent .)
    FALSE           reduce using rule 34 (unary_statement -> exponent .)
    LBRACKET        reduce using rule 34 (unary_statement -> exponent .)
    $end            reduce using rule 34 (unary_statement -> exponent .)
    COLON           reduce using rule 34 (unary_statement -> exponent .)
    COMMA           reduce using rule 34 (unary_statement -> exponent .)
    RPAREN          reduce using rule 34 (unary_statement -> exponent .)
    ENDWHILE        reduce using rule 34 (unary_statement -> exponent .)
    ELSE            reduce using rule 34 (unary_statement -> exponent .)
    ENDIF           reduce using rule 34 (unary_statement -> exponent .)
    ENDFOR          reduce using rule 34 (unary_statement -> exponent .)


state 26

    (36) unary_statement -> NOT . unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    unary_statement                shift and go to state 59
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 27

    (40) term -> atom .

    POWER           reduce using rule 40 (term -> atom .)
    TIMES           reduce using rule 40 (term -> atom .)
    DIVIDE          reduce using rule 40 (term -> atom .)
    MOD             reduce using rule 40 (term -> atom .)
    PLUS            reduce using rule 40 (term -> atom .)
    MINUS           reduce using rule 40 (term -> atom .)
    LT              reduce using rule 40 (term -> atom .)
    GT              reduce using rule 40 (term -> atom .)
    LTEQ            reduce using rule 40 (term -> atom .)
    GTEQ            reduce using rule 40 (term -> atom .)
    EQ              reduce using rule 40 (term -> atom .)
    NEQ             reduce using rule 40 (term -> atom .)
    AND             reduce using rule 40 (term -> atom .)
    OR              reduce using rule 40 (term -> atom .)
    WHILE           reduce using rule 40 (term -> atom .)
    FOR             reduce using rule 40 (term -> atom .)
    IF              reduce using rule 40 (term -> atom .)
    INPUT           reduce using rule 40 (term -> atom .)
    PRINT           reduce using rule 40 (term -> atom .)
    IDENTIFIER      reduce using rule 40 (term -> atom .)
    NOT             reduce using rule 40 (term -> atom .)
    LPAREN          reduce using rule 40 (term -> atom .)
    INTEGER         reduce using rule 40 (term -> atom .)
    FLOAT           reduce using rule 40 (term -> atom .)
    CHARACTER       reduce using rule 40 (term -> atom .)
    STRING          reduce using rule 40 (term -> atom .)
    TRUE            reduce using rule 40 (term -> atom .)
    FALSE           reduce using rule 40 (term -> atom .)
    LBRACKET        reduce using rule 40 (term -> atom .)
    $end            reduce using rule 40 (term -> atom .)
    COLON           reduce using rule 40 (term -> atom .)
    COMMA           reduce using rule 40 (term -> atom .)
    RPAREN          reduce using rule 40 (term -> atom .)
    ENDWHILE        reduce using rule 40 (term -> atom .)
    ELSE            reduce using rule 40 (term -> atom .)
    ENDIF           reduce using rule 40 (term -> atom .)
    ENDFOR          reduce using rule 40 (term -> atom .)


state 28

    (42) atom -> INTEGER .

    POWER           reduce using rule 42 (atom -> INTEGER .)
    TIMES           reduce using rule 42 (atom -> INTEGER .)
    DIVIDE          reduce using rule 42 (atom -> INTEGER .)
    MOD             reduce using rule 42 (atom -> INTEGER .)
    PLUS            reduce using rule 42 (atom -> INTEGER .)
    MINUS           reduce using rule 42 (atom -> INTEGER .)
    LT              reduce using rule 42 (atom -> INTEGER .)
    GT              reduce using rule 42 (atom -> INTEGER .)
    LTEQ            reduce using rule 42 (atom -> INTEGER .)
    GTEQ            reduce using rule 42 (atom -> INTEGER .)
    EQ              reduce using rule 42 (atom -> INTEGER .)
    NEQ             reduce using rule 42 (atom -> INTEGER .)
    AND             reduce using rule 42 (atom -> INTEGER .)
    OR              reduce using rule 42 (atom -> INTEGER .)
    WHILE           reduce using rule 42 (atom -> INTEGER .)
    FOR             reduce using rule 42 (atom -> INTEGER .)
    IF              reduce using rule 42 (atom -> INTEGER .)
    INPUT           reduce using rule 42 (atom -> INTEGER .)
    PRINT           reduce using rule 42 (atom -> INTEGER .)
    IDENTIFIER      reduce using rule 42 (atom -> INTEGER .)
    NOT             reduce using rule 42 (atom -> INTEGER .)
    LPAREN          reduce using rule 42 (atom -> INTEGER .)
    INTEGER         reduce using rule 42 (atom -> INTEGER .)
    FLOAT           reduce using rule 42 (atom -> INTEGER .)
    CHARACTER       reduce using rule 42 (atom -> INTEGER .)
    STRING          reduce using rule 42 (atom -> INTEGER .)
    TRUE            reduce using rule 42 (atom -> INTEGER .)
    FALSE           reduce using rule 42 (atom -> INTEGER .)
    LBRACKET        reduce using rule 42 (atom -> INTEGER .)
    $end            reduce using rule 42 (atom -> INTEGER .)
    COLON           reduce using rule 42 (atom -> INTEGER .)
    COMMA           reduce using rule 42 (atom -> INTEGER .)
    RPAREN          reduce using rule 42 (atom -> INTEGER .)
    ENDWHILE        reduce using rule 42 (atom -> INTEGER .)
    ELSE            reduce using rule 42 (atom -> INTEGER .)
    ENDIF           reduce using rule 42 (atom -> INTEGER .)
    ENDFOR          reduce using rule 42 (atom -> INTEGER .)


state 29

    (43) atom -> FLOAT .

    POWER           reduce using rule 43 (atom -> FLOAT .)
    TIMES           reduce using rule 43 (atom -> FLOAT .)
    DIVIDE          reduce using rule 43 (atom -> FLOAT .)
    MOD             reduce using rule 43 (atom -> FLOAT .)
    PLUS            reduce using rule 43 (atom -> FLOAT .)
    MINUS           reduce using rule 43 (atom -> FLOAT .)
    LT              reduce using rule 43 (atom -> FLOAT .)
    GT              reduce using rule 43 (atom -> FLOAT .)
    LTEQ            reduce using rule 43 (atom -> FLOAT .)
    GTEQ            reduce using rule 43 (atom -> FLOAT .)
    EQ              reduce using rule 43 (atom -> FLOAT .)
    NEQ             reduce using rule 43 (atom -> FLOAT .)
    AND             reduce using rule 43 (atom -> FLOAT .)
    OR              reduce using rule 43 (atom -> FLOAT .)
    WHILE           reduce using rule 43 (atom -> FLOAT .)
    FOR             reduce using rule 43 (atom -> FLOAT .)
    IF              reduce using rule 43 (atom -> FLOAT .)
    INPUT           reduce using rule 43 (atom -> FLOAT .)
    PRINT           reduce using rule 43 (atom -> FLOAT .)
    IDENTIFIER      reduce using rule 43 (atom -> FLOAT .)
    NOT             reduce using rule 43 (atom -> FLOAT .)
    LPAREN          reduce using rule 43 (atom -> FLOAT .)
    INTEGER         reduce using rule 43 (atom -> FLOAT .)
    FLOAT           reduce using rule 43 (atom -> FLOAT .)
    CHARACTER       reduce using rule 43 (atom -> FLOAT .)
    STRING          reduce using rule 43 (atom -> FLOAT .)
    TRUE            reduce using rule 43 (atom -> FLOAT .)
    FALSE           reduce using rule 43 (atom -> FLOAT .)
    LBRACKET        reduce using rule 43 (atom -> FLOAT .)
    $end            reduce using rule 43 (atom -> FLOAT .)
    COLON           reduce using rule 43 (atom -> FLOAT .)
    COMMA           reduce using rule 43 (atom -> FLOAT .)
    RPAREN          reduce using rule 43 (atom -> FLOAT .)
    ENDWHILE        reduce using rule 43 (atom -> FLOAT .)
    ELSE            reduce using rule 43 (atom -> FLOAT .)
    ENDIF           reduce using rule 43 (atom -> FLOAT .)
    ENDFOR          reduce using rule 43 (atom -> FLOAT .)


state 30

    (44) atom -> CHARACTER .

    POWER           reduce using rule 44 (atom -> CHARACTER .)
    TIMES           reduce using rule 44 (atom -> CHARACTER .)
    DIVIDE          reduce using rule 44 (atom -> CHARACTER .)
    MOD             reduce using rule 44 (atom -> CHARACTER .)
    PLUS            reduce using rule 44 (atom -> CHARACTER .)
    MINUS           reduce using rule 44 (atom -> CHARACTER .)
    LT              reduce using rule 44 (atom -> CHARACTER .)
    GT              reduce using rule 44 (atom -> CHARACTER .)
    LTEQ            reduce using rule 44 (atom -> CHARACTER .)
    GTEQ            reduce using rule 44 (atom -> CHARACTER .)
    EQ              reduce using rule 44 (atom -> CHARACTER .)
    NEQ             reduce using rule 44 (atom -> CHARACTER .)
    AND             reduce using rule 44 (atom -> CHARACTER .)
    OR              reduce using rule 44 (atom -> CHARACTER .)
    WHILE           reduce using rule 44 (atom -> CHARACTER .)
    FOR             reduce using rule 44 (atom -> CHARACTER .)
    IF              reduce using rule 44 (atom -> CHARACTER .)
    INPUT           reduce using rule 44 (atom -> CHARACTER .)
    PRINT           reduce using rule 44 (atom -> CHARACTER .)
    IDENTIFIER      reduce using rule 44 (atom -> CHARACTER .)
    NOT             reduce using rule 44 (atom -> CHARACTER .)
    LPAREN          reduce using rule 44 (atom -> CHARACTER .)
    INTEGER         reduce using rule 44 (atom -> CHARACTER .)
    FLOAT           reduce using rule 44 (atom -> CHARACTER .)
    CHARACTER       reduce using rule 44 (atom -> CHARACTER .)
    STRING          reduce using rule 44 (atom -> CHARACTER .)
    TRUE            reduce using rule 44 (atom -> CHARACTER .)
    FALSE           reduce using rule 44 (atom -> CHARACTER .)
    LBRACKET        reduce using rule 44 (atom -> CHARACTER .)
    $end            reduce using rule 44 (atom -> CHARACTER .)
    COLON           reduce using rule 44 (atom -> CHARACTER .)
    COMMA           reduce using rule 44 (atom -> CHARACTER .)
    RPAREN          reduce using rule 44 (atom -> CHARACTER .)
    ENDWHILE        reduce using rule 44 (atom -> CHARACTER .)
    ELSE            reduce using rule 44 (atom -> CHARACTER .)
    ENDIF           reduce using rule 44 (atom -> CHARACTER .)
    ENDFOR          reduce using rule 44 (atom -> CHARACTER .)


state 31

    (45) atom -> STRING .

    POWER           reduce using rule 45 (atom -> STRING .)
    TIMES           reduce using rule 45 (atom -> STRING .)
    DIVIDE          reduce using rule 45 (atom -> STRING .)
    MOD             reduce using rule 45 (atom -> STRING .)
    PLUS            reduce using rule 45 (atom -> STRING .)
    MINUS           reduce using rule 45 (atom -> STRING .)
    LT              reduce using rule 45 (atom -> STRING .)
    GT              reduce using rule 45 (atom -> STRING .)
    LTEQ            reduce using rule 45 (atom -> STRING .)
    GTEQ            reduce using rule 45 (atom -> STRING .)
    EQ              reduce using rule 45 (atom -> STRING .)
    NEQ             reduce using rule 45 (atom -> STRING .)
    AND             reduce using rule 45 (atom -> STRING .)
    OR              reduce using rule 45 (atom -> STRING .)
    WHILE           reduce using rule 45 (atom -> STRING .)
    FOR             reduce using rule 45 (atom -> STRING .)
    IF              reduce using rule 45 (atom -> STRING .)
    INPUT           reduce using rule 45 (atom -> STRING .)
    PRINT           reduce using rule 45 (atom -> STRING .)
    IDENTIFIER      reduce using rule 45 (atom -> STRING .)
    NOT             reduce using rule 45 (atom -> STRING .)
    LPAREN          reduce using rule 45 (atom -> STRING .)
    INTEGER         reduce using rule 45 (atom -> STRING .)
    FLOAT           reduce using rule 45 (atom -> STRING .)
    CHARACTER       reduce using rule 45 (atom -> STRING .)
    STRING          reduce using rule 45 (atom -> STRING .)
    TRUE            reduce using rule 45 (atom -> STRING .)
    FALSE           reduce using rule 45 (atom -> STRING .)
    LBRACKET        reduce using rule 45 (atom -> STRING .)
    $end            reduce using rule 45 (atom -> STRING .)
    COLON           reduce using rule 45 (atom -> STRING .)
    COMMA           reduce using rule 45 (atom -> STRING .)
    RPAREN          reduce using rule 45 (atom -> STRING .)
    ENDWHILE        reduce using rule 45 (atom -> STRING .)
    ELSE            reduce using rule 45 (atom -> STRING .)
    ENDIF           reduce using rule 45 (atom -> STRING .)
    ENDFOR          reduce using rule 45 (atom -> STRING .)


state 32

    (46) atom -> TRUE .

    POWER           reduce using rule 46 (atom -> TRUE .)
    TIMES           reduce using rule 46 (atom -> TRUE .)
    DIVIDE          reduce using rule 46 (atom -> TRUE .)
    MOD             reduce using rule 46 (atom -> TRUE .)
    PLUS            reduce using rule 46 (atom -> TRUE .)
    MINUS           reduce using rule 46 (atom -> TRUE .)
    LT              reduce using rule 46 (atom -> TRUE .)
    GT              reduce using rule 46 (atom -> TRUE .)
    LTEQ            reduce using rule 46 (atom -> TRUE .)
    GTEQ            reduce using rule 46 (atom -> TRUE .)
    EQ              reduce using rule 46 (atom -> TRUE .)
    NEQ             reduce using rule 46 (atom -> TRUE .)
    AND             reduce using rule 46 (atom -> TRUE .)
    OR              reduce using rule 46 (atom -> TRUE .)
    WHILE           reduce using rule 46 (atom -> TRUE .)
    FOR             reduce using rule 46 (atom -> TRUE .)
    IF              reduce using rule 46 (atom -> TRUE .)
    INPUT           reduce using rule 46 (atom -> TRUE .)
    PRINT           reduce using rule 46 (atom -> TRUE .)
    IDENTIFIER      reduce using rule 46 (atom -> TRUE .)
    NOT             reduce using rule 46 (atom -> TRUE .)
    LPAREN          reduce using rule 46 (atom -> TRUE .)
    INTEGER         reduce using rule 46 (atom -> TRUE .)
    FLOAT           reduce using rule 46 (atom -> TRUE .)
    CHARACTER       reduce using rule 46 (atom -> TRUE .)
    STRING          reduce using rule 46 (atom -> TRUE .)
    TRUE            reduce using rule 46 (atom -> TRUE .)
    FALSE           reduce using rule 46 (atom -> TRUE .)
    LBRACKET        reduce using rule 46 (atom -> TRUE .)
    $end            reduce using rule 46 (atom -> TRUE .)
    COLON           reduce using rule 46 (atom -> TRUE .)
    COMMA           reduce using rule 46 (atom -> TRUE .)
    RPAREN          reduce using rule 46 (atom -> TRUE .)
    ENDWHILE        reduce using rule 46 (atom -> TRUE .)
    ELSE            reduce using rule 46 (atom -> TRUE .)
    ENDIF           reduce using rule 46 (atom -> TRUE .)
    ENDFOR          reduce using rule 46 (atom -> TRUE .)


state 33

    (47) atom -> FALSE .

    POWER           reduce using rule 47 (atom -> FALSE .)
    TIMES           reduce using rule 47 (atom -> FALSE .)
    DIVIDE          reduce using rule 47 (atom -> FALSE .)
    MOD             reduce using rule 47 (atom -> FALSE .)
    PLUS            reduce using rule 47 (atom -> FALSE .)
    MINUS           reduce using rule 47 (atom -> FALSE .)
    LT              reduce using rule 47 (atom -> FALSE .)
    GT              reduce using rule 47 (atom -> FALSE .)
    LTEQ            reduce using rule 47 (atom -> FALSE .)
    GTEQ            reduce using rule 47 (atom -> FALSE .)
    EQ              reduce using rule 47 (atom -> FALSE .)
    NEQ             reduce using rule 47 (atom -> FALSE .)
    AND             reduce using rule 47 (atom -> FALSE .)
    OR              reduce using rule 47 (atom -> FALSE .)
    WHILE           reduce using rule 47 (atom -> FALSE .)
    FOR             reduce using rule 47 (atom -> FALSE .)
    IF              reduce using rule 47 (atom -> FALSE .)
    INPUT           reduce using rule 47 (atom -> FALSE .)
    PRINT           reduce using rule 47 (atom -> FALSE .)
    IDENTIFIER      reduce using rule 47 (atom -> FALSE .)
    NOT             reduce using rule 47 (atom -> FALSE .)
    LPAREN          reduce using rule 47 (atom -> FALSE .)
    INTEGER         reduce using rule 47 (atom -> FALSE .)
    FLOAT           reduce using rule 47 (atom -> FALSE .)
    CHARACTER       reduce using rule 47 (atom -> FALSE .)
    STRING          reduce using rule 47 (atom -> FALSE .)
    TRUE            reduce using rule 47 (atom -> FALSE .)
    FALSE           reduce using rule 47 (atom -> FALSE .)
    LBRACKET        reduce using rule 47 (atom -> FALSE .)
    $end            reduce using rule 47 (atom -> FALSE .)
    COLON           reduce using rule 47 (atom -> FALSE .)
    COMMA           reduce using rule 47 (atom -> FALSE .)
    RPAREN          reduce using rule 47 (atom -> FALSE .)
    ENDWHILE        reduce using rule 47 (atom -> FALSE .)
    ELSE            reduce using rule 47 (atom -> FALSE .)
    ENDIF           reduce using rule 47 (atom -> FALSE .)
    ENDFOR          reduce using rule 47 (atom -> FALSE .)


state 34

    (48) atom -> LBRACKET . elements RBRACKET
    (50) elements -> . elements INTEGER
    (51) elements -> . elements FLOAT
    (52) elements -> .

    RBRACKET        reduce using rule 52 (elements -> .)
    INTEGER         reduce using rule 52 (elements -> .)
    FLOAT           reduce using rule 52 (elements -> .)

    elements                       shift and go to state 60

state 35

    (8) iterative_statement -> WHILE expression . COLON start ENDWHILE

    COLON           shift and go to state 61


state 36

    (9) iterative_statement -> FOR expression . COMMA expression COMMA expression COLON start ENDFOR

    COMMA           shift and go to state 62


state 37

    (10) conditional_statement -> IF expression . COLON start ELSE start ENDIF
    (11) conditional_statement -> IF expression . COLON start ENDIF

    COLON           shift and go to state 63


state 38

    (53) input_function -> INPUT LPAREN . IDENTIFIER RPAREN

    IDENTIFIER      shift and go to state 64


state 39

    (41) term -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 65


state 40

    (14) assignment_statement -> IDENTIFIER EQUALS . or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    or_statement                   shift and go to state 66
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 41

    (49) atom -> IDENTIFIER LBRACKET . INTEGER RBRACKET

    INTEGER         shift and go to state 67


state 42

    (54) output_function -> PRINT LPAREN . term RPAREN
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    term                           shift and go to state 68
    atom                           shift and go to state 27

state 43

    (38) exponent -> term POWER . unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    term                           shift and go to state 16
    unary_statement                shift and go to state 69
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 44

    (16) or_statement -> or_statement OR . and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    and_statement                  shift and go to state 70
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 45

    (18) and_statement -> and_statement AND . equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    equality_statement             shift and go to state 71
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 46

    (20) equality_statement -> equality_statement EQ . relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    relational_statement           shift and go to state 72
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 47

    (21) equality_statement -> equality_statement NEQ . relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    relational_statement           shift and go to state 73
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 48

    (23) relational_statement -> relational_statement LT . add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    add_statement                  shift and go to state 74
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 49

    (24) relational_statement -> relational_statement GT . add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    add_statement                  shift and go to state 75
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 50

    (25) relational_statement -> relational_statement LTEQ . add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    add_statement                  shift and go to state 76
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 51

    (26) relational_statement -> relational_statement GTEQ . add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    add_statement                  shift and go to state 77
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 52

    (28) add_statement -> add_statement PLUS . multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    multiply_statement             shift and go to state 78
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 53

    (29) add_statement -> add_statement MINUS . multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    multiply_statement             shift and go to state 79
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 54

    (31) multiply_statement -> multiply_statement TIMES . unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    unary_statement                shift and go to state 80
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 55

    (32) multiply_statement -> multiply_statement DIVIDE . unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    unary_statement                shift and go to state 81
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 56

    (33) multiply_statement -> multiply_statement MOD . unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    IDENTIFIER      shift and go to state 58
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    unary_statement                shift and go to state 82
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 57

    (35) unary_statement -> MINUS unary_statement .

    TIMES           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    DIVIDE          reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    MOD             reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    PLUS            reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    MINUS           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    LT              reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    GT              reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    LTEQ            reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    GTEQ            reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    EQ              reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    NEQ             reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    AND             reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    OR              reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    WHILE           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    FOR             reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    IF              reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    INPUT           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    PRINT           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    IDENTIFIER      reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    NOT             reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    LPAREN          reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    INTEGER         reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    FLOAT           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    CHARACTER       reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    STRING          reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    TRUE            reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    FALSE           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    LBRACKET        reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    $end            reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    COLON           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    COMMA           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    RPAREN          reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    ENDWHILE        reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    ELSE            reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    ENDIF           reduce using rule 35 (unary_statement -> MINUS unary_statement .)
    ENDFOR          reduce using rule 35 (unary_statement -> MINUS unary_statement .)


state 58

    (39) term -> IDENTIFIER .
    (49) atom -> IDENTIFIER . LBRACKET INTEGER RBRACKET

  ! shift/reduce conflict for LBRACKET resolved as shift
    POWER           reduce using rule 39 (term -> IDENTIFIER .)
    TIMES           reduce using rule 39 (term -> IDENTIFIER .)
    DIVIDE          reduce using rule 39 (term -> IDENTIFIER .)
    MOD             reduce using rule 39 (term -> IDENTIFIER .)
    PLUS            reduce using rule 39 (term -> IDENTIFIER .)
    MINUS           reduce using rule 39 (term -> IDENTIFIER .)
    LT              reduce using rule 39 (term -> IDENTIFIER .)
    GT              reduce using rule 39 (term -> IDENTIFIER .)
    LTEQ            reduce using rule 39 (term -> IDENTIFIER .)
    GTEQ            reduce using rule 39 (term -> IDENTIFIER .)
    EQ              reduce using rule 39 (term -> IDENTIFIER .)
    NEQ             reduce using rule 39 (term -> IDENTIFIER .)
    AND             reduce using rule 39 (term -> IDENTIFIER .)
    OR              reduce using rule 39 (term -> IDENTIFIER .)
    WHILE           reduce using rule 39 (term -> IDENTIFIER .)
    FOR             reduce using rule 39 (term -> IDENTIFIER .)
    IF              reduce using rule 39 (term -> IDENTIFIER .)
    INPUT           reduce using rule 39 (term -> IDENTIFIER .)
    PRINT           reduce using rule 39 (term -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 39 (term -> IDENTIFIER .)
    NOT             reduce using rule 39 (term -> IDENTIFIER .)
    LPAREN          reduce using rule 39 (term -> IDENTIFIER .)
    INTEGER         reduce using rule 39 (term -> IDENTIFIER .)
    FLOAT           reduce using rule 39 (term -> IDENTIFIER .)
    CHARACTER       reduce using rule 39 (term -> IDENTIFIER .)
    STRING          reduce using rule 39 (term -> IDENTIFIER .)
    TRUE            reduce using rule 39 (term -> IDENTIFIER .)
    FALSE           reduce using rule 39 (term -> IDENTIFIER .)
    $end            reduce using rule 39 (term -> IDENTIFIER .)
    COLON           reduce using rule 39 (term -> IDENTIFIER .)
    COMMA           reduce using rule 39 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 39 (term -> IDENTIFIER .)
    ENDWHILE        reduce using rule 39 (term -> IDENTIFIER .)
    ELSE            reduce using rule 39 (term -> IDENTIFIER .)
    ENDIF           reduce using rule 39 (term -> IDENTIFIER .)
    ENDFOR          reduce using rule 39 (term -> IDENTIFIER .)
    LBRACKET        shift and go to state 41

  ! LBRACKET        [ reduce using rule 39 (term -> IDENTIFIER .) ]


state 59

    (36) unary_statement -> NOT unary_statement .

    TIMES           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    DIVIDE          reduce using rule 36 (unary_statement -> NOT unary_statement .)
    MOD             reduce using rule 36 (unary_statement -> NOT unary_statement .)
    PLUS            reduce using rule 36 (unary_statement -> NOT unary_statement .)
    MINUS           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    LT              reduce using rule 36 (unary_statement -> NOT unary_statement .)
    GT              reduce using rule 36 (unary_statement -> NOT unary_statement .)
    LTEQ            reduce using rule 36 (unary_statement -> NOT unary_statement .)
    GTEQ            reduce using rule 36 (unary_statement -> NOT unary_statement .)
    EQ              reduce using rule 36 (unary_statement -> NOT unary_statement .)
    NEQ             reduce using rule 36 (unary_statement -> NOT unary_statement .)
    AND             reduce using rule 36 (unary_statement -> NOT unary_statement .)
    OR              reduce using rule 36 (unary_statement -> NOT unary_statement .)
    WHILE           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    FOR             reduce using rule 36 (unary_statement -> NOT unary_statement .)
    IF              reduce using rule 36 (unary_statement -> NOT unary_statement .)
    INPUT           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    PRINT           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    IDENTIFIER      reduce using rule 36 (unary_statement -> NOT unary_statement .)
    NOT             reduce using rule 36 (unary_statement -> NOT unary_statement .)
    LPAREN          reduce using rule 36 (unary_statement -> NOT unary_statement .)
    INTEGER         reduce using rule 36 (unary_statement -> NOT unary_statement .)
    FLOAT           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    CHARACTER       reduce using rule 36 (unary_statement -> NOT unary_statement .)
    STRING          reduce using rule 36 (unary_statement -> NOT unary_statement .)
    TRUE            reduce using rule 36 (unary_statement -> NOT unary_statement .)
    FALSE           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    LBRACKET        reduce using rule 36 (unary_statement -> NOT unary_statement .)
    $end            reduce using rule 36 (unary_statement -> NOT unary_statement .)
    COLON           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    COMMA           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    RPAREN          reduce using rule 36 (unary_statement -> NOT unary_statement .)
    ENDWHILE        reduce using rule 36 (unary_statement -> NOT unary_statement .)
    ELSE            reduce using rule 36 (unary_statement -> NOT unary_statement .)
    ENDIF           reduce using rule 36 (unary_statement -> NOT unary_statement .)
    ENDFOR          reduce using rule 36 (unary_statement -> NOT unary_statement .)


state 60

    (48) atom -> LBRACKET elements . RBRACKET
    (50) elements -> elements . INTEGER
    (51) elements -> elements . FLOAT

    RBRACKET        shift and go to state 83
    INTEGER         shift and go to state 84
    FLOAT           shift and go to state 85


state 61

    (8) iterative_statement -> WHILE expression COLON . start ENDWHILE
    (1) start -> .
    (2) start -> . start code_entity

    ENDWHILE        reduce using rule 1 (start -> .)
    WHILE           reduce using rule 1 (start -> .)
    FOR             reduce using rule 1 (start -> .)
    IF              reduce using rule 1 (start -> .)
    INPUT           reduce using rule 1 (start -> .)
    PRINT           reduce using rule 1 (start -> .)
    IDENTIFIER      reduce using rule 1 (start -> .)
    MINUS           reduce using rule 1 (start -> .)
    NOT             reduce using rule 1 (start -> .)
    LPAREN          reduce using rule 1 (start -> .)
    INTEGER         reduce using rule 1 (start -> .)
    FLOAT           reduce using rule 1 (start -> .)
    CHARACTER       reduce using rule 1 (start -> .)
    STRING          reduce using rule 1 (start -> .)
    TRUE            reduce using rule 1 (start -> .)
    FALSE           reduce using rule 1 (start -> .)
    LBRACKET        reduce using rule 1 (start -> .)

    start                          shift and go to state 86

state 62

    (9) iterative_statement -> FOR expression COMMA . expression COMMA expression COLON start ENDFOR
    (12) expression -> . assignment_statement
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 87
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 63

    (10) conditional_statement -> IF expression COLON . start ELSE start ENDIF
    (11) conditional_statement -> IF expression COLON . start ENDIF
    (1) start -> .
    (2) start -> . start code_entity

    ELSE            reduce using rule 1 (start -> .)
    ENDIF           reduce using rule 1 (start -> .)
    WHILE           reduce using rule 1 (start -> .)
    FOR             reduce using rule 1 (start -> .)
    IF              reduce using rule 1 (start -> .)
    INPUT           reduce using rule 1 (start -> .)
    PRINT           reduce using rule 1 (start -> .)
    IDENTIFIER      reduce using rule 1 (start -> .)
    MINUS           reduce using rule 1 (start -> .)
    NOT             reduce using rule 1 (start -> .)
    LPAREN          reduce using rule 1 (start -> .)
    INTEGER         reduce using rule 1 (start -> .)
    FLOAT           reduce using rule 1 (start -> .)
    CHARACTER       reduce using rule 1 (start -> .)
    STRING          reduce using rule 1 (start -> .)
    TRUE            reduce using rule 1 (start -> .)
    FALSE           reduce using rule 1 (start -> .)
    LBRACKET        reduce using rule 1 (start -> .)

    start                          shift and go to state 88

state 64

    (53) input_function -> INPUT LPAREN IDENTIFIER . RPAREN

    RPAREN          shift and go to state 89


state 65

    (41) term -> LPAREN expression RPAREN .

    POWER           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 41 (term -> LPAREN expression RPAREN .)
    MOD             reduce using rule 41 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 41 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    LT              reduce using rule 41 (term -> LPAREN expression RPAREN .)
    GT              reduce using rule 41 (term -> LPAREN expression RPAREN .)
    LTEQ            reduce using rule 41 (term -> LPAREN expression RPAREN .)
    GTEQ            reduce using rule 41 (term -> LPAREN expression RPAREN .)
    EQ              reduce using rule 41 (term -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 41 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 41 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 41 (term -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    FOR             reduce using rule 41 (term -> LPAREN expression RPAREN .)
    IF              reduce using rule 41 (term -> LPAREN expression RPAREN .)
    INPUT           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 41 (term -> LPAREN expression RPAREN .)
    NOT             reduce using rule 41 (term -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 41 (term -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 41 (term -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    CHARACTER       reduce using rule 41 (term -> LPAREN expression RPAREN .)
    STRING          reduce using rule 41 (term -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 41 (term -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 41 (term -> LPAREN expression RPAREN .)
    $end            reduce using rule 41 (term -> LPAREN expression RPAREN .)
    COLON           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 41 (term -> LPAREN expression RPAREN .)
    ENDWHILE        reduce using rule 41 (term -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 41 (term -> LPAREN expression RPAREN .)
    ENDIF           reduce using rule 41 (term -> LPAREN expression RPAREN .)
    ENDFOR          reduce using rule 41 (term -> LPAREN expression RPAREN .)


state 66

    (14) assignment_statement -> IDENTIFIER EQUALS or_statement .
    (16) or_statement -> or_statement . OR and_statement

    WHILE           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    FOR             reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    IF              reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    INPUT           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    PRINT           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    IDENTIFIER      reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    MINUS           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    NOT             reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    LPAREN          reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    INTEGER         reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    FLOAT           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    CHARACTER       reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    STRING          reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    TRUE            reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    FALSE           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    LBRACKET        reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    $end            reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COLON           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    COMMA           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    RPAREN          reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDWHILE        reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ELSE            reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDIF           reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    ENDFOR          reduce using rule 14 (assignment_statement -> IDENTIFIER EQUALS or_statement .)
    OR              shift and go to state 44


state 67

    (49) atom -> IDENTIFIER LBRACKET INTEGER . RBRACKET

    RBRACKET        shift and go to state 90


state 68

    (54) output_function -> PRINT LPAREN term . RPAREN

    RPAREN          shift and go to state 91


state 69

    (38) exponent -> term POWER unary_statement .

    TIMES           reduce using rule 38 (exponent -> term POWER unary_statement .)
    DIVIDE          reduce using rule 38 (exponent -> term POWER unary_statement .)
    MOD             reduce using rule 38 (exponent -> term POWER unary_statement .)
    PLUS            reduce using rule 38 (exponent -> term POWER unary_statement .)
    MINUS           reduce using rule 38 (exponent -> term POWER unary_statement .)
    LT              reduce using rule 38 (exponent -> term POWER unary_statement .)
    GT              reduce using rule 38 (exponent -> term POWER unary_statement .)
    LTEQ            reduce using rule 38 (exponent -> term POWER unary_statement .)
    GTEQ            reduce using rule 38 (exponent -> term POWER unary_statement .)
    EQ              reduce using rule 38 (exponent -> term POWER unary_statement .)
    NEQ             reduce using rule 38 (exponent -> term POWER unary_statement .)
    AND             reduce using rule 38 (exponent -> term POWER unary_statement .)
    OR              reduce using rule 38 (exponent -> term POWER unary_statement .)
    WHILE           reduce using rule 38 (exponent -> term POWER unary_statement .)
    FOR             reduce using rule 38 (exponent -> term POWER unary_statement .)
    IF              reduce using rule 38 (exponent -> term POWER unary_statement .)
    INPUT           reduce using rule 38 (exponent -> term POWER unary_statement .)
    PRINT           reduce using rule 38 (exponent -> term POWER unary_statement .)
    IDENTIFIER      reduce using rule 38 (exponent -> term POWER unary_statement .)
    NOT             reduce using rule 38 (exponent -> term POWER unary_statement .)
    LPAREN          reduce using rule 38 (exponent -> term POWER unary_statement .)
    INTEGER         reduce using rule 38 (exponent -> term POWER unary_statement .)
    FLOAT           reduce using rule 38 (exponent -> term POWER unary_statement .)
    CHARACTER       reduce using rule 38 (exponent -> term POWER unary_statement .)
    STRING          reduce using rule 38 (exponent -> term POWER unary_statement .)
    TRUE            reduce using rule 38 (exponent -> term POWER unary_statement .)
    FALSE           reduce using rule 38 (exponent -> term POWER unary_statement .)
    LBRACKET        reduce using rule 38 (exponent -> term POWER unary_statement .)
    $end            reduce using rule 38 (exponent -> term POWER unary_statement .)
    COLON           reduce using rule 38 (exponent -> term POWER unary_statement .)
    COMMA           reduce using rule 38 (exponent -> term POWER unary_statement .)
    RPAREN          reduce using rule 38 (exponent -> term POWER unary_statement .)
    ENDWHILE        reduce using rule 38 (exponent -> term POWER unary_statement .)
    ELSE            reduce using rule 38 (exponent -> term POWER unary_statement .)
    ENDIF           reduce using rule 38 (exponent -> term POWER unary_statement .)
    ENDFOR          reduce using rule 38 (exponent -> term POWER unary_statement .)


state 70

    (16) or_statement -> or_statement OR and_statement .
    (18) and_statement -> and_statement . AND equality_statement

    OR              reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    WHILE           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    FOR             reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    IF              reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    INPUT           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    PRINT           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    IDENTIFIER      reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    MINUS           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    NOT             reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    LPAREN          reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    INTEGER         reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    FLOAT           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    CHARACTER       reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    STRING          reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    TRUE            reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    FALSE           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    LBRACKET        reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    $end            reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    COLON           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    COMMA           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    RPAREN          reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    ENDWHILE        reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    ELSE            reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    ENDIF           reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    ENDFOR          reduce using rule 16 (or_statement -> or_statement OR and_statement .)
    AND             shift and go to state 45


state 71

    (18) and_statement -> and_statement AND equality_statement .
    (20) equality_statement -> equality_statement . EQ relational_statement
    (21) equality_statement -> equality_statement . NEQ relational_statement

    AND             reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    OR              reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    WHILE           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    FOR             reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    IF              reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    INPUT           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    PRINT           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    IDENTIFIER      reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    MINUS           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    NOT             reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    LPAREN          reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    INTEGER         reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    FLOAT           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    CHARACTER       reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    STRING          reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    TRUE            reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    FALSE           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    LBRACKET        reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    $end            reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    COLON           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    COMMA           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    RPAREN          reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    ENDWHILE        reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    ELSE            reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    ENDIF           reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    ENDFOR          reduce using rule 18 (and_statement -> and_statement AND equality_statement .)
    EQ              shift and go to state 46
    NEQ             shift and go to state 47


state 72

    (20) equality_statement -> equality_statement EQ relational_statement .
    (23) relational_statement -> relational_statement . LT add_statement
    (24) relational_statement -> relational_statement . GT add_statement
    (25) relational_statement -> relational_statement . LTEQ add_statement
    (26) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    NEQ             reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    AND             reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    OR              reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    WHILE           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    FOR             reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    IF              reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    INPUT           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    PRINT           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    IDENTIFIER      reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    MINUS           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    NOT             reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    LPAREN          reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    INTEGER         reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    FLOAT           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    CHARACTER       reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    STRING          reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    TRUE            reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    FALSE           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    LBRACKET        reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    $end            reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    COLON           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    COMMA           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    RPAREN          reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    ENDWHILE        reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    ELSE            reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    ENDIF           reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    ENDFOR          reduce using rule 20 (equality_statement -> equality_statement EQ relational_statement .)
    LT              shift and go to state 48
    GT              shift and go to state 49
    LTEQ            shift and go to state 50
    GTEQ            shift and go to state 51


state 73

    (21) equality_statement -> equality_statement NEQ relational_statement .
    (23) relational_statement -> relational_statement . LT add_statement
    (24) relational_statement -> relational_statement . GT add_statement
    (25) relational_statement -> relational_statement . LTEQ add_statement
    (26) relational_statement -> relational_statement . GTEQ add_statement

    EQ              reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    NEQ             reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    AND             reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    OR              reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    WHILE           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    FOR             reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    IF              reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    INPUT           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    PRINT           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    IDENTIFIER      reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    MINUS           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    NOT             reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    LPAREN          reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    INTEGER         reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    FLOAT           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    CHARACTER       reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    STRING          reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    TRUE            reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    FALSE           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    LBRACKET        reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    $end            reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    COLON           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    COMMA           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    RPAREN          reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDWHILE        reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    ELSE            reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDIF           reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    ENDFOR          reduce using rule 21 (equality_statement -> equality_statement NEQ relational_statement .)
    LT              shift and go to state 48
    GT              shift and go to state 49
    LTEQ            shift and go to state 50
    GTEQ            shift and go to state 51


state 74

    (23) relational_statement -> relational_statement LT add_statement .
    (28) add_statement -> add_statement . PLUS multiply_statement
    (29) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    GT              reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    LTEQ            reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    GTEQ            reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    EQ              reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    NEQ             reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    AND             reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    OR              reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    WHILE           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    FOR             reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    IF              reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    INPUT           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    PRINT           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    IDENTIFIER      reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    NOT             reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    LPAREN          reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    INTEGER         reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    FLOAT           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    CHARACTER       reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    STRING          reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    TRUE            reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    FALSE           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    LBRACKET        reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    $end            reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    COLON           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    COMMA           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    RPAREN          reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    ENDWHILE        reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    ELSE            reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    ENDIF           reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    ENDFOR          reduce using rule 23 (relational_statement -> relational_statement LT add_statement .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53

  ! MINUS           [ reduce using rule 23 (relational_statement -> relational_statement LT add_statement .) ]


state 75

    (24) relational_statement -> relational_statement GT add_statement .
    (28) add_statement -> add_statement . PLUS multiply_statement
    (29) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    GT              reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    LTEQ            reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    GTEQ            reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    EQ              reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    NEQ             reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    AND             reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    OR              reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    WHILE           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    FOR             reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    IF              reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    INPUT           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    PRINT           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    IDENTIFIER      reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    NOT             reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    LPAREN          reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    INTEGER         reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    FLOAT           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    CHARACTER       reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    STRING          reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    TRUE            reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    FALSE           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    LBRACKET        reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    $end            reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    COLON           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    COMMA           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    RPAREN          reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    ENDWHILE        reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    ELSE            reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    ENDIF           reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    ENDFOR          reduce using rule 24 (relational_statement -> relational_statement GT add_statement .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53

  ! MINUS           [ reduce using rule 24 (relational_statement -> relational_statement GT add_statement .) ]


state 76

    (25) relational_statement -> relational_statement LTEQ add_statement .
    (28) add_statement -> add_statement . PLUS multiply_statement
    (29) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    GT              reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    LTEQ            reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    GTEQ            reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    EQ              reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    NEQ             reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    AND             reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    OR              reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    WHILE           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    FOR             reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    IF              reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    INPUT           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    PRINT           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    IDENTIFIER      reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    NOT             reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    LPAREN          reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    INTEGER         reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    FLOAT           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    CHARACTER       reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    STRING          reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    TRUE            reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    FALSE           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    LBRACKET        reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    $end            reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    COLON           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    COMMA           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    RPAREN          reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDWHILE        reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    ELSE            reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDIF           reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    ENDFOR          reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53

  ! MINUS           [ reduce using rule 25 (relational_statement -> relational_statement LTEQ add_statement .) ]


state 77

    (26) relational_statement -> relational_statement GTEQ add_statement .
    (28) add_statement -> add_statement . PLUS multiply_statement
    (29) add_statement -> add_statement . MINUS multiply_statement

  ! shift/reduce conflict for MINUS resolved as shift
    LT              reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    GT              reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    LTEQ            reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    GTEQ            reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    EQ              reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    NEQ             reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    AND             reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    OR              reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    WHILE           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    FOR             reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    IF              reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    INPUT           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    PRINT           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    IDENTIFIER      reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    NOT             reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    LPAREN          reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    INTEGER         reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    FLOAT           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    CHARACTER       reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    STRING          reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    TRUE            reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    FALSE           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    LBRACKET        reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    $end            reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    COLON           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    COMMA           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    RPAREN          reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDWHILE        reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    ELSE            reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDIF           reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    ENDFOR          reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53

  ! MINUS           [ reduce using rule 26 (relational_statement -> relational_statement GTEQ add_statement .) ]


state 78

    (28) add_statement -> add_statement PLUS multiply_statement .
    (31) multiply_statement -> multiply_statement . TIMES unary_statement
    (32) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (33) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    MINUS           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    LT              reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    GT              reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    LTEQ            reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    GTEQ            reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    EQ              reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    NEQ             reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    AND             reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    OR              reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    WHILE           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    FOR             reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    IF              reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    INPUT           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    PRINT           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    IDENTIFIER      reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    NOT             reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    LPAREN          reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    INTEGER         reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    FLOAT           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    CHARACTER       reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    STRING          reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    TRUE            reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    FALSE           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    LBRACKET        reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    $end            reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    COLON           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    COMMA           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    RPAREN          reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    ENDWHILE        reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    ELSE            reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    ENDIF           reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    ENDFOR          reduce using rule 28 (add_statement -> add_statement PLUS multiply_statement .)
    TIMES           shift and go to state 54
    DIVIDE          shift and go to state 55
    MOD             shift and go to state 56


state 79

    (29) add_statement -> add_statement MINUS multiply_statement .
    (31) multiply_statement -> multiply_statement . TIMES unary_statement
    (32) multiply_statement -> multiply_statement . DIVIDE unary_statement
    (33) multiply_statement -> multiply_statement . MOD unary_statement

    PLUS            reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    MINUS           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    LT              reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    GT              reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    LTEQ            reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    GTEQ            reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    EQ              reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    NEQ             reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    AND             reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    OR              reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    WHILE           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    FOR             reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    IF              reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    INPUT           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    PRINT           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    IDENTIFIER      reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    NOT             reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    LPAREN          reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    INTEGER         reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    FLOAT           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    CHARACTER       reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    STRING          reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    TRUE            reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    FALSE           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    LBRACKET        reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    $end            reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    COLON           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    COMMA           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    RPAREN          reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    ENDWHILE        reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    ELSE            reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    ENDIF           reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    ENDFOR          reduce using rule 29 (add_statement -> add_statement MINUS multiply_statement .)
    TIMES           shift and go to state 54
    DIVIDE          shift and go to state 55
    MOD             shift and go to state 56


state 80

    (31) multiply_statement -> multiply_statement TIMES unary_statement .

    TIMES           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    DIVIDE          reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MOD             reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    PLUS            reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    MINUS           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LT              reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GT              reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LTEQ            reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    GTEQ            reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    EQ              reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    NEQ             reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    AND             reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    OR              reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    WHILE           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FOR             reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    IF              reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    INPUT           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    PRINT           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    IDENTIFIER      reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    NOT             reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LPAREN          reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    INTEGER         reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FLOAT           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    CHARACTER       reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    STRING          reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    TRUE            reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    FALSE           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    LBRACKET        reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    $end            reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COLON           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    COMMA           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    RPAREN          reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDWHILE        reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ELSE            reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDIF           reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)
    ENDFOR          reduce using rule 31 (multiply_statement -> multiply_statement TIMES unary_statement .)


state 81

    (32) multiply_statement -> multiply_statement DIVIDE unary_statement .

    TIMES           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    DIVIDE          reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MOD             reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    PLUS            reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    MINUS           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LT              reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GT              reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LTEQ            reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    GTEQ            reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    EQ              reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    NEQ             reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    AND             reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    OR              reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    WHILE           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FOR             reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    IF              reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    INPUT           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    PRINT           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    IDENTIFIER      reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    NOT             reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LPAREN          reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    INTEGER         reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FLOAT           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    CHARACTER       reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    STRING          reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    TRUE            reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    FALSE           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    LBRACKET        reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    $end            reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COLON           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    COMMA           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    RPAREN          reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDWHILE        reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ELSE            reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDIF           reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)
    ENDFOR          reduce using rule 32 (multiply_statement -> multiply_statement DIVIDE unary_statement .)


state 82

    (33) multiply_statement -> multiply_statement MOD unary_statement .

    TIMES           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    DIVIDE          reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    MOD             reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    PLUS            reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    MINUS           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    LT              reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    GT              reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    LTEQ            reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    GTEQ            reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    EQ              reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    NEQ             reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    AND             reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    OR              reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    WHILE           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    FOR             reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    IF              reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    INPUT           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    PRINT           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    IDENTIFIER      reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    NOT             reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    LPAREN          reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    INTEGER         reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    FLOAT           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    CHARACTER       reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    STRING          reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    TRUE            reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    FALSE           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    LBRACKET        reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    $end            reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    COLON           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    COMMA           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    RPAREN          reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDWHILE        reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    ELSE            reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDIF           reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)
    ENDFOR          reduce using rule 33 (multiply_statement -> multiply_statement MOD unary_statement .)


state 83

    (48) atom -> LBRACKET elements RBRACKET .

    POWER           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    TIMES           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    DIVIDE          reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    MOD             reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    PLUS            reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    MINUS           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    LT              reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    GT              reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    LTEQ            reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    GTEQ            reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    EQ              reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    NEQ             reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    AND             reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    OR              reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    WHILE           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    FOR             reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    IF              reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    INPUT           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    PRINT           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    IDENTIFIER      reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    NOT             reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    LPAREN          reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    INTEGER         reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    FLOAT           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    CHARACTER       reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    STRING          reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    TRUE            reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    FALSE           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    LBRACKET        reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    $end            reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    COLON           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    COMMA           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    RPAREN          reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    ENDWHILE        reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    ELSE            reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    ENDIF           reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)
    ENDFOR          reduce using rule 48 (atom -> LBRACKET elements RBRACKET .)


state 84

    (50) elements -> elements INTEGER .

    RBRACKET        reduce using rule 50 (elements -> elements INTEGER .)
    INTEGER         reduce using rule 50 (elements -> elements INTEGER .)
    FLOAT           reduce using rule 50 (elements -> elements INTEGER .)


state 85

    (51) elements -> elements FLOAT .

    RBRACKET        reduce using rule 51 (elements -> elements FLOAT .)
    INTEGER         reduce using rule 51 (elements -> elements FLOAT .)
    FLOAT           reduce using rule 51 (elements -> elements FLOAT .)


state 86

    (8) iterative_statement -> WHILE expression COLON start . ENDWHILE
    (2) start -> start . code_entity
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    ENDWHILE        shift and go to state 92
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 5
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 87

    (9) iterative_statement -> FOR expression COMMA expression . COMMA expression COLON start ENDFOR

    COMMA           shift and go to state 93


state 88

    (10) conditional_statement -> IF expression COLON start . ELSE start ENDIF
    (11) conditional_statement -> IF expression COLON start . ENDIF
    (2) start -> start . code_entity
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    ELSE            shift and go to state 94
    ENDIF           shift and go to state 95
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 5
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 89

    (53) input_function -> INPUT LPAREN IDENTIFIER RPAREN .

    WHILE           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    FOR             reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    IF              reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    INPUT           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    PRINT           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    IDENTIFIER      reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    MINUS           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    NOT             reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    LPAREN          reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    INTEGER         reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    FLOAT           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    CHARACTER       reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    STRING          reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    TRUE            reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    FALSE           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    LBRACKET        reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    $end            reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDWHILE        reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ELSE            reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDIF           reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)
    ENDFOR          reduce using rule 53 (input_function -> INPUT LPAREN IDENTIFIER RPAREN .)


state 90

    (49) atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .

    POWER           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TIMES           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    DIVIDE          reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MOD             reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PLUS            reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    MINUS           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LT              reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GT              reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LTEQ            reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    GTEQ            reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    EQ              reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NEQ             reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    AND             reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    OR              reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    WHILE           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FOR             reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    IF              reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    INPUT           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    PRINT           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    IDENTIFIER      reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    NOT             reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LPAREN          reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    INTEGER         reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FLOAT           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    CHARACTER       reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    STRING          reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    TRUE            reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    FALSE           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    LBRACKET        reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    $end            reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COLON           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    COMMA           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    RPAREN          reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDWHILE        reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ELSE            reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDIF           reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)
    ENDFOR          reduce using rule 49 (atom -> IDENTIFIER LBRACKET INTEGER RBRACKET .)


state 91

    (54) output_function -> PRINT LPAREN term RPAREN .

    WHILE           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    FOR             reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    IF              reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    INPUT           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    PRINT           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    IDENTIFIER      reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    MINUS           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    NOT             reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    LPAREN          reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    INTEGER         reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    FLOAT           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    CHARACTER       reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    STRING          reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    TRUE            reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    FALSE           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    LBRACKET        reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    $end            reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ENDWHILE        reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ELSE            reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ENDIF           reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)
    ENDFOR          reduce using rule 54 (output_function -> PRINT LPAREN term RPAREN .)


state 92

    (8) iterative_statement -> WHILE expression COLON start ENDWHILE .

    WHILE           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    FOR             reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    IF              reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    INPUT           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    PRINT           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    IDENTIFIER      reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    MINUS           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    NOT             reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    LPAREN          reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    INTEGER         reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    FLOAT           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    CHARACTER       reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    STRING          reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    TRUE            reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    FALSE           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    LBRACKET        reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    $end            reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDWHILE        reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ELSE            reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDIF           reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)
    ENDFOR          reduce using rule 8 (iterative_statement -> WHILE expression COLON start ENDWHILE .)


state 93

    (9) iterative_statement -> FOR expression COMMA expression COMMA . expression COLON start ENDFOR
    (12) expression -> . assignment_statement
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 96
    assignment_statement           shift and go to state 11
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    term                           shift and go to state 16
    atom                           shift and go to state 27

state 94

    (10) conditional_statement -> IF expression COLON start ELSE . start ENDIF
    (1) start -> .
    (2) start -> . start code_entity

    ENDIF           reduce using rule 1 (start -> .)
    WHILE           reduce using rule 1 (start -> .)
    FOR             reduce using rule 1 (start -> .)
    IF              reduce using rule 1 (start -> .)
    INPUT           reduce using rule 1 (start -> .)
    PRINT           reduce using rule 1 (start -> .)
    IDENTIFIER      reduce using rule 1 (start -> .)
    MINUS           reduce using rule 1 (start -> .)
    NOT             reduce using rule 1 (start -> .)
    LPAREN          reduce using rule 1 (start -> .)
    INTEGER         reduce using rule 1 (start -> .)
    FLOAT           reduce using rule 1 (start -> .)
    CHARACTER       reduce using rule 1 (start -> .)
    STRING          reduce using rule 1 (start -> .)
    TRUE            reduce using rule 1 (start -> .)
    FALSE           reduce using rule 1 (start -> .)
    LBRACKET        reduce using rule 1 (start -> .)

    start                          shift and go to state 97

state 95

    (11) conditional_statement -> IF expression COLON start ENDIF .

    WHILE           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    FOR             reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    IF              reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    INPUT           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    PRINT           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    IDENTIFIER      reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    MINUS           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    NOT             reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    LPAREN          reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    INTEGER         reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    FLOAT           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    CHARACTER       reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    STRING          reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    TRUE            reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    FALSE           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    LBRACKET        reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    $end            reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDWHILE        reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ELSE            reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDIF           reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)
    ENDFOR          reduce using rule 11 (conditional_statement -> IF expression COLON start ENDIF .)


state 96

    (9) iterative_statement -> FOR expression COMMA expression COMMA expression . COLON start ENDFOR

    COLON           shift and go to state 98


state 97

    (10) conditional_statement -> IF expression COLON start ELSE start . ENDIF
    (2) start -> start . code_entity
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    ENDIF           shift and go to state 99
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 5
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 98

    (9) iterative_statement -> FOR expression COMMA expression COMMA expression COLON . start ENDFOR
    (1) start -> .
    (2) start -> . start code_entity

    ENDFOR          reduce using rule 1 (start -> .)
    WHILE           reduce using rule 1 (start -> .)
    FOR             reduce using rule 1 (start -> .)
    IF              reduce using rule 1 (start -> .)
    INPUT           reduce using rule 1 (start -> .)
    PRINT           reduce using rule 1 (start -> .)
    IDENTIFIER      reduce using rule 1 (start -> .)
    MINUS           reduce using rule 1 (start -> .)
    NOT             reduce using rule 1 (start -> .)
    LPAREN          reduce using rule 1 (start -> .)
    INTEGER         reduce using rule 1 (start -> .)
    FLOAT           reduce using rule 1 (start -> .)
    CHARACTER       reduce using rule 1 (start -> .)
    STRING          reduce using rule 1 (start -> .)
    TRUE            reduce using rule 1 (start -> .)
    FALSE           reduce using rule 1 (start -> .)
    LBRACKET        reduce using rule 1 (start -> .)

    start                          shift and go to state 100

state 99

    (10) conditional_statement -> IF expression COLON start ELSE start ENDIF .

    WHILE           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    FOR             reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    IF              reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    INPUT           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    PRINT           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    IDENTIFIER      reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    MINUS           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    NOT             reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    LPAREN          reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    INTEGER         reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    FLOAT           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    CHARACTER       reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    STRING          reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    TRUE            reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    FALSE           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    LBRACKET        reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    $end            reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDWHILE        reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ELSE            reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDIF           reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)
    ENDFOR          reduce using rule 10 (conditional_statement -> IF expression COLON start ELSE start ENDIF .)


state 100

    (9) iterative_statement -> FOR expression COMMA expression COMMA expression COLON start . ENDFOR
    (2) start -> start . code_entity
    (3) code_entity -> . iterative_statement
    (4) code_entity -> . conditional_statement
    (5) code_entity -> . expression
    (6) code_entity -> . input_function
    (7) code_entity -> . output_function
    (8) iterative_statement -> . WHILE expression COLON start ENDWHILE
    (9) iterative_statement -> . FOR expression COMMA expression COMMA expression COLON start ENDFOR
    (10) conditional_statement -> . IF expression COLON start ELSE start ENDIF
    (11) conditional_statement -> . IF expression COLON start ENDIF
    (12) expression -> . assignment_statement
    (53) input_function -> . INPUT LPAREN IDENTIFIER RPAREN
    (54) output_function -> . PRINT LPAREN term RPAREN
    (13) assignment_statement -> . or_statement
    (14) assignment_statement -> . IDENTIFIER EQUALS or_statement
    (15) or_statement -> . and_statement
    (16) or_statement -> . or_statement OR and_statement
    (17) and_statement -> . equality_statement
    (18) and_statement -> . and_statement AND equality_statement
    (19) equality_statement -> . relational_statement
    (20) equality_statement -> . equality_statement EQ relational_statement
    (21) equality_statement -> . equality_statement NEQ relational_statement
    (22) relational_statement -> . add_statement
    (23) relational_statement -> . relational_statement LT add_statement
    (24) relational_statement -> . relational_statement GT add_statement
    (25) relational_statement -> . relational_statement LTEQ add_statement
    (26) relational_statement -> . relational_statement GTEQ add_statement
    (27) add_statement -> . multiply_statement
    (28) add_statement -> . add_statement PLUS multiply_statement
    (29) add_statement -> . add_statement MINUS multiply_statement
    (30) multiply_statement -> . unary_statement
    (31) multiply_statement -> . multiply_statement TIMES unary_statement
    (32) multiply_statement -> . multiply_statement DIVIDE unary_statement
    (33) multiply_statement -> . multiply_statement MOD unary_statement
    (34) unary_statement -> . exponent
    (35) unary_statement -> . MINUS unary_statement
    (36) unary_statement -> . NOT unary_statement
    (37) exponent -> . term
    (38) exponent -> . term POWER unary_statement
    (39) term -> . IDENTIFIER
    (40) term -> . atom
    (41) term -> . LPAREN expression RPAREN
    (42) atom -> . INTEGER
    (43) atom -> . FLOAT
    (44) atom -> . CHARACTER
    (45) atom -> . STRING
    (46) atom -> . TRUE
    (47) atom -> . FALSE
    (48) atom -> . LBRACKET elements RBRACKET
    (49) atom -> . IDENTIFIER LBRACKET INTEGER RBRACKET

    ENDFOR          shift and go to state 101
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    IF              shift and go to state 10
    INPUT           shift and go to state 12
    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 14
    MINUS           shift and go to state 23
    NOT             shift and go to state 26
    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 28
    FLOAT           shift and go to state 29
    CHARACTER       shift and go to state 30
    STRING          shift and go to state 31
    TRUE            shift and go to state 32
    FALSE           shift and go to state 33
    LBRACKET        shift and go to state 34

    expression                     shift and go to state 5
    code_entity                    shift and go to state 2
    iterative_statement            shift and go to state 3
    conditional_statement          shift and go to state 4
    input_function                 shift and go to state 6
    output_function                shift and go to state 7
    assignment_statement           shift and go to state 11
    term                           shift and go to state 16
    or_statement                   shift and go to state 17
    and_statement                  shift and go to state 18
    equality_statement             shift and go to state 19
    relational_statement           shift and go to state 20
    add_statement                  shift and go to state 21
    multiply_statement             shift and go to state 22
    unary_statement                shift and go to state 24
    exponent                       shift and go to state 25
    atom                           shift and go to state 27

state 101

    (9) iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .

    WHILE           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    FOR             reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    IF              reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    INPUT           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    PRINT           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    IDENTIFIER      reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    MINUS           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    NOT             reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    LPAREN          reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    INTEGER         reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    FLOAT           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    CHARACTER       reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    STRING          reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    TRUE            reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    FALSE           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    LBRACKET        reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    $end            reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDWHILE        reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    ELSE            reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDIF           reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)
    ENDFOR          reduce using rule 9 (iterative_statement -> FOR expression COMMA expression COMMA expression COLON start ENDFOR .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACKET in state 14 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 21 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 75 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 77 resolved as shift
